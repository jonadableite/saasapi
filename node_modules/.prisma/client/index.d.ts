
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model CompaniesUnites
 * 
 */
export type CompaniesUnites = $Result.DefaultSelection<Prisma.$CompaniesUnitesPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Bot_Descritivo
 * 
 */
export type Bot_Descritivo = $Result.DefaultSelection<Prisma.$Bot_DescritivoPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Instance
 * 
 */
export type Instance = $Result.DefaultSelection<Prisma.$InstancePayload>
/**
 * Model MediaStats
 * 
 */
export type MediaStats = $Result.DefaultSelection<Prisma.$MediaStatsPayload>
/**
 * Model WarmupStats
 * 
 */
export type WarmupStats = $Result.DefaultSelection<Prisma.$WarmupStatsPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignMessage
 * 
 */
export type CampaignMessage = $Result.DefaultSelection<Prisma.$CampaignMessagePayload>
/**
 * Model CampaignLead
 * 
 */
export type CampaignLead = $Result.DefaultSelection<Prisma.$CampaignLeadPayload>
/**
 * Model CampaignStatistics
 * 
 */
export type CampaignStatistics = $Result.DefaultSelection<Prisma.$CampaignStatisticsPayload>
/**
 * Model MessageLog
 * 
 */
export type MessageLog = $Result.DefaultSelection<Prisma.$MessageLogPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.companiesUnites`: Exposes CRUD operations for the **CompaniesUnites** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompaniesUnites
    * const companiesUnites = await prisma.companiesUnites.findMany()
    * ```
    */
  get companiesUnites(): Prisma.CompaniesUnitesDelegate<ExtArgs>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs>;

  /**
   * `prisma.bot_Descritivo`: Exposes CRUD operations for the **Bot_Descritivo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bot_Descritivos
    * const bot_Descritivos = await prisma.bot_Descritivo.findMany()
    * ```
    */
  get bot_Descritivo(): Prisma.Bot_DescritivoDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.instance`: Exposes CRUD operations for the **Instance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instances
    * const instances = await prisma.instance.findMany()
    * ```
    */
  get instance(): Prisma.InstanceDelegate<ExtArgs>;

  /**
   * `prisma.mediaStats`: Exposes CRUD operations for the **MediaStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaStats
    * const mediaStats = await prisma.mediaStats.findMany()
    * ```
    */
  get mediaStats(): Prisma.MediaStatsDelegate<ExtArgs>;

  /**
   * `prisma.warmupStats`: Exposes CRUD operations for the **WarmupStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarmupStats
    * const warmupStats = await prisma.warmupStats.findMany()
    * ```
    */
  get warmupStats(): Prisma.WarmupStatsDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.campaignMessage`: Exposes CRUD operations for the **CampaignMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignMessages
    * const campaignMessages = await prisma.campaignMessage.findMany()
    * ```
    */
  get campaignMessage(): Prisma.CampaignMessageDelegate<ExtArgs>;

  /**
   * `prisma.campaignLead`: Exposes CRUD operations for the **CampaignLead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignLeads
    * const campaignLeads = await prisma.campaignLead.findMany()
    * ```
    */
  get campaignLead(): Prisma.CampaignLeadDelegate<ExtArgs>;

  /**
   * `prisma.campaignStatistics`: Exposes CRUD operations for the **CampaignStatistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignStatistics
    * const campaignStatistics = await prisma.campaignStatistics.findMany()
    * ```
    */
  get campaignStatistics(): Prisma.CampaignStatisticsDelegate<ExtArgs>;

  /**
   * `prisma.messageLog`: Exposes CRUD operations for the **MessageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageLogs
    * const messageLogs = await prisma.messageLog.findMany()
    * ```
    */
  get messageLog(): Prisma.MessageLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.1.0
   * Query Engine version: 11f085a2012c0f4778414c8db2651556ee0ef959
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    User: 'User',
    CompaniesUnites: 'CompaniesUnites',
    Lead: 'Lead',
    Bot_Descritivo: 'Bot_Descritivo',
    Payment: 'Payment',
    Instance: 'Instance',
    MediaStats: 'MediaStats',
    WarmupStats: 'WarmupStats',
    Campaign: 'Campaign',
    CampaignMessage: 'CampaignMessage',
    CampaignLead: 'CampaignLead',
    CampaignStatistics: 'CampaignStatistics',
    MessageLog: 'MessageLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "company" | "user" | "companiesUnites" | "lead" | "bot_Descritivo" | "payment" | "instance" | "mediaStats" | "warmupStats" | "campaign" | "campaignMessage" | "campaignLead" | "campaignStatistics" | "messageLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      CompaniesUnites: {
        payload: Prisma.$CompaniesUnitesPayload<ExtArgs>
        fields: Prisma.CompaniesUnitesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompaniesUnitesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompaniesUnitesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>
          }
          findFirst: {
            args: Prisma.CompaniesUnitesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompaniesUnitesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>
          }
          findMany: {
            args: Prisma.CompaniesUnitesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>[]
          }
          create: {
            args: Prisma.CompaniesUnitesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>
          }
          createMany: {
            args: Prisma.CompaniesUnitesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompaniesUnitesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>[]
          }
          delete: {
            args: Prisma.CompaniesUnitesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>
          }
          update: {
            args: Prisma.CompaniesUnitesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>
          }
          deleteMany: {
            args: Prisma.CompaniesUnitesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompaniesUnitesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompaniesUnitesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesUnitesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompaniesUnites>
          }
          groupBy: {
            args: Prisma.CompaniesUnitesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesUnitesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompaniesUnitesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesUnitesCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Bot_Descritivo: {
        payload: Prisma.$Bot_DescritivoPayload<ExtArgs>
        fields: Prisma.Bot_DescritivoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Bot_DescritivoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Bot_DescritivoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Bot_DescritivoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Bot_DescritivoPayload>
          }
          findFirst: {
            args: Prisma.Bot_DescritivoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Bot_DescritivoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Bot_DescritivoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Bot_DescritivoPayload>
          }
          findMany: {
            args: Prisma.Bot_DescritivoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Bot_DescritivoPayload>[]
          }
          create: {
            args: Prisma.Bot_DescritivoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Bot_DescritivoPayload>
          }
          createMany: {
            args: Prisma.Bot_DescritivoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Bot_DescritivoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Bot_DescritivoPayload>[]
          }
          delete: {
            args: Prisma.Bot_DescritivoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Bot_DescritivoPayload>
          }
          update: {
            args: Prisma.Bot_DescritivoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Bot_DescritivoPayload>
          }
          deleteMany: {
            args: Prisma.Bot_DescritivoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Bot_DescritivoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Bot_DescritivoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Bot_DescritivoPayload>
          }
          aggregate: {
            args: Prisma.Bot_DescritivoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBot_Descritivo>
          }
          groupBy: {
            args: Prisma.Bot_DescritivoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bot_DescritivoGroupByOutputType>[]
          }
          count: {
            args: Prisma.Bot_DescritivoCountArgs<ExtArgs>
            result: $Utils.Optional<Bot_DescritivoCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Instance: {
        payload: Prisma.$InstancePayload<ExtArgs>
        fields: Prisma.InstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          findFirst: {
            args: Prisma.InstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          findMany: {
            args: Prisma.InstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>[]
          }
          create: {
            args: Prisma.InstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          createMany: {
            args: Prisma.InstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>[]
          }
          delete: {
            args: Prisma.InstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          update: {
            args: Prisma.InstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          deleteMany: {
            args: Prisma.InstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          aggregate: {
            args: Prisma.InstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstance>
          }
          groupBy: {
            args: Prisma.InstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstanceCountArgs<ExtArgs>
            result: $Utils.Optional<InstanceCountAggregateOutputType> | number
          }
        }
      }
      MediaStats: {
        payload: Prisma.$MediaStatsPayload<ExtArgs>
        fields: Prisma.MediaStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>
          }
          findFirst: {
            args: Prisma.MediaStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>
          }
          findMany: {
            args: Prisma.MediaStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>[]
          }
          create: {
            args: Prisma.MediaStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>
          }
          createMany: {
            args: Prisma.MediaStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>[]
          }
          delete: {
            args: Prisma.MediaStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>
          }
          update: {
            args: Prisma.MediaStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>
          }
          deleteMany: {
            args: Prisma.MediaStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>
          }
          aggregate: {
            args: Prisma.MediaStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaStats>
          }
          groupBy: {
            args: Prisma.MediaStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaStatsCountArgs<ExtArgs>
            result: $Utils.Optional<MediaStatsCountAggregateOutputType> | number
          }
        }
      }
      WarmupStats: {
        payload: Prisma.$WarmupStatsPayload<ExtArgs>
        fields: Prisma.WarmupStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarmupStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarmupStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>
          }
          findFirst: {
            args: Prisma.WarmupStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarmupStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>
          }
          findMany: {
            args: Prisma.WarmupStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>[]
          }
          create: {
            args: Prisma.WarmupStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>
          }
          createMany: {
            args: Prisma.WarmupStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarmupStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>[]
          }
          delete: {
            args: Prisma.WarmupStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>
          }
          update: {
            args: Prisma.WarmupStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>
          }
          deleteMany: {
            args: Prisma.WarmupStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarmupStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WarmupStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>
          }
          aggregate: {
            args: Prisma.WarmupStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarmupStats>
          }
          groupBy: {
            args: Prisma.WarmupStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarmupStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarmupStatsCountArgs<ExtArgs>
            result: $Utils.Optional<WarmupStatsCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignMessage: {
        payload: Prisma.$CampaignMessagePayload<ExtArgs>
        fields: Prisma.CampaignMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          findFirst: {
            args: Prisma.CampaignMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          findMany: {
            args: Prisma.CampaignMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>[]
          }
          create: {
            args: Prisma.CampaignMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          createMany: {
            args: Prisma.CampaignMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>[]
          }
          delete: {
            args: Prisma.CampaignMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          update: {
            args: Prisma.CampaignMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          deleteMany: {
            args: Prisma.CampaignMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          aggregate: {
            args: Prisma.CampaignMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignMessage>
          }
          groupBy: {
            args: Prisma.CampaignMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignMessageCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignMessageCountAggregateOutputType> | number
          }
        }
      }
      CampaignLead: {
        payload: Prisma.$CampaignLeadPayload<ExtArgs>
        fields: Prisma.CampaignLeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignLeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignLeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          findFirst: {
            args: Prisma.CampaignLeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignLeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          findMany: {
            args: Prisma.CampaignLeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>[]
          }
          create: {
            args: Prisma.CampaignLeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          createMany: {
            args: Prisma.CampaignLeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignLeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>[]
          }
          delete: {
            args: Prisma.CampaignLeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          update: {
            args: Prisma.CampaignLeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          deleteMany: {
            args: Prisma.CampaignLeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignLeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignLeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          aggregate: {
            args: Prisma.CampaignLeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignLead>
          }
          groupBy: {
            args: Prisma.CampaignLeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignLeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignLeadCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignLeadCountAggregateOutputType> | number
          }
        }
      }
      CampaignStatistics: {
        payload: Prisma.$CampaignStatisticsPayload<ExtArgs>
        fields: Prisma.CampaignStatisticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignStatisticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignStatisticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>
          }
          findFirst: {
            args: Prisma.CampaignStatisticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignStatisticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>
          }
          findMany: {
            args: Prisma.CampaignStatisticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>[]
          }
          create: {
            args: Prisma.CampaignStatisticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>
          }
          createMany: {
            args: Prisma.CampaignStatisticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignStatisticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>[]
          }
          delete: {
            args: Prisma.CampaignStatisticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>
          }
          update: {
            args: Prisma.CampaignStatisticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>
          }
          deleteMany: {
            args: Prisma.CampaignStatisticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignStatisticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignStatisticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>
          }
          aggregate: {
            args: Prisma.CampaignStatisticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignStatistics>
          }
          groupBy: {
            args: Prisma.CampaignStatisticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignStatisticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignStatisticsCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignStatisticsCountAggregateOutputType> | number
          }
        }
      }
      MessageLog: {
        payload: Prisma.$MessageLogPayload<ExtArgs>
        fields: Prisma.MessageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>
          }
          findFirst: {
            args: Prisma.MessageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>
          }
          findMany: {
            args: Prisma.MessageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>[]
          }
          create: {
            args: Prisma.MessageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>
          }
          createMany: {
            args: Prisma.MessageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>[]
          }
          delete: {
            args: Prisma.MessageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>
          }
          update: {
            args: Prisma.MessageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>
          }
          deleteMany: {
            args: Prisma.MessageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>
          }
          aggregate: {
            args: Prisma.MessageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageLog>
          }
          groupBy: {
            args: Prisma.MessageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageLogCountArgs<ExtArgs>
            result: $Utils.Optional<MessageLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    WhatleadUser: number
    whatleadparceiroconfigs: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WhatleadUser?: boolean | CompanyCountOutputTypeCountWhatleadUserArgs
    whatleadparceiroconfigs?: boolean | CompanyCountOutputTypeCountWhatleadparceiroconfigsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountWhatleadUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountWhatleadparceiroconfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesUnitesWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    instances: number
    payments: number
    warmupStats: number
    Campaign: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instances?: boolean | UserCountOutputTypeCountInstancesArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    warmupStats?: boolean | UserCountOutputTypeCountWarmupStatsArgs
    Campaign?: boolean | UserCountOutputTypeCountCampaignArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWarmupStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarmupStatsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type CompaniesUnitesCountOutputType
   */

  export type CompaniesUnitesCountOutputType = {
    leads: number
  }

  export type CompaniesUnitesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | CompaniesUnitesCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * CompaniesUnitesCountOutputType without action
   */
  export type CompaniesUnitesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnitesCountOutputType
     */
    select?: CompaniesUnitesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesUnitesCountOutputType without action
   */
  export type CompaniesUnitesCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    MessageLog: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageLog?: boolean | LeadCountOutputTypeCountMessageLogArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountMessageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLogWhereInput
  }


  /**
   * Count Type InstanceCountOutputType
   */

  export type InstanceCountOutputType = {
    mediaStats: number
    Campaign: number
  }

  export type InstanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mediaStats?: boolean | InstanceCountOutputTypeCountMediaStatsArgs
    Campaign?: boolean | InstanceCountOutputTypeCountCampaignArgs
  }

  // Custom InputTypes
  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceCountOutputType
     */
    select?: InstanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountMediaStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaStatsWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type MediaStatsCountOutputType
   */

  export type MediaStatsCountOutputType = {
    warmupStatsReceived: number
    warmupStatsSent: number
  }

  export type MediaStatsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warmupStatsReceived?: boolean | MediaStatsCountOutputTypeCountWarmupStatsReceivedArgs
    warmupStatsSent?: boolean | MediaStatsCountOutputTypeCountWarmupStatsSentArgs
  }

  // Custom InputTypes
  /**
   * MediaStatsCountOutputType without action
   */
  export type MediaStatsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStatsCountOutputType
     */
    select?: MediaStatsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaStatsCountOutputType without action
   */
  export type MediaStatsCountOutputTypeCountWarmupStatsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarmupStatsWhereInput
  }

  /**
   * MediaStatsCountOutputType without action
   */
  export type MediaStatsCountOutputTypeCountWarmupStatsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarmupStatsWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    MessageLog: number
    leads: number
    messages: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageLog?: boolean | CampaignCountOutputTypeCountMessageLogArgs
    leads?: boolean | CampaignCountOutputTypeCountLeadsArgs
    messages?: boolean | CampaignCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMessageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLogWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLeadWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMessageWhereInput
  }


  /**
   * Count Type CampaignLeadCountOutputType
   */

  export type CampaignLeadCountOutputType = {
    messageLogs: number
  }

  export type CampaignLeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messageLogs?: boolean | CampaignLeadCountOutputTypeCountMessageLogsArgs
  }

  // Custom InputTypes
  /**
   * CampaignLeadCountOutputType without action
   */
  export type CampaignLeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLeadCountOutputType
     */
    select?: CampaignLeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignLeadCountOutputType without action
   */
  export type CampaignLeadCountOutputTypeCountMessageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLogWhereInput
  }


  /**
   * Count Type MessageLogCountOutputType
   */

  export type MessageLogCountOutputType = {
    CampaignLead: number
  }

  export type MessageLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CampaignLead?: boolean | MessageLogCountOutputTypeCountCampaignLeadArgs
  }

  // Custom InputTypes
  /**
   * MessageLogCountOutputType without action
   */
  export type MessageLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLogCountOutputType
     */
    select?: MessageLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageLogCountOutputType without action
   */
  export type MessageLogCountOutputTypeCountCampaignLeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLeadWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    active: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    WhatleadUser?: boolean | Company$WhatleadUserArgs<ExtArgs>
    whatleadparceiroconfigs?: boolean | Company$whatleadparceiroconfigsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WhatleadUser?: boolean | Company$WhatleadUserArgs<ExtArgs>
    whatleadparceiroconfigs?: boolean | Company$whatleadparceiroconfigsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      WhatleadUser: Prisma.$UserPayload<ExtArgs>[]
      whatleadparceiroconfigs: Prisma.$CompaniesUnitesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      active: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WhatleadUser<T extends Company$WhatleadUserArgs<ExtArgs> = {}>(args?: Subset<T, Company$WhatleadUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    whatleadparceiroconfigs<T extends Company$whatleadparceiroconfigsArgs<ExtArgs> = {}>(args?: Subset<T, Company$whatleadparceiroconfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly active: FieldRef<"Company", 'Boolean'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.WhatleadUser
   */
  export type Company$WhatleadUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.whatleadparceiroconfigs
   */
  export type Company$whatleadparceiroconfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    where?: CompaniesUnitesWhereInput
    orderBy?: CompaniesUnitesOrderByWithRelationInput | CompaniesUnitesOrderByWithRelationInput[]
    cursor?: CompaniesUnitesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesUnitesScalarFieldEnum | CompaniesUnitesScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    maxInstances: number | null
    messagesPerDay: number | null
  }

  export type UserSumAggregateOutputType = {
    maxInstances: number | null
    messagesPerDay: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    profile: string | null
    phone: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripeSubscriptionStatus: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    whatleadCompanyId: string | null
    plan: string | null
    status: boolean | null
    maxInstances: number | null
    messagesPerDay: number | null
    support: string | null
    trialEndDate: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    profile: string | null
    phone: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripeSubscriptionStatus: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    whatleadCompanyId: string | null
    plan: string | null
    status: boolean | null
    maxInstances: number | null
    messagesPerDay: number | null
    support: string | null
    trialEndDate: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    profile: number
    phone: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    stripeSubscriptionStatus: number
    active: number
    createdAt: number
    updatedAt: number
    whatleadCompanyId: number
    plan: number
    status: number
    maxInstances: number
    messagesPerDay: number
    features: number
    support: number
    trialEndDate: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    maxInstances?: true
    messagesPerDay?: true
  }

  export type UserSumAggregateInputType = {
    maxInstances?: true
    messagesPerDay?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    profile?: true
    phone?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripeSubscriptionStatus?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    whatleadCompanyId?: true
    plan?: true
    status?: true
    maxInstances?: true
    messagesPerDay?: true
    support?: true
    trialEndDate?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    profile?: true
    phone?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripeSubscriptionStatus?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    whatleadCompanyId?: true
    plan?: true
    status?: true
    maxInstances?: true
    messagesPerDay?: true
    support?: true
    trialEndDate?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    profile?: true
    phone?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripeSubscriptionStatus?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    whatleadCompanyId?: true
    plan?: true
    status?: true
    maxInstances?: true
    messagesPerDay?: true
    features?: true
    support?: true
    trialEndDate?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripeSubscriptionStatus: string | null
    active: boolean | null
    createdAt: Date
    updatedAt: Date
    whatleadCompanyId: string
    plan: string
    status: boolean
    maxInstances: number
    messagesPerDay: number
    features: string[]
    support: string
    trialEndDate: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    profile?: boolean
    phone?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripeSubscriptionStatus?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatleadCompanyId?: boolean
    plan?: boolean
    status?: boolean
    maxInstances?: boolean
    messagesPerDay?: boolean
    features?: boolean
    support?: boolean
    trialEndDate?: boolean
    instances?: boolean | User$instancesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    warmupStats?: boolean | User$warmupStatsArgs<ExtArgs>
    Campaign?: boolean | User$CampaignArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    profile?: boolean
    phone?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripeSubscriptionStatus?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatleadCompanyId?: boolean
    plan?: boolean
    status?: boolean
    maxInstances?: boolean
    messagesPerDay?: boolean
    features?: boolean
    support?: boolean
    trialEndDate?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    profile?: boolean
    phone?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripeSubscriptionStatus?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatleadCompanyId?: boolean
    plan?: boolean
    status?: boolean
    maxInstances?: boolean
    messagesPerDay?: boolean
    features?: boolean
    support?: boolean
    trialEndDate?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instances?: boolean | User$instancesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    warmupStats?: boolean | User$warmupStatsArgs<ExtArgs>
    Campaign?: boolean | User$CampaignArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      instances: Prisma.$InstancePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      warmupStats: Prisma.$WarmupStatsPayload<ExtArgs>[]
      Campaign: Prisma.$CampaignPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      profile: string
      phone: string
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      stripeSubscriptionStatus: string | null
      active: boolean | null
      createdAt: Date
      updatedAt: Date
      whatleadCompanyId: string
      plan: string
      status: boolean
      maxInstances: number
      messagesPerDay: number
      features: string[]
      support: string
      trialEndDate: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instances<T extends User$instancesArgs<ExtArgs> = {}>(args?: Subset<T, User$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    warmupStats<T extends User$warmupStatsArgs<ExtArgs> = {}>(args?: Subset<T, User$warmupStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findMany"> | Null>
    Campaign<T extends User$CampaignArgs<ExtArgs> = {}>(args?: Subset<T, User$CampaignArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly profile: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly stripeCustomerId: FieldRef<"User", 'String'>
    readonly stripeSubscriptionId: FieldRef<"User", 'String'>
    readonly stripeSubscriptionStatus: FieldRef<"User", 'String'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly whatleadCompanyId: FieldRef<"User", 'String'>
    readonly plan: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'Boolean'>
    readonly maxInstances: FieldRef<"User", 'Int'>
    readonly messagesPerDay: FieldRef<"User", 'Int'>
    readonly features: FieldRef<"User", 'String[]'>
    readonly support: FieldRef<"User", 'String'>
    readonly trialEndDate: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.instances
   */
  export type User$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    where?: InstanceWhereInput
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    cursor?: InstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.warmupStats
   */
  export type User$warmupStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    where?: WarmupStatsWhereInput
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    cursor?: WarmupStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * User.Campaign
   */
  export type User$CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model CompaniesUnites
   */

  export type AggregateCompaniesUnites = {
    _count: CompaniesUnitesCountAggregateOutputType | null
    _min: CompaniesUnitesMinAggregateOutputType | null
    _max: CompaniesUnitesMaxAggregateOutputType | null
  }

  export type CompaniesUnitesMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    name: string | null
    productdefault: string | null
    campaignstatus: string | null
    enablecuration: boolean | null
    enabletosendustolead: boolean | null
    enabled: boolean | null
    isconversationia: boolean | null
    campaignnumberbusiness: string | null
    whatsappprovider: string | null
    enabletosendprovider: boolean | null
    enabletosecondcallprovider: boolean | null
    integrationname: string | null
    updatedAt: Date | null
    whitelabel_config: string | null
    whatleadCompanyId: string | null
  }

  export type CompaniesUnitesMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    name: string | null
    productdefault: string | null
    campaignstatus: string | null
    enablecuration: boolean | null
    enabletosendustolead: boolean | null
    enabled: boolean | null
    isconversationia: boolean | null
    campaignnumberbusiness: string | null
    whatsappprovider: string | null
    enabletosendprovider: boolean | null
    enabletosecondcallprovider: boolean | null
    integrationname: string | null
    updatedAt: Date | null
    whitelabel_config: string | null
    whatleadCompanyId: string | null
  }

  export type CompaniesUnitesCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    productdefault: number
    campaignstatus: number
    enablecuration: number
    enabletosendustolead: number
    enabled: number
    isconversationia: number
    campaignnumberbusiness: number
    whatsappprovider: number
    enabletosendprovider: number
    enabletosecondcallprovider: number
    integrationconfiguration: number
    integrationname: number
    templatelistvars: number
    metaconfiguration: number
    messageperruns: number
    notifyconfiguration: number
    updatedAt: number
    whitelabel_config: number
    whatleadCompanyId: number
    _all: number
  }


  export type CompaniesUnitesMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    productdefault?: true
    campaignstatus?: true
    enablecuration?: true
    enabletosendustolead?: true
    enabled?: true
    isconversationia?: true
    campaignnumberbusiness?: true
    whatsappprovider?: true
    enabletosendprovider?: true
    enabletosecondcallprovider?: true
    integrationname?: true
    updatedAt?: true
    whitelabel_config?: true
    whatleadCompanyId?: true
  }

  export type CompaniesUnitesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    productdefault?: true
    campaignstatus?: true
    enablecuration?: true
    enabletosendustolead?: true
    enabled?: true
    isconversationia?: true
    campaignnumberbusiness?: true
    whatsappprovider?: true
    enabletosendprovider?: true
    enabletosecondcallprovider?: true
    integrationname?: true
    updatedAt?: true
    whitelabel_config?: true
    whatleadCompanyId?: true
  }

  export type CompaniesUnitesCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    productdefault?: true
    campaignstatus?: true
    enablecuration?: true
    enabletosendustolead?: true
    enabled?: true
    isconversationia?: true
    campaignnumberbusiness?: true
    whatsappprovider?: true
    enabletosendprovider?: true
    enabletosecondcallprovider?: true
    integrationconfiguration?: true
    integrationname?: true
    templatelistvars?: true
    metaconfiguration?: true
    messageperruns?: true
    notifyconfiguration?: true
    updatedAt?: true
    whitelabel_config?: true
    whatleadCompanyId?: true
    _all?: true
  }

  export type CompaniesUnitesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesUnites to aggregate.
     */
    where?: CompaniesUnitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUnites to fetch.
     */
    orderBy?: CompaniesUnitesOrderByWithRelationInput | CompaniesUnitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompaniesUnitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUnites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUnites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompaniesUnites
    **/
    _count?: true | CompaniesUnitesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesUnitesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesUnitesMaxAggregateInputType
  }

  export type GetCompaniesUnitesAggregateType<T extends CompaniesUnitesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompaniesUnites]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompaniesUnites[P]>
      : GetScalarType<T[P], AggregateCompaniesUnites[P]>
  }




  export type CompaniesUnitesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesUnitesWhereInput
    orderBy?: CompaniesUnitesOrderByWithAggregationInput | CompaniesUnitesOrderByWithAggregationInput[]
    by: CompaniesUnitesScalarFieldEnum[] | CompaniesUnitesScalarFieldEnum
    having?: CompaniesUnitesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesUnitesCountAggregateInputType | true
    _min?: CompaniesUnitesMinAggregateInputType
    _max?: CompaniesUnitesMaxAggregateInputType
  }

  export type CompaniesUnitesGroupByOutputType = {
    id: string
    createdAt: Date | null
    name: string | null
    productdefault: string | null
    campaignstatus: string | null
    enablecuration: boolean | null
    enabletosendustolead: boolean | null
    enabled: boolean | null
    isconversationia: boolean | null
    campaignnumberbusiness: string | null
    whatsappprovider: string | null
    enabletosendprovider: boolean | null
    enabletosecondcallprovider: boolean | null
    integrationconfiguration: JsonValue | null
    integrationname: string | null
    templatelistvars: JsonValue[]
    metaconfiguration: JsonValue | null
    messageperruns: JsonValue[]
    notifyconfiguration: JsonValue | null
    updatedAt: Date | null
    whitelabel_config: string
    whatleadCompanyId: string | null
    _count: CompaniesUnitesCountAggregateOutputType | null
    _min: CompaniesUnitesMinAggregateOutputType | null
    _max: CompaniesUnitesMaxAggregateOutputType | null
  }

  type GetCompaniesUnitesGroupByPayload<T extends CompaniesUnitesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesUnitesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesUnitesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesUnitesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesUnitesGroupByOutputType[P]>
        }
      >
    >


  export type CompaniesUnitesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    productdefault?: boolean
    campaignstatus?: boolean
    enablecuration?: boolean
    enabletosendustolead?: boolean
    enabled?: boolean
    isconversationia?: boolean
    campaignnumberbusiness?: boolean
    whatsappprovider?: boolean
    enabletosendprovider?: boolean
    enabletosecondcallprovider?: boolean
    integrationconfiguration?: boolean
    integrationname?: boolean
    templatelistvars?: boolean
    metaconfiguration?: boolean
    messageperruns?: boolean
    notifyconfiguration?: boolean
    updatedAt?: boolean
    whitelabel_config?: boolean
    whatleadCompanyId?: boolean
    leads?: boolean | CompaniesUnites$leadsArgs<ExtArgs>
    company?: boolean | CompaniesUnites$companyArgs<ExtArgs>
    _count?: boolean | CompaniesUnitesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companiesUnites"]>

  export type CompaniesUnitesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    productdefault?: boolean
    campaignstatus?: boolean
    enablecuration?: boolean
    enabletosendustolead?: boolean
    enabled?: boolean
    isconversationia?: boolean
    campaignnumberbusiness?: boolean
    whatsappprovider?: boolean
    enabletosendprovider?: boolean
    enabletosecondcallprovider?: boolean
    integrationconfiguration?: boolean
    integrationname?: boolean
    templatelistvars?: boolean
    metaconfiguration?: boolean
    messageperruns?: boolean
    notifyconfiguration?: boolean
    updatedAt?: boolean
    whitelabel_config?: boolean
    whatleadCompanyId?: boolean
    company?: boolean | CompaniesUnites$companyArgs<ExtArgs>
  }, ExtArgs["result"]["companiesUnites"]>

  export type CompaniesUnitesSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    productdefault?: boolean
    campaignstatus?: boolean
    enablecuration?: boolean
    enabletosendustolead?: boolean
    enabled?: boolean
    isconversationia?: boolean
    campaignnumberbusiness?: boolean
    whatsappprovider?: boolean
    enabletosendprovider?: boolean
    enabletosecondcallprovider?: boolean
    integrationconfiguration?: boolean
    integrationname?: boolean
    templatelistvars?: boolean
    metaconfiguration?: boolean
    messageperruns?: boolean
    notifyconfiguration?: boolean
    updatedAt?: boolean
    whitelabel_config?: boolean
    whatleadCompanyId?: boolean
  }

  export type CompaniesUnitesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | CompaniesUnites$leadsArgs<ExtArgs>
    company?: boolean | CompaniesUnites$companyArgs<ExtArgs>
    _count?: boolean | CompaniesUnitesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompaniesUnitesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompaniesUnites$companyArgs<ExtArgs>
  }

  export type $CompaniesUnitesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompaniesUnites"
    objects: {
      leads: Prisma.$LeadPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date | null
      name: string | null
      productdefault: string | null
      campaignstatus: string | null
      enablecuration: boolean | null
      enabletosendustolead: boolean | null
      enabled: boolean | null
      isconversationia: boolean | null
      campaignnumberbusiness: string | null
      whatsappprovider: string | null
      enabletosendprovider: boolean | null
      enabletosecondcallprovider: boolean | null
      integrationconfiguration: Prisma.JsonValue | null
      integrationname: string | null
      templatelistvars: Prisma.JsonValue[]
      metaconfiguration: Prisma.JsonValue | null
      messageperruns: Prisma.JsonValue[]
      notifyconfiguration: Prisma.JsonValue | null
      updatedAt: Date | null
      whitelabel_config: string
      whatleadCompanyId: string | null
    }, ExtArgs["result"]["companiesUnites"]>
    composites: {}
  }

  type CompaniesUnitesGetPayload<S extends boolean | null | undefined | CompaniesUnitesDefaultArgs> = $Result.GetResult<Prisma.$CompaniesUnitesPayload, S>

  type CompaniesUnitesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompaniesUnitesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompaniesUnitesCountAggregateInputType | true
    }

  export interface CompaniesUnitesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompaniesUnites'], meta: { name: 'CompaniesUnites' } }
    /**
     * Find zero or one CompaniesUnites that matches the filter.
     * @param {CompaniesUnitesFindUniqueArgs} args - Arguments to find a CompaniesUnites
     * @example
     * // Get one CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompaniesUnitesFindUniqueArgs>(args: SelectSubset<T, CompaniesUnitesFindUniqueArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompaniesUnites that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompaniesUnitesFindUniqueOrThrowArgs} args - Arguments to find a CompaniesUnites
     * @example
     * // Get one CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompaniesUnitesFindUniqueOrThrowArgs>(args: SelectSubset<T, CompaniesUnitesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompaniesUnites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesFindFirstArgs} args - Arguments to find a CompaniesUnites
     * @example
     * // Get one CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompaniesUnitesFindFirstArgs>(args?: SelectSubset<T, CompaniesUnitesFindFirstArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompaniesUnites that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesFindFirstOrThrowArgs} args - Arguments to find a CompaniesUnites
     * @example
     * // Get one CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompaniesUnitesFindFirstOrThrowArgs>(args?: SelectSubset<T, CompaniesUnitesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompaniesUnites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.findMany()
     * 
     * // Get first 10 CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesUnitesWithIdOnly = await prisma.companiesUnites.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompaniesUnitesFindManyArgs>(args?: SelectSubset<T, CompaniesUnitesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompaniesUnites.
     * @param {CompaniesUnitesCreateArgs} args - Arguments to create a CompaniesUnites.
     * @example
     * // Create one CompaniesUnites
     * const CompaniesUnites = await prisma.companiesUnites.create({
     *   data: {
     *     // ... data to create a CompaniesUnites
     *   }
     * })
     * 
     */
    create<T extends CompaniesUnitesCreateArgs>(args: SelectSubset<T, CompaniesUnitesCreateArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompaniesUnites.
     * @param {CompaniesUnitesCreateManyArgs} args - Arguments to create many CompaniesUnites.
     * @example
     * // Create many CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompaniesUnitesCreateManyArgs>(args?: SelectSubset<T, CompaniesUnitesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompaniesUnites and returns the data saved in the database.
     * @param {CompaniesUnitesCreateManyAndReturnArgs} args - Arguments to create many CompaniesUnites.
     * @example
     * // Create many CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompaniesUnites and only return the `id`
     * const companiesUnitesWithIdOnly = await prisma.companiesUnites.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompaniesUnitesCreateManyAndReturnArgs>(args?: SelectSubset<T, CompaniesUnitesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompaniesUnites.
     * @param {CompaniesUnitesDeleteArgs} args - Arguments to delete one CompaniesUnites.
     * @example
     * // Delete one CompaniesUnites
     * const CompaniesUnites = await prisma.companiesUnites.delete({
     *   where: {
     *     // ... filter to delete one CompaniesUnites
     *   }
     * })
     * 
     */
    delete<T extends CompaniesUnitesDeleteArgs>(args: SelectSubset<T, CompaniesUnitesDeleteArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompaniesUnites.
     * @param {CompaniesUnitesUpdateArgs} args - Arguments to update one CompaniesUnites.
     * @example
     * // Update one CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompaniesUnitesUpdateArgs>(args: SelectSubset<T, CompaniesUnitesUpdateArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompaniesUnites.
     * @param {CompaniesUnitesDeleteManyArgs} args - Arguments to filter CompaniesUnites to delete.
     * @example
     * // Delete a few CompaniesUnites
     * const { count } = await prisma.companiesUnites.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompaniesUnitesDeleteManyArgs>(args?: SelectSubset<T, CompaniesUnitesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompaniesUnites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompaniesUnitesUpdateManyArgs>(args: SelectSubset<T, CompaniesUnitesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompaniesUnites.
     * @param {CompaniesUnitesUpsertArgs} args - Arguments to update or create a CompaniesUnites.
     * @example
     * // Update or create a CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.upsert({
     *   create: {
     *     // ... data to create a CompaniesUnites
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompaniesUnites we want to update
     *   }
     * })
     */
    upsert<T extends CompaniesUnitesUpsertArgs>(args: SelectSubset<T, CompaniesUnitesUpsertArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompaniesUnites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesCountArgs} args - Arguments to filter CompaniesUnites to count.
     * @example
     * // Count the number of CompaniesUnites
     * const count = await prisma.companiesUnites.count({
     *   where: {
     *     // ... the filter for the CompaniesUnites we want to count
     *   }
     * })
    **/
    count<T extends CompaniesUnitesCountArgs>(
      args?: Subset<T, CompaniesUnitesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesUnitesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompaniesUnites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesUnitesAggregateArgs>(args: Subset<T, CompaniesUnitesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesUnitesAggregateType<T>>

    /**
     * Group by CompaniesUnites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompaniesUnitesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompaniesUnitesGroupByArgs['orderBy'] }
        : { orderBy?: CompaniesUnitesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompaniesUnitesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesUnitesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompaniesUnites model
   */
  readonly fields: CompaniesUnitesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompaniesUnites.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompaniesUnitesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leads<T extends CompaniesUnites$leadsArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUnites$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany"> | Null>
    company<T extends CompaniesUnites$companyArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUnites$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompaniesUnites model
   */ 
  interface CompaniesUnitesFieldRefs {
    readonly id: FieldRef<"CompaniesUnites", 'String'>
    readonly createdAt: FieldRef<"CompaniesUnites", 'DateTime'>
    readonly name: FieldRef<"CompaniesUnites", 'String'>
    readonly productdefault: FieldRef<"CompaniesUnites", 'String'>
    readonly campaignstatus: FieldRef<"CompaniesUnites", 'String'>
    readonly enablecuration: FieldRef<"CompaniesUnites", 'Boolean'>
    readonly enabletosendustolead: FieldRef<"CompaniesUnites", 'Boolean'>
    readonly enabled: FieldRef<"CompaniesUnites", 'Boolean'>
    readonly isconversationia: FieldRef<"CompaniesUnites", 'Boolean'>
    readonly campaignnumberbusiness: FieldRef<"CompaniesUnites", 'String'>
    readonly whatsappprovider: FieldRef<"CompaniesUnites", 'String'>
    readonly enabletosendprovider: FieldRef<"CompaniesUnites", 'Boolean'>
    readonly enabletosecondcallprovider: FieldRef<"CompaniesUnites", 'Boolean'>
    readonly integrationconfiguration: FieldRef<"CompaniesUnites", 'Json'>
    readonly integrationname: FieldRef<"CompaniesUnites", 'String'>
    readonly templatelistvars: FieldRef<"CompaniesUnites", 'Json[]'>
    readonly metaconfiguration: FieldRef<"CompaniesUnites", 'Json'>
    readonly messageperruns: FieldRef<"CompaniesUnites", 'Json[]'>
    readonly notifyconfiguration: FieldRef<"CompaniesUnites", 'Json'>
    readonly updatedAt: FieldRef<"CompaniesUnites", 'DateTime'>
    readonly whitelabel_config: FieldRef<"CompaniesUnites", 'String'>
    readonly whatleadCompanyId: FieldRef<"CompaniesUnites", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompaniesUnites findUnique
   */
  export type CompaniesUnitesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUnites to fetch.
     */
    where: CompaniesUnitesWhereUniqueInput
  }

  /**
   * CompaniesUnites findUniqueOrThrow
   */
  export type CompaniesUnitesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUnites to fetch.
     */
    where: CompaniesUnitesWhereUniqueInput
  }

  /**
   * CompaniesUnites findFirst
   */
  export type CompaniesUnitesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUnites to fetch.
     */
    where?: CompaniesUnitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUnites to fetch.
     */
    orderBy?: CompaniesUnitesOrderByWithRelationInput | CompaniesUnitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesUnites.
     */
    cursor?: CompaniesUnitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUnites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUnites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesUnites.
     */
    distinct?: CompaniesUnitesScalarFieldEnum | CompaniesUnitesScalarFieldEnum[]
  }

  /**
   * CompaniesUnites findFirstOrThrow
   */
  export type CompaniesUnitesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUnites to fetch.
     */
    where?: CompaniesUnitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUnites to fetch.
     */
    orderBy?: CompaniesUnitesOrderByWithRelationInput | CompaniesUnitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesUnites.
     */
    cursor?: CompaniesUnitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUnites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUnites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesUnites.
     */
    distinct?: CompaniesUnitesScalarFieldEnum | CompaniesUnitesScalarFieldEnum[]
  }

  /**
   * CompaniesUnites findMany
   */
  export type CompaniesUnitesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUnites to fetch.
     */
    where?: CompaniesUnitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUnites to fetch.
     */
    orderBy?: CompaniesUnitesOrderByWithRelationInput | CompaniesUnitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompaniesUnites.
     */
    cursor?: CompaniesUnitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUnites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUnites.
     */
    skip?: number
    distinct?: CompaniesUnitesScalarFieldEnum | CompaniesUnitesScalarFieldEnum[]
  }

  /**
   * CompaniesUnites create
   */
  export type CompaniesUnitesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * The data needed to create a CompaniesUnites.
     */
    data: XOR<CompaniesUnitesCreateInput, CompaniesUnitesUncheckedCreateInput>
  }

  /**
   * CompaniesUnites createMany
   */
  export type CompaniesUnitesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompaniesUnites.
     */
    data: CompaniesUnitesCreateManyInput | CompaniesUnitesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompaniesUnites createManyAndReturn
   */
  export type CompaniesUnitesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompaniesUnites.
     */
    data: CompaniesUnitesCreateManyInput | CompaniesUnitesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompaniesUnites update
   */
  export type CompaniesUnitesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * The data needed to update a CompaniesUnites.
     */
    data: XOR<CompaniesUnitesUpdateInput, CompaniesUnitesUncheckedUpdateInput>
    /**
     * Choose, which CompaniesUnites to update.
     */
    where: CompaniesUnitesWhereUniqueInput
  }

  /**
   * CompaniesUnites updateMany
   */
  export type CompaniesUnitesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompaniesUnites.
     */
    data: XOR<CompaniesUnitesUpdateManyMutationInput, CompaniesUnitesUncheckedUpdateManyInput>
    /**
     * Filter which CompaniesUnites to update
     */
    where?: CompaniesUnitesWhereInput
  }

  /**
   * CompaniesUnites upsert
   */
  export type CompaniesUnitesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * The filter to search for the CompaniesUnites to update in case it exists.
     */
    where: CompaniesUnitesWhereUniqueInput
    /**
     * In case the CompaniesUnites found by the `where` argument doesn't exist, create a new CompaniesUnites with this data.
     */
    create: XOR<CompaniesUnitesCreateInput, CompaniesUnitesUncheckedCreateInput>
    /**
     * In case the CompaniesUnites was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompaniesUnitesUpdateInput, CompaniesUnitesUncheckedUpdateInput>
  }

  /**
   * CompaniesUnites delete
   */
  export type CompaniesUnitesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * Filter which CompaniesUnites to delete.
     */
    where: CompaniesUnitesWhereUniqueInput
  }

  /**
   * CompaniesUnites deleteMany
   */
  export type CompaniesUnitesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesUnites to delete
     */
    where?: CompaniesUnitesWhereInput
  }

  /**
   * CompaniesUnites.leads
   */
  export type CompaniesUnites$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * CompaniesUnites.company
   */
  export type CompaniesUnites$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * CompaniesUnites without action
   */
  export type CompaniesUnitesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    stepsecondcalltemplate: number | null
    stepnointeraction: number | null
    nointeractionquantity: number | null
    productid: number | null
  }

  export type LeadSumAggregateOutputType = {
    stepsecondcalltemplate: number | null
    stepnointeraction: number | null
    nointeractionquantity: number | null
    productid: number | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    externalid: string | null
    sourceid: string | null
    name: string | null
    phone: string | null
    email: string | null
    lastmessagesent: Date | null
    stepsecondcalltemplate: number | null
    stepnointeraction: number | null
    nointeractionquantity: number | null
    accepttemplate: boolean | null
    acceptsecondtemplate: boolean | null
    status: string | null
    configid: string | null
    whitelabelconfig: string | null
    lastintent: string | null
    broker: string | null
    origin: string | null
    send: boolean | null
    sendAt: Date | null
    isBusinessAutoResponder: boolean | null
    startmessage: Date | null
    schedulingdata: string | null
    productchoosebyclient: string | null
    productid: number | null
    createdat: Date | null
    updatedat: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    externalid: string | null
    sourceid: string | null
    name: string | null
    phone: string | null
    email: string | null
    lastmessagesent: Date | null
    stepsecondcalltemplate: number | null
    stepnointeraction: number | null
    nointeractionquantity: number | null
    accepttemplate: boolean | null
    acceptsecondtemplate: boolean | null
    status: string | null
    configid: string | null
    whitelabelconfig: string | null
    lastintent: string | null
    broker: string | null
    origin: string | null
    send: boolean | null
    sendAt: Date | null
    isBusinessAutoResponder: boolean | null
    startmessage: Date | null
    schedulingdata: string | null
    productchoosebyclient: string | null
    productid: number | null
    createdat: Date | null
    updatedat: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    externalid: number
    sourceid: number
    name: number
    phone: number
    email: number
    lastmessagesent: number
    stepsecondcalltemplate: number
    stepnointeraction: number
    nointeractionquantity: number
    accepttemplate: number
    acceptsecondtemplate: number
    status: number
    dialog: number
    configid: number
    whitelabelconfig: number
    lastintent: number
    broker: number
    origin: number
    send: number
    sendAt: number
    isBusinessAutoResponder: number
    startmessage: number
    schedulingdata: number
    productchoosebyclient: number
    productid: number
    createdat: number
    updatedat: number
    curation: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    stepsecondcalltemplate?: true
    stepnointeraction?: true
    nointeractionquantity?: true
    productid?: true
  }

  export type LeadSumAggregateInputType = {
    stepsecondcalltemplate?: true
    stepnointeraction?: true
    nointeractionquantity?: true
    productid?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    externalid?: true
    sourceid?: true
    name?: true
    phone?: true
    email?: true
    lastmessagesent?: true
    stepsecondcalltemplate?: true
    stepnointeraction?: true
    nointeractionquantity?: true
    accepttemplate?: true
    acceptsecondtemplate?: true
    status?: true
    configid?: true
    whitelabelconfig?: true
    lastintent?: true
    broker?: true
    origin?: true
    send?: true
    sendAt?: true
    isBusinessAutoResponder?: true
    startmessage?: true
    schedulingdata?: true
    productchoosebyclient?: true
    productid?: true
    createdat?: true
    updatedat?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    externalid?: true
    sourceid?: true
    name?: true
    phone?: true
    email?: true
    lastmessagesent?: true
    stepsecondcalltemplate?: true
    stepnointeraction?: true
    nointeractionquantity?: true
    accepttemplate?: true
    acceptsecondtemplate?: true
    status?: true
    configid?: true
    whitelabelconfig?: true
    lastintent?: true
    broker?: true
    origin?: true
    send?: true
    sendAt?: true
    isBusinessAutoResponder?: true
    startmessage?: true
    schedulingdata?: true
    productchoosebyclient?: true
    productid?: true
    createdat?: true
    updatedat?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    externalid?: true
    sourceid?: true
    name?: true
    phone?: true
    email?: true
    lastmessagesent?: true
    stepsecondcalltemplate?: true
    stepnointeraction?: true
    nointeractionquantity?: true
    accepttemplate?: true
    acceptsecondtemplate?: true
    status?: true
    dialog?: true
    configid?: true
    whitelabelconfig?: true
    lastintent?: true
    broker?: true
    origin?: true
    send?: true
    sendAt?: true
    isBusinessAutoResponder?: true
    startmessage?: true
    schedulingdata?: true
    productchoosebyclient?: true
    productid?: true
    createdat?: true
    updatedat?: true
    curation?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    externalid: string | null
    sourceid: string | null
    name: string
    phone: string
    email: string | null
    lastmessagesent: Date | null
    stepsecondcalltemplate: number | null
    stepnointeraction: number | null
    nointeractionquantity: number | null
    accepttemplate: boolean | null
    acceptsecondtemplate: boolean | null
    status: string | null
    dialog: JsonValue[]
    configid: string
    whitelabelconfig: string
    lastintent: string | null
    broker: string | null
    origin: string | null
    send: boolean | null
    sendAt: Date | null
    isBusinessAutoResponder: boolean | null
    startmessage: Date | null
    schedulingdata: string | null
    productchoosebyclient: string | null
    productid: number | null
    createdat: Date | null
    updatedat: Date | null
    curation: JsonValue | null
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalid?: boolean
    sourceid?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    lastmessagesent?: boolean
    stepsecondcalltemplate?: boolean
    stepnointeraction?: boolean
    nointeractionquantity?: boolean
    accepttemplate?: boolean
    acceptsecondtemplate?: boolean
    status?: boolean
    dialog?: boolean
    configid?: boolean
    whitelabelconfig?: boolean
    lastintent?: boolean
    broker?: boolean
    origin?: boolean
    send?: boolean
    sendAt?: boolean
    isBusinessAutoResponder?: boolean
    startmessage?: boolean
    schedulingdata?: boolean
    productchoosebyclient?: boolean
    productid?: boolean
    createdat?: boolean
    updatedat?: boolean
    curation?: boolean
    MessageLog?: boolean | Lead$MessageLogArgs<ExtArgs>
    config?: boolean | CompaniesUnitesDefaultArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalid?: boolean
    sourceid?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    lastmessagesent?: boolean
    stepsecondcalltemplate?: boolean
    stepnointeraction?: boolean
    nointeractionquantity?: boolean
    accepttemplate?: boolean
    acceptsecondtemplate?: boolean
    status?: boolean
    dialog?: boolean
    configid?: boolean
    whitelabelconfig?: boolean
    lastintent?: boolean
    broker?: boolean
    origin?: boolean
    send?: boolean
    sendAt?: boolean
    isBusinessAutoResponder?: boolean
    startmessage?: boolean
    schedulingdata?: boolean
    productchoosebyclient?: boolean
    productid?: boolean
    createdat?: boolean
    updatedat?: boolean
    curation?: boolean
    config?: boolean | CompaniesUnitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    externalid?: boolean
    sourceid?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    lastmessagesent?: boolean
    stepsecondcalltemplate?: boolean
    stepnointeraction?: boolean
    nointeractionquantity?: boolean
    accepttemplate?: boolean
    acceptsecondtemplate?: boolean
    status?: boolean
    dialog?: boolean
    configid?: boolean
    whitelabelconfig?: boolean
    lastintent?: boolean
    broker?: boolean
    origin?: boolean
    send?: boolean
    sendAt?: boolean
    isBusinessAutoResponder?: boolean
    startmessage?: boolean
    schedulingdata?: boolean
    productchoosebyclient?: boolean
    productid?: boolean
    createdat?: boolean
    updatedat?: boolean
    curation?: boolean
  }

  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageLog?: boolean | Lead$MessageLogArgs<ExtArgs>
    config?: boolean | CompaniesUnitesDefaultArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | CompaniesUnitesDefaultArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      MessageLog: Prisma.$MessageLogPayload<ExtArgs>[]
      config: Prisma.$CompaniesUnitesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalid: string | null
      sourceid: string | null
      name: string
      phone: string
      email: string | null
      lastmessagesent: Date | null
      stepsecondcalltemplate: number | null
      stepnointeraction: number | null
      nointeractionquantity: number | null
      accepttemplate: boolean | null
      acceptsecondtemplate: boolean | null
      status: string | null
      dialog: Prisma.JsonValue[]
      configid: string
      whitelabelconfig: string
      lastintent: string | null
      broker: string | null
      origin: string | null
      send: boolean | null
      sendAt: Date | null
      isBusinessAutoResponder: boolean | null
      startmessage: Date | null
      schedulingdata: string | null
      productchoosebyclient: string | null
      productid: number | null
      createdat: Date | null
      updatedat: Date | null
      curation: Prisma.JsonValue | null
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MessageLog<T extends Lead$MessageLogArgs<ExtArgs> = {}>(args?: Subset<T, Lead$MessageLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findMany"> | Null>
    config<T extends CompaniesUnitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUnitesDefaultArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */ 
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly externalid: FieldRef<"Lead", 'String'>
    readonly sourceid: FieldRef<"Lead", 'String'>
    readonly name: FieldRef<"Lead", 'String'>
    readonly phone: FieldRef<"Lead", 'String'>
    readonly email: FieldRef<"Lead", 'String'>
    readonly lastmessagesent: FieldRef<"Lead", 'DateTime'>
    readonly stepsecondcalltemplate: FieldRef<"Lead", 'Int'>
    readonly stepnointeraction: FieldRef<"Lead", 'Int'>
    readonly nointeractionquantity: FieldRef<"Lead", 'Int'>
    readonly accepttemplate: FieldRef<"Lead", 'Boolean'>
    readonly acceptsecondtemplate: FieldRef<"Lead", 'Boolean'>
    readonly status: FieldRef<"Lead", 'String'>
    readonly dialog: FieldRef<"Lead", 'Json[]'>
    readonly configid: FieldRef<"Lead", 'String'>
    readonly whitelabelconfig: FieldRef<"Lead", 'String'>
    readonly lastintent: FieldRef<"Lead", 'String'>
    readonly broker: FieldRef<"Lead", 'String'>
    readonly origin: FieldRef<"Lead", 'String'>
    readonly send: FieldRef<"Lead", 'Boolean'>
    readonly sendAt: FieldRef<"Lead", 'DateTime'>
    readonly isBusinessAutoResponder: FieldRef<"Lead", 'Boolean'>
    readonly startmessage: FieldRef<"Lead", 'DateTime'>
    readonly schedulingdata: FieldRef<"Lead", 'String'>
    readonly productchoosebyclient: FieldRef<"Lead", 'String'>
    readonly productid: FieldRef<"Lead", 'Int'>
    readonly createdat: FieldRef<"Lead", 'DateTime'>
    readonly updatedat: FieldRef<"Lead", 'DateTime'>
    readonly curation: FieldRef<"Lead", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
  }

  /**
   * Lead.MessageLog
   */
  export type Lead$MessageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    where?: MessageLogWhereInput
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    cursor?: MessageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageLogScalarFieldEnum | MessageLogScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model Bot_Descritivo
   */

  export type AggregateBot_Descritivo = {
    _count: Bot_DescritivoCountAggregateOutputType | null
    _min: Bot_DescritivoMinAggregateOutputType | null
    _max: Bot_DescritivoMaxAggregateOutputType | null
  }

  export type Bot_DescritivoMinAggregateOutputType = {
    id: string | null
    name: string | null
    descritivo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Bot_DescritivoMaxAggregateOutputType = {
    id: string | null
    name: string | null
    descritivo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Bot_DescritivoCountAggregateOutputType = {
    id: number
    name: number
    descritivo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Bot_DescritivoMinAggregateInputType = {
    id?: true
    name?: true
    descritivo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Bot_DescritivoMaxAggregateInputType = {
    id?: true
    name?: true
    descritivo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Bot_DescritivoCountAggregateInputType = {
    id?: true
    name?: true
    descritivo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Bot_DescritivoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bot_Descritivo to aggregate.
     */
    where?: Bot_DescritivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bot_Descritivos to fetch.
     */
    orderBy?: Bot_DescritivoOrderByWithRelationInput | Bot_DescritivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Bot_DescritivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bot_Descritivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bot_Descritivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bot_Descritivos
    **/
    _count?: true | Bot_DescritivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bot_DescritivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bot_DescritivoMaxAggregateInputType
  }

  export type GetBot_DescritivoAggregateType<T extends Bot_DescritivoAggregateArgs> = {
        [P in keyof T & keyof AggregateBot_Descritivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot_Descritivo[P]>
      : GetScalarType<T[P], AggregateBot_Descritivo[P]>
  }




  export type Bot_DescritivoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Bot_DescritivoWhereInput
    orderBy?: Bot_DescritivoOrderByWithAggregationInput | Bot_DescritivoOrderByWithAggregationInput[]
    by: Bot_DescritivoScalarFieldEnum[] | Bot_DescritivoScalarFieldEnum
    having?: Bot_DescritivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bot_DescritivoCountAggregateInputType | true
    _min?: Bot_DescritivoMinAggregateInputType
    _max?: Bot_DescritivoMaxAggregateInputType
  }

  export type Bot_DescritivoGroupByOutputType = {
    id: string
    name: string
    descritivo: string
    createdAt: Date
    updatedAt: Date
    _count: Bot_DescritivoCountAggregateOutputType | null
    _min: Bot_DescritivoMinAggregateOutputType | null
    _max: Bot_DescritivoMaxAggregateOutputType | null
  }

  type GetBot_DescritivoGroupByPayload<T extends Bot_DescritivoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bot_DescritivoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bot_DescritivoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bot_DescritivoGroupByOutputType[P]>
            : GetScalarType<T[P], Bot_DescritivoGroupByOutputType[P]>
        }
      >
    >


  export type Bot_DescritivoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    descritivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bot_Descritivo"]>

  export type Bot_DescritivoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    descritivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bot_Descritivo"]>

  export type Bot_DescritivoSelectScalar = {
    id?: boolean
    name?: boolean
    descritivo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $Bot_DescritivoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bot_Descritivo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      descritivo: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bot_Descritivo"]>
    composites: {}
  }

  type Bot_DescritivoGetPayload<S extends boolean | null | undefined | Bot_DescritivoDefaultArgs> = $Result.GetResult<Prisma.$Bot_DescritivoPayload, S>

  type Bot_DescritivoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Bot_DescritivoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bot_DescritivoCountAggregateInputType | true
    }

  export interface Bot_DescritivoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bot_Descritivo'], meta: { name: 'Bot_Descritivo' } }
    /**
     * Find zero or one Bot_Descritivo that matches the filter.
     * @param {Bot_DescritivoFindUniqueArgs} args - Arguments to find a Bot_Descritivo
     * @example
     * // Get one Bot_Descritivo
     * const bot_Descritivo = await prisma.bot_Descritivo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Bot_DescritivoFindUniqueArgs>(args: SelectSubset<T, Bot_DescritivoFindUniqueArgs<ExtArgs>>): Prisma__Bot_DescritivoClient<$Result.GetResult<Prisma.$Bot_DescritivoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bot_Descritivo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Bot_DescritivoFindUniqueOrThrowArgs} args - Arguments to find a Bot_Descritivo
     * @example
     * // Get one Bot_Descritivo
     * const bot_Descritivo = await prisma.bot_Descritivo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Bot_DescritivoFindUniqueOrThrowArgs>(args: SelectSubset<T, Bot_DescritivoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Bot_DescritivoClient<$Result.GetResult<Prisma.$Bot_DescritivoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bot_Descritivo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_DescritivoFindFirstArgs} args - Arguments to find a Bot_Descritivo
     * @example
     * // Get one Bot_Descritivo
     * const bot_Descritivo = await prisma.bot_Descritivo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Bot_DescritivoFindFirstArgs>(args?: SelectSubset<T, Bot_DescritivoFindFirstArgs<ExtArgs>>): Prisma__Bot_DescritivoClient<$Result.GetResult<Prisma.$Bot_DescritivoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bot_Descritivo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_DescritivoFindFirstOrThrowArgs} args - Arguments to find a Bot_Descritivo
     * @example
     * // Get one Bot_Descritivo
     * const bot_Descritivo = await prisma.bot_Descritivo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Bot_DescritivoFindFirstOrThrowArgs>(args?: SelectSubset<T, Bot_DescritivoFindFirstOrThrowArgs<ExtArgs>>): Prisma__Bot_DescritivoClient<$Result.GetResult<Prisma.$Bot_DescritivoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bot_Descritivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_DescritivoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bot_Descritivos
     * const bot_Descritivos = await prisma.bot_Descritivo.findMany()
     * 
     * // Get first 10 Bot_Descritivos
     * const bot_Descritivos = await prisma.bot_Descritivo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bot_DescritivoWithIdOnly = await prisma.bot_Descritivo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Bot_DescritivoFindManyArgs>(args?: SelectSubset<T, Bot_DescritivoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Bot_DescritivoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bot_Descritivo.
     * @param {Bot_DescritivoCreateArgs} args - Arguments to create a Bot_Descritivo.
     * @example
     * // Create one Bot_Descritivo
     * const Bot_Descritivo = await prisma.bot_Descritivo.create({
     *   data: {
     *     // ... data to create a Bot_Descritivo
     *   }
     * })
     * 
     */
    create<T extends Bot_DescritivoCreateArgs>(args: SelectSubset<T, Bot_DescritivoCreateArgs<ExtArgs>>): Prisma__Bot_DescritivoClient<$Result.GetResult<Prisma.$Bot_DescritivoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bot_Descritivos.
     * @param {Bot_DescritivoCreateManyArgs} args - Arguments to create many Bot_Descritivos.
     * @example
     * // Create many Bot_Descritivos
     * const bot_Descritivo = await prisma.bot_Descritivo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Bot_DescritivoCreateManyArgs>(args?: SelectSubset<T, Bot_DescritivoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bot_Descritivos and returns the data saved in the database.
     * @param {Bot_DescritivoCreateManyAndReturnArgs} args - Arguments to create many Bot_Descritivos.
     * @example
     * // Create many Bot_Descritivos
     * const bot_Descritivo = await prisma.bot_Descritivo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bot_Descritivos and only return the `id`
     * const bot_DescritivoWithIdOnly = await prisma.bot_Descritivo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Bot_DescritivoCreateManyAndReturnArgs>(args?: SelectSubset<T, Bot_DescritivoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Bot_DescritivoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bot_Descritivo.
     * @param {Bot_DescritivoDeleteArgs} args - Arguments to delete one Bot_Descritivo.
     * @example
     * // Delete one Bot_Descritivo
     * const Bot_Descritivo = await prisma.bot_Descritivo.delete({
     *   where: {
     *     // ... filter to delete one Bot_Descritivo
     *   }
     * })
     * 
     */
    delete<T extends Bot_DescritivoDeleteArgs>(args: SelectSubset<T, Bot_DescritivoDeleteArgs<ExtArgs>>): Prisma__Bot_DescritivoClient<$Result.GetResult<Prisma.$Bot_DescritivoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bot_Descritivo.
     * @param {Bot_DescritivoUpdateArgs} args - Arguments to update one Bot_Descritivo.
     * @example
     * // Update one Bot_Descritivo
     * const bot_Descritivo = await prisma.bot_Descritivo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Bot_DescritivoUpdateArgs>(args: SelectSubset<T, Bot_DescritivoUpdateArgs<ExtArgs>>): Prisma__Bot_DescritivoClient<$Result.GetResult<Prisma.$Bot_DescritivoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bot_Descritivos.
     * @param {Bot_DescritivoDeleteManyArgs} args - Arguments to filter Bot_Descritivos to delete.
     * @example
     * // Delete a few Bot_Descritivos
     * const { count } = await prisma.bot_Descritivo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Bot_DescritivoDeleteManyArgs>(args?: SelectSubset<T, Bot_DescritivoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bot_Descritivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_DescritivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bot_Descritivos
     * const bot_Descritivo = await prisma.bot_Descritivo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Bot_DescritivoUpdateManyArgs>(args: SelectSubset<T, Bot_DescritivoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bot_Descritivo.
     * @param {Bot_DescritivoUpsertArgs} args - Arguments to update or create a Bot_Descritivo.
     * @example
     * // Update or create a Bot_Descritivo
     * const bot_Descritivo = await prisma.bot_Descritivo.upsert({
     *   create: {
     *     // ... data to create a Bot_Descritivo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot_Descritivo we want to update
     *   }
     * })
     */
    upsert<T extends Bot_DescritivoUpsertArgs>(args: SelectSubset<T, Bot_DescritivoUpsertArgs<ExtArgs>>): Prisma__Bot_DescritivoClient<$Result.GetResult<Prisma.$Bot_DescritivoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bot_Descritivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_DescritivoCountArgs} args - Arguments to filter Bot_Descritivos to count.
     * @example
     * // Count the number of Bot_Descritivos
     * const count = await prisma.bot_Descritivo.count({
     *   where: {
     *     // ... the filter for the Bot_Descritivos we want to count
     *   }
     * })
    **/
    count<T extends Bot_DescritivoCountArgs>(
      args?: Subset<T, Bot_DescritivoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bot_DescritivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot_Descritivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_DescritivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bot_DescritivoAggregateArgs>(args: Subset<T, Bot_DescritivoAggregateArgs>): Prisma.PrismaPromise<GetBot_DescritivoAggregateType<T>>

    /**
     * Group by Bot_Descritivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bot_DescritivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Bot_DescritivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Bot_DescritivoGroupByArgs['orderBy'] }
        : { orderBy?: Bot_DescritivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Bot_DescritivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBot_DescritivoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bot_Descritivo model
   */
  readonly fields: Bot_DescritivoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bot_Descritivo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Bot_DescritivoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bot_Descritivo model
   */ 
  interface Bot_DescritivoFieldRefs {
    readonly id: FieldRef<"Bot_Descritivo", 'String'>
    readonly name: FieldRef<"Bot_Descritivo", 'String'>
    readonly descritivo: FieldRef<"Bot_Descritivo", 'String'>
    readonly createdAt: FieldRef<"Bot_Descritivo", 'DateTime'>
    readonly updatedAt: FieldRef<"Bot_Descritivo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bot_Descritivo findUnique
   */
  export type Bot_DescritivoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot_Descritivo
     */
    select?: Bot_DescritivoSelect<ExtArgs> | null
    /**
     * Filter, which Bot_Descritivo to fetch.
     */
    where: Bot_DescritivoWhereUniqueInput
  }

  /**
   * Bot_Descritivo findUniqueOrThrow
   */
  export type Bot_DescritivoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot_Descritivo
     */
    select?: Bot_DescritivoSelect<ExtArgs> | null
    /**
     * Filter, which Bot_Descritivo to fetch.
     */
    where: Bot_DescritivoWhereUniqueInput
  }

  /**
   * Bot_Descritivo findFirst
   */
  export type Bot_DescritivoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot_Descritivo
     */
    select?: Bot_DescritivoSelect<ExtArgs> | null
    /**
     * Filter, which Bot_Descritivo to fetch.
     */
    where?: Bot_DescritivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bot_Descritivos to fetch.
     */
    orderBy?: Bot_DescritivoOrderByWithRelationInput | Bot_DescritivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bot_Descritivos.
     */
    cursor?: Bot_DescritivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bot_Descritivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bot_Descritivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bot_Descritivos.
     */
    distinct?: Bot_DescritivoScalarFieldEnum | Bot_DescritivoScalarFieldEnum[]
  }

  /**
   * Bot_Descritivo findFirstOrThrow
   */
  export type Bot_DescritivoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot_Descritivo
     */
    select?: Bot_DescritivoSelect<ExtArgs> | null
    /**
     * Filter, which Bot_Descritivo to fetch.
     */
    where?: Bot_DescritivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bot_Descritivos to fetch.
     */
    orderBy?: Bot_DescritivoOrderByWithRelationInput | Bot_DescritivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bot_Descritivos.
     */
    cursor?: Bot_DescritivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bot_Descritivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bot_Descritivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bot_Descritivos.
     */
    distinct?: Bot_DescritivoScalarFieldEnum | Bot_DescritivoScalarFieldEnum[]
  }

  /**
   * Bot_Descritivo findMany
   */
  export type Bot_DescritivoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot_Descritivo
     */
    select?: Bot_DescritivoSelect<ExtArgs> | null
    /**
     * Filter, which Bot_Descritivos to fetch.
     */
    where?: Bot_DescritivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bot_Descritivos to fetch.
     */
    orderBy?: Bot_DescritivoOrderByWithRelationInput | Bot_DescritivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bot_Descritivos.
     */
    cursor?: Bot_DescritivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bot_Descritivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bot_Descritivos.
     */
    skip?: number
    distinct?: Bot_DescritivoScalarFieldEnum | Bot_DescritivoScalarFieldEnum[]
  }

  /**
   * Bot_Descritivo create
   */
  export type Bot_DescritivoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot_Descritivo
     */
    select?: Bot_DescritivoSelect<ExtArgs> | null
    /**
     * The data needed to create a Bot_Descritivo.
     */
    data: XOR<Bot_DescritivoCreateInput, Bot_DescritivoUncheckedCreateInput>
  }

  /**
   * Bot_Descritivo createMany
   */
  export type Bot_DescritivoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bot_Descritivos.
     */
    data: Bot_DescritivoCreateManyInput | Bot_DescritivoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bot_Descritivo createManyAndReturn
   */
  export type Bot_DescritivoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot_Descritivo
     */
    select?: Bot_DescritivoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bot_Descritivos.
     */
    data: Bot_DescritivoCreateManyInput | Bot_DescritivoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bot_Descritivo update
   */
  export type Bot_DescritivoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot_Descritivo
     */
    select?: Bot_DescritivoSelect<ExtArgs> | null
    /**
     * The data needed to update a Bot_Descritivo.
     */
    data: XOR<Bot_DescritivoUpdateInput, Bot_DescritivoUncheckedUpdateInput>
    /**
     * Choose, which Bot_Descritivo to update.
     */
    where: Bot_DescritivoWhereUniqueInput
  }

  /**
   * Bot_Descritivo updateMany
   */
  export type Bot_DescritivoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bot_Descritivos.
     */
    data: XOR<Bot_DescritivoUpdateManyMutationInput, Bot_DescritivoUncheckedUpdateManyInput>
    /**
     * Filter which Bot_Descritivos to update
     */
    where?: Bot_DescritivoWhereInput
  }

  /**
   * Bot_Descritivo upsert
   */
  export type Bot_DescritivoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot_Descritivo
     */
    select?: Bot_DescritivoSelect<ExtArgs> | null
    /**
     * The filter to search for the Bot_Descritivo to update in case it exists.
     */
    where: Bot_DescritivoWhereUniqueInput
    /**
     * In case the Bot_Descritivo found by the `where` argument doesn't exist, create a new Bot_Descritivo with this data.
     */
    create: XOR<Bot_DescritivoCreateInput, Bot_DescritivoUncheckedCreateInput>
    /**
     * In case the Bot_Descritivo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Bot_DescritivoUpdateInput, Bot_DescritivoUncheckedUpdateInput>
  }

  /**
   * Bot_Descritivo delete
   */
  export type Bot_DescritivoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot_Descritivo
     */
    select?: Bot_DescritivoSelect<ExtArgs> | null
    /**
     * Filter which Bot_Descritivo to delete.
     */
    where: Bot_DescritivoWhereUniqueInput
  }

  /**
   * Bot_Descritivo deleteMany
   */
  export type Bot_DescritivoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bot_Descritivos to delete
     */
    where?: Bot_DescritivoWhereInput
  }

  /**
   * Bot_Descritivo without action
   */
  export type Bot_DescritivoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot_Descritivo
     */
    select?: Bot_DescritivoSelect<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    stripePaymentId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    customerId: string | null
    disputeStatus: string | null
    disputeReason: string | null
    cancelReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    stripePaymentId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    customerId: string | null
    disputeStatus: string | null
    disputeReason: string | null
    cancelReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    stripePaymentId: number
    amount: number
    currency: number
    status: number
    customerId: number
    metadata: number
    disputeStatus: number
    disputeReason: number
    cancelReason: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    stripePaymentId?: true
    amount?: true
    currency?: true
    status?: true
    customerId?: true
    disputeStatus?: true
    disputeReason?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    stripePaymentId?: true
    amount?: true
    currency?: true
    status?: true
    customerId?: true
    disputeStatus?: true
    disputeReason?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    stripePaymentId?: true
    amount?: true
    currency?: true
    status?: true
    customerId?: true
    metadata?: true
    disputeStatus?: true
    disputeReason?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    customerId: string | null
    metadata: JsonValue | null
    disputeStatus: string | null
    disputeReason: string | null
    cancelReason: string | null
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripePaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    customerId?: boolean
    metadata?: boolean
    disputeStatus?: boolean
    disputeReason?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Payment$userArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripePaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    customerId?: boolean
    metadata?: boolean
    disputeStatus?: boolean
    disputeReason?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Payment$userArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    stripePaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    customerId?: boolean
    metadata?: boolean
    disputeStatus?: boolean
    disputeReason?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Payment$userArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Payment$userArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stripePaymentId: string
      amount: number
      currency: string
      status: string
      customerId: string | null
      metadata: Prisma.JsonValue | null
      disputeStatus: string | null
      disputeReason: string | null
      cancelReason: string | null
      createdAt: Date
      updatedAt: Date
      userId: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Payment$userArgs<ExtArgs> = {}>(args?: Subset<T, Payment$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly stripePaymentId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Int'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly customerId: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly disputeStatus: FieldRef<"Payment", 'String'>
    readonly disputeReason: FieldRef<"Payment", 'String'>
    readonly cancelReason: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly userId: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.user
   */
  export type Payment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Instance
   */

  export type AggregateInstance = {
    _count: InstanceCountAggregateOutputType | null
    _min: InstanceMinAggregateOutputType | null
    _max: InstanceMaxAggregateOutputType | null
  }

  export type InstanceMinAggregateOutputType = {
    id: string | null
    instanceName: string | null
    connectionStatus: string | null
    number: string | null
    ownerJid: string | null
    profilePicUrl: string | null
    integration: string | null
    token: string | null
    clientName: string | null
    profileName: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    disconnectedAt: Date | null
    disconnectionReasonCode: string | null
  }

  export type InstanceMaxAggregateOutputType = {
    id: string | null
    instanceName: string | null
    connectionStatus: string | null
    number: string | null
    ownerJid: string | null
    profilePicUrl: string | null
    integration: string | null
    token: string | null
    clientName: string | null
    profileName: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    disconnectedAt: Date | null
    disconnectionReasonCode: string | null
  }

  export type InstanceCountAggregateOutputType = {
    id: number
    instanceName: number
    connectionStatus: number
    number: number
    ownerJid: number
    profilePicUrl: number
    integration: number
    token: number
    clientName: number
    profileName: number
    userId: number
    createdAt: number
    updatedAt: number
    disconnectedAt: number
    disconnectionObject: number
    disconnectionReasonCode: number
    proxyConfig: number
    typebot: number
    _all: number
  }


  export type InstanceMinAggregateInputType = {
    id?: true
    instanceName?: true
    connectionStatus?: true
    number?: true
    ownerJid?: true
    profilePicUrl?: true
    integration?: true
    token?: true
    clientName?: true
    profileName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    disconnectedAt?: true
    disconnectionReasonCode?: true
  }

  export type InstanceMaxAggregateInputType = {
    id?: true
    instanceName?: true
    connectionStatus?: true
    number?: true
    ownerJid?: true
    profilePicUrl?: true
    integration?: true
    token?: true
    clientName?: true
    profileName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    disconnectedAt?: true
    disconnectionReasonCode?: true
  }

  export type InstanceCountAggregateInputType = {
    id?: true
    instanceName?: true
    connectionStatus?: true
    number?: true
    ownerJid?: true
    profilePicUrl?: true
    integration?: true
    token?: true
    clientName?: true
    profileName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    disconnectedAt?: true
    disconnectionObject?: true
    disconnectionReasonCode?: true
    proxyConfig?: true
    typebot?: true
    _all?: true
  }

  export type InstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instance to aggregate.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instances
    **/
    _count?: true | InstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstanceMaxAggregateInputType
  }

  export type GetInstanceAggregateType<T extends InstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstance[P]>
      : GetScalarType<T[P], AggregateInstance[P]>
  }




  export type InstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstanceWhereInput
    orderBy?: InstanceOrderByWithAggregationInput | InstanceOrderByWithAggregationInput[]
    by: InstanceScalarFieldEnum[] | InstanceScalarFieldEnum
    having?: InstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstanceCountAggregateInputType | true
    _min?: InstanceMinAggregateInputType
    _max?: InstanceMaxAggregateInputType
  }

  export type InstanceGroupByOutputType = {
    id: string
    instanceName: string
    connectionStatus: string
    number: string | null
    ownerJid: string | null
    profilePicUrl: string | null
    integration: string
    token: string | null
    clientName: string | null
    profileName: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    disconnectedAt: Date | null
    disconnectionObject: JsonValue | null
    disconnectionReasonCode: string | null
    proxyConfig: JsonValue | null
    typebot: JsonValue | null
    _count: InstanceCountAggregateOutputType | null
    _min: InstanceMinAggregateOutputType | null
    _max: InstanceMaxAggregateOutputType | null
  }

  type GetInstanceGroupByPayload<T extends InstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstanceGroupByOutputType[P]>
            : GetScalarType<T[P], InstanceGroupByOutputType[P]>
        }
      >
    >


  export type InstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    connectionStatus?: boolean
    number?: boolean
    ownerJid?: boolean
    profilePicUrl?: boolean
    integration?: boolean
    token?: boolean
    clientName?: boolean
    profileName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disconnectedAt?: boolean
    disconnectionObject?: boolean
    disconnectionReasonCode?: boolean
    proxyConfig?: boolean
    typebot?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mediaStats?: boolean | Instance$mediaStatsArgs<ExtArgs>
    warmupStats?: boolean | Instance$warmupStatsArgs<ExtArgs>
    Campaign?: boolean | Instance$CampaignArgs<ExtArgs>
    _count?: boolean | InstanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instance"]>

  export type InstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    connectionStatus?: boolean
    number?: boolean
    ownerJid?: boolean
    profilePicUrl?: boolean
    integration?: boolean
    token?: boolean
    clientName?: boolean
    profileName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disconnectedAt?: boolean
    disconnectionObject?: boolean
    disconnectionReasonCode?: boolean
    proxyConfig?: boolean
    typebot?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instance"]>

  export type InstanceSelectScalar = {
    id?: boolean
    instanceName?: boolean
    connectionStatus?: boolean
    number?: boolean
    ownerJid?: boolean
    profilePicUrl?: boolean
    integration?: boolean
    token?: boolean
    clientName?: boolean
    profileName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disconnectedAt?: boolean
    disconnectionObject?: boolean
    disconnectionReasonCode?: boolean
    proxyConfig?: boolean
    typebot?: boolean
  }

  export type InstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mediaStats?: boolean | Instance$mediaStatsArgs<ExtArgs>
    warmupStats?: boolean | Instance$warmupStatsArgs<ExtArgs>
    Campaign?: boolean | Instance$CampaignArgs<ExtArgs>
    _count?: boolean | InstanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      mediaStats: Prisma.$MediaStatsPayload<ExtArgs>[]
      warmupStats: Prisma.$WarmupStatsPayload<ExtArgs> | null
      Campaign: Prisma.$CampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceName: string
      connectionStatus: string
      number: string | null
      ownerJid: string | null
      profilePicUrl: string | null
      integration: string
      token: string | null
      clientName: string | null
      profileName: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
      disconnectedAt: Date | null
      disconnectionObject: Prisma.JsonValue | null
      disconnectionReasonCode: string | null
      proxyConfig: Prisma.JsonValue | null
      typebot: Prisma.JsonValue | null
    }, ExtArgs["result"]["instance"]>
    composites: {}
  }

  type InstanceGetPayload<S extends boolean | null | undefined | InstanceDefaultArgs> = $Result.GetResult<Prisma.$InstancePayload, S>

  type InstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstanceCountAggregateInputType | true
    }

  export interface InstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instance'], meta: { name: 'Instance' } }
    /**
     * Find zero or one Instance that matches the filter.
     * @param {InstanceFindUniqueArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstanceFindUniqueArgs>(args: SelectSubset<T, InstanceFindUniqueArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Instance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InstanceFindUniqueOrThrowArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, InstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Instance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindFirstArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstanceFindFirstArgs>(args?: SelectSubset<T, InstanceFindFirstArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Instance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindFirstOrThrowArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, InstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Instances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instances
     * const instances = await prisma.instance.findMany()
     * 
     * // Get first 10 Instances
     * const instances = await prisma.instance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instanceWithIdOnly = await prisma.instance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstanceFindManyArgs>(args?: SelectSubset<T, InstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Instance.
     * @param {InstanceCreateArgs} args - Arguments to create a Instance.
     * @example
     * // Create one Instance
     * const Instance = await prisma.instance.create({
     *   data: {
     *     // ... data to create a Instance
     *   }
     * })
     * 
     */
    create<T extends InstanceCreateArgs>(args: SelectSubset<T, InstanceCreateArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Instances.
     * @param {InstanceCreateManyArgs} args - Arguments to create many Instances.
     * @example
     * // Create many Instances
     * const instance = await prisma.instance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstanceCreateManyArgs>(args?: SelectSubset<T, InstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Instances and returns the data saved in the database.
     * @param {InstanceCreateManyAndReturnArgs} args - Arguments to create many Instances.
     * @example
     * // Create many Instances
     * const instance = await prisma.instance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Instances and only return the `id`
     * const instanceWithIdOnly = await prisma.instance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, InstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Instance.
     * @param {InstanceDeleteArgs} args - Arguments to delete one Instance.
     * @example
     * // Delete one Instance
     * const Instance = await prisma.instance.delete({
     *   where: {
     *     // ... filter to delete one Instance
     *   }
     * })
     * 
     */
    delete<T extends InstanceDeleteArgs>(args: SelectSubset<T, InstanceDeleteArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Instance.
     * @param {InstanceUpdateArgs} args - Arguments to update one Instance.
     * @example
     * // Update one Instance
     * const instance = await prisma.instance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstanceUpdateArgs>(args: SelectSubset<T, InstanceUpdateArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Instances.
     * @param {InstanceDeleteManyArgs} args - Arguments to filter Instances to delete.
     * @example
     * // Delete a few Instances
     * const { count } = await prisma.instance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstanceDeleteManyArgs>(args?: SelectSubset<T, InstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instances
     * const instance = await prisma.instance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstanceUpdateManyArgs>(args: SelectSubset<T, InstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Instance.
     * @param {InstanceUpsertArgs} args - Arguments to update or create a Instance.
     * @example
     * // Update or create a Instance
     * const instance = await prisma.instance.upsert({
     *   create: {
     *     // ... data to create a Instance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instance we want to update
     *   }
     * })
     */
    upsert<T extends InstanceUpsertArgs>(args: SelectSubset<T, InstanceUpsertArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceCountArgs} args - Arguments to filter Instances to count.
     * @example
     * // Count the number of Instances
     * const count = await prisma.instance.count({
     *   where: {
     *     // ... the filter for the Instances we want to count
     *   }
     * })
    **/
    count<T extends InstanceCountArgs>(
      args?: Subset<T, InstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstanceAggregateArgs>(args: Subset<T, InstanceAggregateArgs>): Prisma.PrismaPromise<GetInstanceAggregateType<T>>

    /**
     * Group by Instance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstanceGroupByArgs['orderBy'] }
        : { orderBy?: InstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instance model
   */
  readonly fields: InstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mediaStats<T extends Instance$mediaStatsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$mediaStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findMany"> | Null>
    warmupStats<T extends Instance$warmupStatsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$warmupStatsArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Campaign<T extends Instance$CampaignArgs<ExtArgs> = {}>(args?: Subset<T, Instance$CampaignArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instance model
   */ 
  interface InstanceFieldRefs {
    readonly id: FieldRef<"Instance", 'String'>
    readonly instanceName: FieldRef<"Instance", 'String'>
    readonly connectionStatus: FieldRef<"Instance", 'String'>
    readonly number: FieldRef<"Instance", 'String'>
    readonly ownerJid: FieldRef<"Instance", 'String'>
    readonly profilePicUrl: FieldRef<"Instance", 'String'>
    readonly integration: FieldRef<"Instance", 'String'>
    readonly token: FieldRef<"Instance", 'String'>
    readonly clientName: FieldRef<"Instance", 'String'>
    readonly profileName: FieldRef<"Instance", 'String'>
    readonly userId: FieldRef<"Instance", 'String'>
    readonly createdAt: FieldRef<"Instance", 'DateTime'>
    readonly updatedAt: FieldRef<"Instance", 'DateTime'>
    readonly disconnectedAt: FieldRef<"Instance", 'DateTime'>
    readonly disconnectionObject: FieldRef<"Instance", 'Json'>
    readonly disconnectionReasonCode: FieldRef<"Instance", 'String'>
    readonly proxyConfig: FieldRef<"Instance", 'Json'>
    readonly typebot: FieldRef<"Instance", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Instance findUnique
   */
  export type InstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance findUniqueOrThrow
   */
  export type InstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance findFirst
   */
  export type InstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instances.
     */
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance findFirstOrThrow
   */
  export type InstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instances.
     */
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance findMany
   */
  export type InstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instances to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance create
   */
  export type InstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Instance.
     */
    data: XOR<InstanceCreateInput, InstanceUncheckedCreateInput>
  }

  /**
   * Instance createMany
   */
  export type InstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instances.
     */
    data: InstanceCreateManyInput | InstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instance createManyAndReturn
   */
  export type InstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Instances.
     */
    data: InstanceCreateManyInput | InstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Instance update
   */
  export type InstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Instance.
     */
    data: XOR<InstanceUpdateInput, InstanceUncheckedUpdateInput>
    /**
     * Choose, which Instance to update.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance updateMany
   */
  export type InstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instances.
     */
    data: XOR<InstanceUpdateManyMutationInput, InstanceUncheckedUpdateManyInput>
    /**
     * Filter which Instances to update
     */
    where?: InstanceWhereInput
  }

  /**
   * Instance upsert
   */
  export type InstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Instance to update in case it exists.
     */
    where: InstanceWhereUniqueInput
    /**
     * In case the Instance found by the `where` argument doesn't exist, create a new Instance with this data.
     */
    create: XOR<InstanceCreateInput, InstanceUncheckedCreateInput>
    /**
     * In case the Instance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstanceUpdateInput, InstanceUncheckedUpdateInput>
  }

  /**
   * Instance delete
   */
  export type InstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter which Instance to delete.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance deleteMany
   */
  export type InstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instances to delete
     */
    where?: InstanceWhereInput
  }

  /**
   * Instance.mediaStats
   */
  export type Instance$mediaStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    where?: MediaStatsWhereInput
    orderBy?: MediaStatsOrderByWithRelationInput | MediaStatsOrderByWithRelationInput[]
    cursor?: MediaStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaStatsScalarFieldEnum | MediaStatsScalarFieldEnum[]
  }

  /**
   * Instance.warmupStats
   */
  export type Instance$warmupStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    where?: WarmupStatsWhereInput
  }

  /**
   * Instance.Campaign
   */
  export type Instance$CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Instance without action
   */
  export type InstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
  }


  /**
   * Model MediaStats
   */

  export type AggregateMediaStats = {
    _count: MediaStatsCountAggregateOutputType | null
    _avg: MediaStatsAvgAggregateOutputType | null
    _sum: MediaStatsSumAggregateOutputType | null
    _min: MediaStatsMinAggregateOutputType | null
    _max: MediaStatsMaxAggregateOutputType | null
  }

  export type MediaStatsAvgAggregateOutputType = {
    text: number | null
    image: number | null
    video: number | null
    audio: number | null
    sticker: number | null
    reaction: number | null
    totalDaily: number | null
    totalAllTime: number | null
    totalSent: number | null
    totalReceived: number | null
  }

  export type MediaStatsSumAggregateOutputType = {
    text: number | null
    image: number | null
    video: number | null
    audio: number | null
    sticker: number | null
    reaction: number | null
    totalDaily: number | null
    totalAllTime: number | null
    totalSent: number | null
    totalReceived: number | null
  }

  export type MediaStatsMinAggregateOutputType = {
    id: string | null
    instanceName: string | null
    date: Date | null
    text: number | null
    image: number | null
    video: number | null
    audio: number | null
    sticker: number | null
    reaction: number | null
    isReceived: boolean | null
    totalDaily: number | null
    totalAllTime: number | null
    totalSent: number | null
    totalReceived: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaStatsMaxAggregateOutputType = {
    id: string | null
    instanceName: string | null
    date: Date | null
    text: number | null
    image: number | null
    video: number | null
    audio: number | null
    sticker: number | null
    reaction: number | null
    isReceived: boolean | null
    totalDaily: number | null
    totalAllTime: number | null
    totalSent: number | null
    totalReceived: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaStatsCountAggregateOutputType = {
    id: number
    instanceName: number
    date: number
    text: number
    image: number
    video: number
    audio: number
    sticker: number
    reaction: number
    isReceived: number
    totalDaily: number
    totalAllTime: number
    totalSent: number
    totalReceived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaStatsAvgAggregateInputType = {
    text?: true
    image?: true
    video?: true
    audio?: true
    sticker?: true
    reaction?: true
    totalDaily?: true
    totalAllTime?: true
    totalSent?: true
    totalReceived?: true
  }

  export type MediaStatsSumAggregateInputType = {
    text?: true
    image?: true
    video?: true
    audio?: true
    sticker?: true
    reaction?: true
    totalDaily?: true
    totalAllTime?: true
    totalSent?: true
    totalReceived?: true
  }

  export type MediaStatsMinAggregateInputType = {
    id?: true
    instanceName?: true
    date?: true
    text?: true
    image?: true
    video?: true
    audio?: true
    sticker?: true
    reaction?: true
    isReceived?: true
    totalDaily?: true
    totalAllTime?: true
    totalSent?: true
    totalReceived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaStatsMaxAggregateInputType = {
    id?: true
    instanceName?: true
    date?: true
    text?: true
    image?: true
    video?: true
    audio?: true
    sticker?: true
    reaction?: true
    isReceived?: true
    totalDaily?: true
    totalAllTime?: true
    totalSent?: true
    totalReceived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaStatsCountAggregateInputType = {
    id?: true
    instanceName?: true
    date?: true
    text?: true
    image?: true
    video?: true
    audio?: true
    sticker?: true
    reaction?: true
    isReceived?: true
    totalDaily?: true
    totalAllTime?: true
    totalSent?: true
    totalReceived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaStats to aggregate.
     */
    where?: MediaStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaStats to fetch.
     */
    orderBy?: MediaStatsOrderByWithRelationInput | MediaStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaStats
    **/
    _count?: true | MediaStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaStatsMaxAggregateInputType
  }

  export type GetMediaStatsAggregateType<T extends MediaStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaStats[P]>
      : GetScalarType<T[P], AggregateMediaStats[P]>
  }




  export type MediaStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaStatsWhereInput
    orderBy?: MediaStatsOrderByWithAggregationInput | MediaStatsOrderByWithAggregationInput[]
    by: MediaStatsScalarFieldEnum[] | MediaStatsScalarFieldEnum
    having?: MediaStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaStatsCountAggregateInputType | true
    _avg?: MediaStatsAvgAggregateInputType
    _sum?: MediaStatsSumAggregateInputType
    _min?: MediaStatsMinAggregateInputType
    _max?: MediaStatsMaxAggregateInputType
  }

  export type MediaStatsGroupByOutputType = {
    id: string
    instanceName: string
    date: Date
    text: number
    image: number
    video: number
    audio: number
    sticker: number
    reaction: number
    isReceived: boolean
    totalDaily: number
    totalAllTime: number
    totalSent: number
    totalReceived: number
    createdAt: Date
    updatedAt: Date
    _count: MediaStatsCountAggregateOutputType | null
    _avg: MediaStatsAvgAggregateOutputType | null
    _sum: MediaStatsSumAggregateOutputType | null
    _min: MediaStatsMinAggregateOutputType | null
    _max: MediaStatsMaxAggregateOutputType | null
  }

  type GetMediaStatsGroupByPayload<T extends MediaStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaStatsGroupByOutputType[P]>
            : GetScalarType<T[P], MediaStatsGroupByOutputType[P]>
        }
      >
    >


  export type MediaStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    date?: boolean
    text?: boolean
    image?: boolean
    video?: boolean
    audio?: boolean
    sticker?: boolean
    reaction?: boolean
    isReceived?: boolean
    totalDaily?: boolean
    totalAllTime?: boolean
    totalSent?: boolean
    totalReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    warmupStatsReceived?: boolean | MediaStats$warmupStatsReceivedArgs<ExtArgs>
    warmupStatsSent?: boolean | MediaStats$warmupStatsSentArgs<ExtArgs>
    _count?: boolean | MediaStatsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaStats"]>

  export type MediaStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    date?: boolean
    text?: boolean
    image?: boolean
    video?: boolean
    audio?: boolean
    sticker?: boolean
    reaction?: boolean
    isReceived?: boolean
    totalDaily?: boolean
    totalAllTime?: boolean
    totalSent?: boolean
    totalReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaStats"]>

  export type MediaStatsSelectScalar = {
    id?: boolean
    instanceName?: boolean
    date?: boolean
    text?: boolean
    image?: boolean
    video?: boolean
    audio?: boolean
    sticker?: boolean
    reaction?: boolean
    isReceived?: boolean
    totalDaily?: boolean
    totalAllTime?: boolean
    totalSent?: boolean
    totalReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    warmupStatsReceived?: boolean | MediaStats$warmupStatsReceivedArgs<ExtArgs>
    warmupStatsSent?: boolean | MediaStats$warmupStatsSentArgs<ExtArgs>
    _count?: boolean | MediaStatsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $MediaStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaStats"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      warmupStatsReceived: Prisma.$WarmupStatsPayload<ExtArgs>[]
      warmupStatsSent: Prisma.$WarmupStatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceName: string
      date: Date
      text: number
      image: number
      video: number
      audio: number
      sticker: number
      reaction: number
      isReceived: boolean
      totalDaily: number
      totalAllTime: number
      totalSent: number
      totalReceived: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mediaStats"]>
    composites: {}
  }

  type MediaStatsGetPayload<S extends boolean | null | undefined | MediaStatsDefaultArgs> = $Result.GetResult<Prisma.$MediaStatsPayload, S>

  type MediaStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaStatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaStatsCountAggregateInputType | true
    }

  export interface MediaStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaStats'], meta: { name: 'MediaStats' } }
    /**
     * Find zero or one MediaStats that matches the filter.
     * @param {MediaStatsFindUniqueArgs} args - Arguments to find a MediaStats
     * @example
     * // Get one MediaStats
     * const mediaStats = await prisma.mediaStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaStatsFindUniqueArgs>(args: SelectSubset<T, MediaStatsFindUniqueArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MediaStats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaStatsFindUniqueOrThrowArgs} args - Arguments to find a MediaStats
     * @example
     * // Get one MediaStats
     * const mediaStats = await prisma.mediaStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MediaStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsFindFirstArgs} args - Arguments to find a MediaStats
     * @example
     * // Get one MediaStats
     * const mediaStats = await prisma.mediaStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaStatsFindFirstArgs>(args?: SelectSubset<T, MediaStatsFindFirstArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MediaStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsFindFirstOrThrowArgs} args - Arguments to find a MediaStats
     * @example
     * // Get one MediaStats
     * const mediaStats = await prisma.mediaStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MediaStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaStats
     * const mediaStats = await prisma.mediaStats.findMany()
     * 
     * // Get first 10 MediaStats
     * const mediaStats = await prisma.mediaStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaStatsWithIdOnly = await prisma.mediaStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaStatsFindManyArgs>(args?: SelectSubset<T, MediaStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MediaStats.
     * @param {MediaStatsCreateArgs} args - Arguments to create a MediaStats.
     * @example
     * // Create one MediaStats
     * const MediaStats = await prisma.mediaStats.create({
     *   data: {
     *     // ... data to create a MediaStats
     *   }
     * })
     * 
     */
    create<T extends MediaStatsCreateArgs>(args: SelectSubset<T, MediaStatsCreateArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MediaStats.
     * @param {MediaStatsCreateManyArgs} args - Arguments to create many MediaStats.
     * @example
     * // Create many MediaStats
     * const mediaStats = await prisma.mediaStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaStatsCreateManyArgs>(args?: SelectSubset<T, MediaStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaStats and returns the data saved in the database.
     * @param {MediaStatsCreateManyAndReturnArgs} args - Arguments to create many MediaStats.
     * @example
     * // Create many MediaStats
     * const mediaStats = await prisma.mediaStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaStats and only return the `id`
     * const mediaStatsWithIdOnly = await prisma.mediaStats.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MediaStats.
     * @param {MediaStatsDeleteArgs} args - Arguments to delete one MediaStats.
     * @example
     * // Delete one MediaStats
     * const MediaStats = await prisma.mediaStats.delete({
     *   where: {
     *     // ... filter to delete one MediaStats
     *   }
     * })
     * 
     */
    delete<T extends MediaStatsDeleteArgs>(args: SelectSubset<T, MediaStatsDeleteArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MediaStats.
     * @param {MediaStatsUpdateArgs} args - Arguments to update one MediaStats.
     * @example
     * // Update one MediaStats
     * const mediaStats = await prisma.mediaStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaStatsUpdateArgs>(args: SelectSubset<T, MediaStatsUpdateArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MediaStats.
     * @param {MediaStatsDeleteManyArgs} args - Arguments to filter MediaStats to delete.
     * @example
     * // Delete a few MediaStats
     * const { count } = await prisma.mediaStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaStatsDeleteManyArgs>(args?: SelectSubset<T, MediaStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaStats
     * const mediaStats = await prisma.mediaStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaStatsUpdateManyArgs>(args: SelectSubset<T, MediaStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaStats.
     * @param {MediaStatsUpsertArgs} args - Arguments to update or create a MediaStats.
     * @example
     * // Update or create a MediaStats
     * const mediaStats = await prisma.mediaStats.upsert({
     *   create: {
     *     // ... data to create a MediaStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaStats we want to update
     *   }
     * })
     */
    upsert<T extends MediaStatsUpsertArgs>(args: SelectSubset<T, MediaStatsUpsertArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MediaStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsCountArgs} args - Arguments to filter MediaStats to count.
     * @example
     * // Count the number of MediaStats
     * const count = await prisma.mediaStats.count({
     *   where: {
     *     // ... the filter for the MediaStats we want to count
     *   }
     * })
    **/
    count<T extends MediaStatsCountArgs>(
      args?: Subset<T, MediaStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaStatsAggregateArgs>(args: Subset<T, MediaStatsAggregateArgs>): Prisma.PrismaPromise<GetMediaStatsAggregateType<T>>

    /**
     * Group by MediaStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaStatsGroupByArgs['orderBy'] }
        : { orderBy?: MediaStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaStats model
   */
  readonly fields: MediaStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    warmupStatsReceived<T extends MediaStats$warmupStatsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, MediaStats$warmupStatsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findMany"> | Null>
    warmupStatsSent<T extends MediaStats$warmupStatsSentArgs<ExtArgs> = {}>(args?: Subset<T, MediaStats$warmupStatsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaStats model
   */ 
  interface MediaStatsFieldRefs {
    readonly id: FieldRef<"MediaStats", 'String'>
    readonly instanceName: FieldRef<"MediaStats", 'String'>
    readonly date: FieldRef<"MediaStats", 'DateTime'>
    readonly text: FieldRef<"MediaStats", 'Int'>
    readonly image: FieldRef<"MediaStats", 'Int'>
    readonly video: FieldRef<"MediaStats", 'Int'>
    readonly audio: FieldRef<"MediaStats", 'Int'>
    readonly sticker: FieldRef<"MediaStats", 'Int'>
    readonly reaction: FieldRef<"MediaStats", 'Int'>
    readonly isReceived: FieldRef<"MediaStats", 'Boolean'>
    readonly totalDaily: FieldRef<"MediaStats", 'Int'>
    readonly totalAllTime: FieldRef<"MediaStats", 'Int'>
    readonly totalSent: FieldRef<"MediaStats", 'Int'>
    readonly totalReceived: FieldRef<"MediaStats", 'Int'>
    readonly createdAt: FieldRef<"MediaStats", 'DateTime'>
    readonly updatedAt: FieldRef<"MediaStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaStats findUnique
   */
  export type MediaStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * Filter, which MediaStats to fetch.
     */
    where: MediaStatsWhereUniqueInput
  }

  /**
   * MediaStats findUniqueOrThrow
   */
  export type MediaStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * Filter, which MediaStats to fetch.
     */
    where: MediaStatsWhereUniqueInput
  }

  /**
   * MediaStats findFirst
   */
  export type MediaStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * Filter, which MediaStats to fetch.
     */
    where?: MediaStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaStats to fetch.
     */
    orderBy?: MediaStatsOrderByWithRelationInput | MediaStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaStats.
     */
    cursor?: MediaStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaStats.
     */
    distinct?: MediaStatsScalarFieldEnum | MediaStatsScalarFieldEnum[]
  }

  /**
   * MediaStats findFirstOrThrow
   */
  export type MediaStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * Filter, which MediaStats to fetch.
     */
    where?: MediaStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaStats to fetch.
     */
    orderBy?: MediaStatsOrderByWithRelationInput | MediaStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaStats.
     */
    cursor?: MediaStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaStats.
     */
    distinct?: MediaStatsScalarFieldEnum | MediaStatsScalarFieldEnum[]
  }

  /**
   * MediaStats findMany
   */
  export type MediaStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * Filter, which MediaStats to fetch.
     */
    where?: MediaStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaStats to fetch.
     */
    orderBy?: MediaStatsOrderByWithRelationInput | MediaStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaStats.
     */
    cursor?: MediaStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaStats.
     */
    skip?: number
    distinct?: MediaStatsScalarFieldEnum | MediaStatsScalarFieldEnum[]
  }

  /**
   * MediaStats create
   */
  export type MediaStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaStats.
     */
    data: XOR<MediaStatsCreateInput, MediaStatsUncheckedCreateInput>
  }

  /**
   * MediaStats createMany
   */
  export type MediaStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaStats.
     */
    data: MediaStatsCreateManyInput | MediaStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaStats createManyAndReturn
   */
  export type MediaStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MediaStats.
     */
    data: MediaStatsCreateManyInput | MediaStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaStats update
   */
  export type MediaStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaStats.
     */
    data: XOR<MediaStatsUpdateInput, MediaStatsUncheckedUpdateInput>
    /**
     * Choose, which MediaStats to update.
     */
    where: MediaStatsWhereUniqueInput
  }

  /**
   * MediaStats updateMany
   */
  export type MediaStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaStats.
     */
    data: XOR<MediaStatsUpdateManyMutationInput, MediaStatsUncheckedUpdateManyInput>
    /**
     * Filter which MediaStats to update
     */
    where?: MediaStatsWhereInput
  }

  /**
   * MediaStats upsert
   */
  export type MediaStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaStats to update in case it exists.
     */
    where: MediaStatsWhereUniqueInput
    /**
     * In case the MediaStats found by the `where` argument doesn't exist, create a new MediaStats with this data.
     */
    create: XOR<MediaStatsCreateInput, MediaStatsUncheckedCreateInput>
    /**
     * In case the MediaStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaStatsUpdateInput, MediaStatsUncheckedUpdateInput>
  }

  /**
   * MediaStats delete
   */
  export type MediaStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * Filter which MediaStats to delete.
     */
    where: MediaStatsWhereUniqueInput
  }

  /**
   * MediaStats deleteMany
   */
  export type MediaStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaStats to delete
     */
    where?: MediaStatsWhereInput
  }

  /**
   * MediaStats.warmupStatsReceived
   */
  export type MediaStats$warmupStatsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    where?: WarmupStatsWhereInput
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    cursor?: WarmupStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * MediaStats.warmupStatsSent
   */
  export type MediaStats$warmupStatsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    where?: WarmupStatsWhereInput
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    cursor?: WarmupStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * MediaStats without action
   */
  export type MediaStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
  }


  /**
   * Model WarmupStats
   */

  export type AggregateWarmupStats = {
    _count: WarmupStatsCountAggregateOutputType | null
    _avg: WarmupStatsAvgAggregateOutputType | null
    _sum: WarmupStatsSumAggregateOutputType | null
    _min: WarmupStatsMinAggregateOutputType | null
    _max: WarmupStatsMaxAggregateOutputType | null
  }

  export type WarmupStatsAvgAggregateOutputType = {
    messagesSent: number | null
    messagesReceived: number | null
    warmupTime: number | null
    progress: number | null
  }

  export type WarmupStatsSumAggregateOutputType = {
    messagesSent: number | null
    messagesReceived: number | null
    warmupTime: number | null
    progress: number | null
  }

  export type WarmupStatsMinAggregateOutputType = {
    id: string | null
    instanceName: string | null
    status: string | null
    messagesSent: number | null
    messagesReceived: number | null
    warmupTime: number | null
    lastActive: Date | null
    startTime: Date | null
    pauseTime: Date | null
    progress: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mediaStatsId: string | null
    mediaReceivedId: string | null
  }

  export type WarmupStatsMaxAggregateOutputType = {
    id: string | null
    instanceName: string | null
    status: string | null
    messagesSent: number | null
    messagesReceived: number | null
    warmupTime: number | null
    lastActive: Date | null
    startTime: Date | null
    pauseTime: Date | null
    progress: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mediaStatsId: string | null
    mediaReceivedId: string | null
  }

  export type WarmupStatsCountAggregateOutputType = {
    id: number
    instanceName: number
    status: number
    messagesSent: number
    messagesReceived: number
    warmupTime: number
    lastActive: number
    startTime: number
    pauseTime: number
    progress: number
    userId: number
    createdAt: number
    updatedAt: number
    mediaStatsId: number
    mediaReceivedId: number
    _all: number
  }


  export type WarmupStatsAvgAggregateInputType = {
    messagesSent?: true
    messagesReceived?: true
    warmupTime?: true
    progress?: true
  }

  export type WarmupStatsSumAggregateInputType = {
    messagesSent?: true
    messagesReceived?: true
    warmupTime?: true
    progress?: true
  }

  export type WarmupStatsMinAggregateInputType = {
    id?: true
    instanceName?: true
    status?: true
    messagesSent?: true
    messagesReceived?: true
    warmupTime?: true
    lastActive?: true
    startTime?: true
    pauseTime?: true
    progress?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    mediaStatsId?: true
    mediaReceivedId?: true
  }

  export type WarmupStatsMaxAggregateInputType = {
    id?: true
    instanceName?: true
    status?: true
    messagesSent?: true
    messagesReceived?: true
    warmupTime?: true
    lastActive?: true
    startTime?: true
    pauseTime?: true
    progress?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    mediaStatsId?: true
    mediaReceivedId?: true
  }

  export type WarmupStatsCountAggregateInputType = {
    id?: true
    instanceName?: true
    status?: true
    messagesSent?: true
    messagesReceived?: true
    warmupTime?: true
    lastActive?: true
    startTime?: true
    pauseTime?: true
    progress?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    mediaStatsId?: true
    mediaReceivedId?: true
    _all?: true
  }

  export type WarmupStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarmupStats to aggregate.
     */
    where?: WarmupStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarmupStats to fetch.
     */
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarmupStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarmupStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarmupStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarmupStats
    **/
    _count?: true | WarmupStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarmupStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarmupStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarmupStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarmupStatsMaxAggregateInputType
  }

  export type GetWarmupStatsAggregateType<T extends WarmupStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateWarmupStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarmupStats[P]>
      : GetScalarType<T[P], AggregateWarmupStats[P]>
  }




  export type WarmupStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarmupStatsWhereInput
    orderBy?: WarmupStatsOrderByWithAggregationInput | WarmupStatsOrderByWithAggregationInput[]
    by: WarmupStatsScalarFieldEnum[] | WarmupStatsScalarFieldEnum
    having?: WarmupStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarmupStatsCountAggregateInputType | true
    _avg?: WarmupStatsAvgAggregateInputType
    _sum?: WarmupStatsSumAggregateInputType
    _min?: WarmupStatsMinAggregateInputType
    _max?: WarmupStatsMaxAggregateInputType
  }

  export type WarmupStatsGroupByOutputType = {
    id: string
    instanceName: string
    status: string
    messagesSent: number
    messagesReceived: number
    warmupTime: number
    lastActive: Date
    startTime: Date | null
    pauseTime: Date | null
    progress: number
    userId: string
    createdAt: Date
    updatedAt: Date
    mediaStatsId: string | null
    mediaReceivedId: string | null
    _count: WarmupStatsCountAggregateOutputType | null
    _avg: WarmupStatsAvgAggregateOutputType | null
    _sum: WarmupStatsSumAggregateOutputType | null
    _min: WarmupStatsMinAggregateOutputType | null
    _max: WarmupStatsMaxAggregateOutputType | null
  }

  type GetWarmupStatsGroupByPayload<T extends WarmupStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarmupStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarmupStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarmupStatsGroupByOutputType[P]>
            : GetScalarType<T[P], WarmupStatsGroupByOutputType[P]>
        }
      >
    >


  export type WarmupStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    status?: boolean
    messagesSent?: boolean
    messagesReceived?: boolean
    warmupTime?: boolean
    lastActive?: boolean
    startTime?: boolean
    pauseTime?: boolean
    progress?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaStatsId?: boolean
    mediaReceivedId?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    mediaReceived?: boolean | WarmupStats$mediaReceivedArgs<ExtArgs>
    mediaStats?: boolean | WarmupStats$mediaStatsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warmupStats"]>

  export type WarmupStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    status?: boolean
    messagesSent?: boolean
    messagesReceived?: boolean
    warmupTime?: boolean
    lastActive?: boolean
    startTime?: boolean
    pauseTime?: boolean
    progress?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaStatsId?: boolean
    mediaReceivedId?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    mediaReceived?: boolean | WarmupStats$mediaReceivedArgs<ExtArgs>
    mediaStats?: boolean | WarmupStats$mediaStatsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warmupStats"]>

  export type WarmupStatsSelectScalar = {
    id?: boolean
    instanceName?: boolean
    status?: boolean
    messagesSent?: boolean
    messagesReceived?: boolean
    warmupTime?: boolean
    lastActive?: boolean
    startTime?: boolean
    pauseTime?: boolean
    progress?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaStatsId?: boolean
    mediaReceivedId?: boolean
  }

  export type WarmupStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    mediaReceived?: boolean | WarmupStats$mediaReceivedArgs<ExtArgs>
    mediaStats?: boolean | WarmupStats$mediaStatsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WarmupStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    mediaReceived?: boolean | WarmupStats$mediaReceivedArgs<ExtArgs>
    mediaStats?: boolean | WarmupStats$mediaStatsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WarmupStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarmupStats"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      mediaReceived: Prisma.$MediaStatsPayload<ExtArgs> | null
      mediaStats: Prisma.$MediaStatsPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceName: string
      status: string
      messagesSent: number
      messagesReceived: number
      warmupTime: number
      lastActive: Date
      startTime: Date | null
      pauseTime: Date | null
      progress: number
      userId: string
      createdAt: Date
      updatedAt: Date
      mediaStatsId: string | null
      mediaReceivedId: string | null
    }, ExtArgs["result"]["warmupStats"]>
    composites: {}
  }

  type WarmupStatsGetPayload<S extends boolean | null | undefined | WarmupStatsDefaultArgs> = $Result.GetResult<Prisma.$WarmupStatsPayload, S>

  type WarmupStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WarmupStatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WarmupStatsCountAggregateInputType | true
    }

  export interface WarmupStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarmupStats'], meta: { name: 'WarmupStats' } }
    /**
     * Find zero or one WarmupStats that matches the filter.
     * @param {WarmupStatsFindUniqueArgs} args - Arguments to find a WarmupStats
     * @example
     * // Get one WarmupStats
     * const warmupStats = await prisma.warmupStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarmupStatsFindUniqueArgs>(args: SelectSubset<T, WarmupStatsFindUniqueArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WarmupStats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WarmupStatsFindUniqueOrThrowArgs} args - Arguments to find a WarmupStats
     * @example
     * // Get one WarmupStats
     * const warmupStats = await prisma.warmupStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarmupStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, WarmupStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WarmupStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsFindFirstArgs} args - Arguments to find a WarmupStats
     * @example
     * // Get one WarmupStats
     * const warmupStats = await prisma.warmupStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarmupStatsFindFirstArgs>(args?: SelectSubset<T, WarmupStatsFindFirstArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WarmupStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsFindFirstOrThrowArgs} args - Arguments to find a WarmupStats
     * @example
     * // Get one WarmupStats
     * const warmupStats = await prisma.warmupStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarmupStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, WarmupStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WarmupStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarmupStats
     * const warmupStats = await prisma.warmupStats.findMany()
     * 
     * // Get first 10 WarmupStats
     * const warmupStats = await prisma.warmupStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warmupStatsWithIdOnly = await prisma.warmupStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarmupStatsFindManyArgs>(args?: SelectSubset<T, WarmupStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WarmupStats.
     * @param {WarmupStatsCreateArgs} args - Arguments to create a WarmupStats.
     * @example
     * // Create one WarmupStats
     * const WarmupStats = await prisma.warmupStats.create({
     *   data: {
     *     // ... data to create a WarmupStats
     *   }
     * })
     * 
     */
    create<T extends WarmupStatsCreateArgs>(args: SelectSubset<T, WarmupStatsCreateArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WarmupStats.
     * @param {WarmupStatsCreateManyArgs} args - Arguments to create many WarmupStats.
     * @example
     * // Create many WarmupStats
     * const warmupStats = await prisma.warmupStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarmupStatsCreateManyArgs>(args?: SelectSubset<T, WarmupStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarmupStats and returns the data saved in the database.
     * @param {WarmupStatsCreateManyAndReturnArgs} args - Arguments to create many WarmupStats.
     * @example
     * // Create many WarmupStats
     * const warmupStats = await prisma.warmupStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarmupStats and only return the `id`
     * const warmupStatsWithIdOnly = await prisma.warmupStats.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarmupStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, WarmupStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WarmupStats.
     * @param {WarmupStatsDeleteArgs} args - Arguments to delete one WarmupStats.
     * @example
     * // Delete one WarmupStats
     * const WarmupStats = await prisma.warmupStats.delete({
     *   where: {
     *     // ... filter to delete one WarmupStats
     *   }
     * })
     * 
     */
    delete<T extends WarmupStatsDeleteArgs>(args: SelectSubset<T, WarmupStatsDeleteArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WarmupStats.
     * @param {WarmupStatsUpdateArgs} args - Arguments to update one WarmupStats.
     * @example
     * // Update one WarmupStats
     * const warmupStats = await prisma.warmupStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarmupStatsUpdateArgs>(args: SelectSubset<T, WarmupStatsUpdateArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WarmupStats.
     * @param {WarmupStatsDeleteManyArgs} args - Arguments to filter WarmupStats to delete.
     * @example
     * // Delete a few WarmupStats
     * const { count } = await prisma.warmupStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarmupStatsDeleteManyArgs>(args?: SelectSubset<T, WarmupStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarmupStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarmupStats
     * const warmupStats = await prisma.warmupStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarmupStatsUpdateManyArgs>(args: SelectSubset<T, WarmupStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WarmupStats.
     * @param {WarmupStatsUpsertArgs} args - Arguments to update or create a WarmupStats.
     * @example
     * // Update or create a WarmupStats
     * const warmupStats = await prisma.warmupStats.upsert({
     *   create: {
     *     // ... data to create a WarmupStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarmupStats we want to update
     *   }
     * })
     */
    upsert<T extends WarmupStatsUpsertArgs>(args: SelectSubset<T, WarmupStatsUpsertArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WarmupStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsCountArgs} args - Arguments to filter WarmupStats to count.
     * @example
     * // Count the number of WarmupStats
     * const count = await prisma.warmupStats.count({
     *   where: {
     *     // ... the filter for the WarmupStats we want to count
     *   }
     * })
    **/
    count<T extends WarmupStatsCountArgs>(
      args?: Subset<T, WarmupStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarmupStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarmupStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarmupStatsAggregateArgs>(args: Subset<T, WarmupStatsAggregateArgs>): Prisma.PrismaPromise<GetWarmupStatsAggregateType<T>>

    /**
     * Group by WarmupStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarmupStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarmupStatsGroupByArgs['orderBy'] }
        : { orderBy?: WarmupStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarmupStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarmupStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarmupStats model
   */
  readonly fields: WarmupStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarmupStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarmupStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mediaReceived<T extends WarmupStats$mediaReceivedArgs<ExtArgs> = {}>(args?: Subset<T, WarmupStats$mediaReceivedArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    mediaStats<T extends WarmupStats$mediaStatsArgs<ExtArgs> = {}>(args?: Subset<T, WarmupStats$mediaStatsArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarmupStats model
   */ 
  interface WarmupStatsFieldRefs {
    readonly id: FieldRef<"WarmupStats", 'String'>
    readonly instanceName: FieldRef<"WarmupStats", 'String'>
    readonly status: FieldRef<"WarmupStats", 'String'>
    readonly messagesSent: FieldRef<"WarmupStats", 'Int'>
    readonly messagesReceived: FieldRef<"WarmupStats", 'Int'>
    readonly warmupTime: FieldRef<"WarmupStats", 'Int'>
    readonly lastActive: FieldRef<"WarmupStats", 'DateTime'>
    readonly startTime: FieldRef<"WarmupStats", 'DateTime'>
    readonly pauseTime: FieldRef<"WarmupStats", 'DateTime'>
    readonly progress: FieldRef<"WarmupStats", 'Int'>
    readonly userId: FieldRef<"WarmupStats", 'String'>
    readonly createdAt: FieldRef<"WarmupStats", 'DateTime'>
    readonly updatedAt: FieldRef<"WarmupStats", 'DateTime'>
    readonly mediaStatsId: FieldRef<"WarmupStats", 'String'>
    readonly mediaReceivedId: FieldRef<"WarmupStats", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WarmupStats findUnique
   */
  export type WarmupStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * Filter, which WarmupStats to fetch.
     */
    where: WarmupStatsWhereUniqueInput
  }

  /**
   * WarmupStats findUniqueOrThrow
   */
  export type WarmupStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * Filter, which WarmupStats to fetch.
     */
    where: WarmupStatsWhereUniqueInput
  }

  /**
   * WarmupStats findFirst
   */
  export type WarmupStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * Filter, which WarmupStats to fetch.
     */
    where?: WarmupStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarmupStats to fetch.
     */
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarmupStats.
     */
    cursor?: WarmupStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarmupStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarmupStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarmupStats.
     */
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * WarmupStats findFirstOrThrow
   */
  export type WarmupStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * Filter, which WarmupStats to fetch.
     */
    where?: WarmupStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarmupStats to fetch.
     */
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarmupStats.
     */
    cursor?: WarmupStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarmupStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarmupStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarmupStats.
     */
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * WarmupStats findMany
   */
  export type WarmupStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * Filter, which WarmupStats to fetch.
     */
    where?: WarmupStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarmupStats to fetch.
     */
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarmupStats.
     */
    cursor?: WarmupStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarmupStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarmupStats.
     */
    skip?: number
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * WarmupStats create
   */
  export type WarmupStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a WarmupStats.
     */
    data: XOR<WarmupStatsCreateInput, WarmupStatsUncheckedCreateInput>
  }

  /**
   * WarmupStats createMany
   */
  export type WarmupStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarmupStats.
     */
    data: WarmupStatsCreateManyInput | WarmupStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WarmupStats createManyAndReturn
   */
  export type WarmupStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WarmupStats.
     */
    data: WarmupStatsCreateManyInput | WarmupStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarmupStats update
   */
  export type WarmupStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a WarmupStats.
     */
    data: XOR<WarmupStatsUpdateInput, WarmupStatsUncheckedUpdateInput>
    /**
     * Choose, which WarmupStats to update.
     */
    where: WarmupStatsWhereUniqueInput
  }

  /**
   * WarmupStats updateMany
   */
  export type WarmupStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarmupStats.
     */
    data: XOR<WarmupStatsUpdateManyMutationInput, WarmupStatsUncheckedUpdateManyInput>
    /**
     * Filter which WarmupStats to update
     */
    where?: WarmupStatsWhereInput
  }

  /**
   * WarmupStats upsert
   */
  export type WarmupStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the WarmupStats to update in case it exists.
     */
    where: WarmupStatsWhereUniqueInput
    /**
     * In case the WarmupStats found by the `where` argument doesn't exist, create a new WarmupStats with this data.
     */
    create: XOR<WarmupStatsCreateInput, WarmupStatsUncheckedCreateInput>
    /**
     * In case the WarmupStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarmupStatsUpdateInput, WarmupStatsUncheckedUpdateInput>
  }

  /**
   * WarmupStats delete
   */
  export type WarmupStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * Filter which WarmupStats to delete.
     */
    where: WarmupStatsWhereUniqueInput
  }

  /**
   * WarmupStats deleteMany
   */
  export type WarmupStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarmupStats to delete
     */
    where?: WarmupStatsWhereInput
  }

  /**
   * WarmupStats.mediaReceived
   */
  export type WarmupStats$mediaReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    where?: MediaStatsWhereInput
  }

  /**
   * WarmupStats.mediaStats
   */
  export type WarmupStats$mediaStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    where?: MediaStatsWhereInput
  }

  /**
   * WarmupStats without action
   */
  export type WarmupStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    progress: number | null
    minDelay: number | null
    maxDelay: number | null
  }

  export type CampaignSumAggregateOutputType = {
    progress: number | null
    minDelay: number | null
    maxDelay: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    type: string | null
    scheduledDate: Date | null
    scheduledStatus: string | null
    startedAt: Date | null
    completedAt: Date | null
    pausedAt: Date | null
    progress: number | null
    minDelay: number | null
    maxDelay: number | null
    userId: string | null
    instanceName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    type: string | null
    scheduledDate: Date | null
    scheduledStatus: string | null
    startedAt: Date | null
    completedAt: Date | null
    pausedAt: Date | null
    progress: number | null
    minDelay: number | null
    maxDelay: number | null
    userId: string | null
    instanceName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    type: number
    scheduledDate: number
    scheduledStatus: number
    startedAt: number
    completedAt: number
    pausedAt: number
    progress: number
    minDelay: number
    maxDelay: number
    userId: number
    instanceName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    progress?: true
    minDelay?: true
    maxDelay?: true
  }

  export type CampaignSumAggregateInputType = {
    progress?: true
    minDelay?: true
    maxDelay?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    type?: true
    scheduledDate?: true
    scheduledStatus?: true
    startedAt?: true
    completedAt?: true
    pausedAt?: true
    progress?: true
    minDelay?: true
    maxDelay?: true
    userId?: true
    instanceName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    type?: true
    scheduledDate?: true
    scheduledStatus?: true
    startedAt?: true
    completedAt?: true
    pausedAt?: true
    progress?: true
    minDelay?: true
    maxDelay?: true
    userId?: true
    instanceName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    type?: true
    scheduledDate?: true
    scheduledStatus?: true
    startedAt?: true
    completedAt?: true
    pausedAt?: true
    progress?: true
    minDelay?: true
    maxDelay?: true
    userId?: true
    instanceName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: string
    type: string
    scheduledDate: Date | null
    scheduledStatus: string | null
    startedAt: Date | null
    completedAt: Date | null
    pausedAt: Date | null
    progress: number
    minDelay: number
    maxDelay: number
    userId: string
    instanceName: string
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    type?: boolean
    scheduledDate?: boolean
    scheduledStatus?: boolean
    startedAt?: boolean
    completedAt?: boolean
    pausedAt?: boolean
    progress?: boolean
    minDelay?: boolean
    maxDelay?: boolean
    userId?: boolean
    instanceName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    MessageLog?: boolean | Campaign$MessageLogArgs<ExtArgs>
    leads?: boolean | Campaign$leadsArgs<ExtArgs>
    messages?: boolean | Campaign$messagesArgs<ExtArgs>
    statistics?: boolean | Campaign$statisticsArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    type?: boolean
    scheduledDate?: boolean
    scheduledStatus?: boolean
    startedAt?: boolean
    completedAt?: boolean
    pausedAt?: boolean
    progress?: boolean
    minDelay?: boolean
    maxDelay?: boolean
    userId?: boolean
    instanceName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    type?: boolean
    scheduledDate?: boolean
    scheduledStatus?: boolean
    startedAt?: boolean
    completedAt?: boolean
    pausedAt?: boolean
    progress?: boolean
    minDelay?: boolean
    maxDelay?: boolean
    userId?: boolean
    instanceName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageLog?: boolean | Campaign$MessageLogArgs<ExtArgs>
    leads?: boolean | Campaign$leadsArgs<ExtArgs>
    messages?: boolean | Campaign$messagesArgs<ExtArgs>
    statistics?: boolean | Campaign$statisticsArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      MessageLog: Prisma.$MessageLogPayload<ExtArgs>[]
      leads: Prisma.$CampaignLeadPayload<ExtArgs>[]
      messages: Prisma.$CampaignMessagePayload<ExtArgs>[]
      statistics: Prisma.$CampaignStatisticsPayload<ExtArgs> | null
      instance: Prisma.$InstancePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: string
      type: string
      scheduledDate: Date | null
      scheduledStatus: string | null
      startedAt: Date | null
      completedAt: Date | null
      pausedAt: Date | null
      progress: number
      minDelay: number
      maxDelay: number
      userId: string
      instanceName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MessageLog<T extends Campaign$MessageLogArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$MessageLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findMany"> | Null>
    leads<T extends Campaign$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Campaign$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findMany"> | Null>
    statistics<T extends Campaign$statisticsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$statisticsArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly status: FieldRef<"Campaign", 'String'>
    readonly type: FieldRef<"Campaign", 'String'>
    readonly scheduledDate: FieldRef<"Campaign", 'DateTime'>
    readonly scheduledStatus: FieldRef<"Campaign", 'String'>
    readonly startedAt: FieldRef<"Campaign", 'DateTime'>
    readonly completedAt: FieldRef<"Campaign", 'DateTime'>
    readonly pausedAt: FieldRef<"Campaign", 'DateTime'>
    readonly progress: FieldRef<"Campaign", 'Int'>
    readonly minDelay: FieldRef<"Campaign", 'Int'>
    readonly maxDelay: FieldRef<"Campaign", 'Int'>
    readonly userId: FieldRef<"Campaign", 'String'>
    readonly instanceName: FieldRef<"Campaign", 'String'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.MessageLog
   */
  export type Campaign$MessageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    where?: MessageLogWhereInput
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    cursor?: MessageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageLogScalarFieldEnum | MessageLogScalarFieldEnum[]
  }

  /**
   * Campaign.leads
   */
  export type Campaign$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    where?: CampaignLeadWhereInput
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    cursor?: CampaignLeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }

  /**
   * Campaign.messages
   */
  export type Campaign$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    where?: CampaignMessageWhereInput
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    cursor?: CampaignMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * Campaign.statistics
   */
  export type Campaign$statisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    where?: CampaignStatisticsWhereInput
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignMessage
   */

  export type AggregateCampaignMessage = {
    _count: CampaignMessageCountAggregateOutputType | null
    _avg: CampaignMessageAvgAggregateOutputType | null
    _sum: CampaignMessageSumAggregateOutputType | null
    _min: CampaignMessageMinAggregateOutputType | null
    _max: CampaignMessageMaxAggregateOutputType | null
  }

  export type CampaignMessageAvgAggregateOutputType = {
    order: number | null
  }

  export type CampaignMessageSumAggregateOutputType = {
    order: number | null
  }

  export type CampaignMessageMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    type: string | null
    content: string | null
    order: number | null
    caption: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMessageMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    type: string | null
    content: string | null
    order: number | null
    caption: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMessageCountAggregateOutputType = {
    id: number
    campaignId: number
    type: number
    content: number
    order: number
    caption: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignMessageAvgAggregateInputType = {
    order?: true
  }

  export type CampaignMessageSumAggregateInputType = {
    order?: true
  }

  export type CampaignMessageMinAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    content?: true
    order?: true
    caption?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMessageMaxAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    content?: true
    order?: true
    caption?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMessageCountAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    content?: true
    order?: true
    caption?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMessage to aggregate.
     */
    where?: CampaignMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMessages to fetch.
     */
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignMessages
    **/
    _count?: true | CampaignMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMessageMaxAggregateInputType
  }

  export type GetCampaignMessageAggregateType<T extends CampaignMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignMessage[P]>
      : GetScalarType<T[P], AggregateCampaignMessage[P]>
  }




  export type CampaignMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMessageWhereInput
    orderBy?: CampaignMessageOrderByWithAggregationInput | CampaignMessageOrderByWithAggregationInput[]
    by: CampaignMessageScalarFieldEnum[] | CampaignMessageScalarFieldEnum
    having?: CampaignMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignMessageCountAggregateInputType | true
    _avg?: CampaignMessageAvgAggregateInputType
    _sum?: CampaignMessageSumAggregateInputType
    _min?: CampaignMessageMinAggregateInputType
    _max?: CampaignMessageMaxAggregateInputType
  }

  export type CampaignMessageGroupByOutputType = {
    id: string
    campaignId: string
    type: string
    content: string
    order: number
    caption: string | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignMessageCountAggregateOutputType | null
    _avg: CampaignMessageAvgAggregateOutputType | null
    _sum: CampaignMessageSumAggregateOutputType | null
    _min: CampaignMessageMinAggregateOutputType | null
    _max: CampaignMessageMaxAggregateOutputType | null
  }

  type GetCampaignMessageGroupByPayload<T extends CampaignMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignMessageGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignMessageGroupByOutputType[P]>
        }
      >
    >


  export type CampaignMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    caption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMessage"]>

  export type CampaignMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    caption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMessage"]>

  export type CampaignMessageSelectScalar = {
    id?: boolean
    campaignId?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    caption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignMessage"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      type: string
      content: string
      order: number
      caption: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignMessage"]>
    composites: {}
  }

  type CampaignMessageGetPayload<S extends boolean | null | undefined | CampaignMessageDefaultArgs> = $Result.GetResult<Prisma.$CampaignMessagePayload, S>

  type CampaignMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignMessageCountAggregateInputType | true
    }

  export interface CampaignMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignMessage'], meta: { name: 'CampaignMessage' } }
    /**
     * Find zero or one CampaignMessage that matches the filter.
     * @param {CampaignMessageFindUniqueArgs} args - Arguments to find a CampaignMessage
     * @example
     * // Get one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignMessageFindUniqueArgs>(args: SelectSubset<T, CampaignMessageFindUniqueArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignMessageFindUniqueOrThrowArgs} args - Arguments to find a CampaignMessage
     * @example
     * // Get one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageFindFirstArgs} args - Arguments to find a CampaignMessage
     * @example
     * // Get one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignMessageFindFirstArgs>(args?: SelectSubset<T, CampaignMessageFindFirstArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageFindFirstOrThrowArgs} args - Arguments to find a CampaignMessage
     * @example
     * // Get one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignMessages
     * const campaignMessages = await prisma.campaignMessage.findMany()
     * 
     * // Get first 10 CampaignMessages
     * const campaignMessages = await prisma.campaignMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignMessageWithIdOnly = await prisma.campaignMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignMessageFindManyArgs>(args?: SelectSubset<T, CampaignMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignMessage.
     * @param {CampaignMessageCreateArgs} args - Arguments to create a CampaignMessage.
     * @example
     * // Create one CampaignMessage
     * const CampaignMessage = await prisma.campaignMessage.create({
     *   data: {
     *     // ... data to create a CampaignMessage
     *   }
     * })
     * 
     */
    create<T extends CampaignMessageCreateArgs>(args: SelectSubset<T, CampaignMessageCreateArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignMessages.
     * @param {CampaignMessageCreateManyArgs} args - Arguments to create many CampaignMessages.
     * @example
     * // Create many CampaignMessages
     * const campaignMessage = await prisma.campaignMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignMessageCreateManyArgs>(args?: SelectSubset<T, CampaignMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignMessages and returns the data saved in the database.
     * @param {CampaignMessageCreateManyAndReturnArgs} args - Arguments to create many CampaignMessages.
     * @example
     * // Create many CampaignMessages
     * const campaignMessage = await prisma.campaignMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignMessages and only return the `id`
     * const campaignMessageWithIdOnly = await prisma.campaignMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignMessage.
     * @param {CampaignMessageDeleteArgs} args - Arguments to delete one CampaignMessage.
     * @example
     * // Delete one CampaignMessage
     * const CampaignMessage = await prisma.campaignMessage.delete({
     *   where: {
     *     // ... filter to delete one CampaignMessage
     *   }
     * })
     * 
     */
    delete<T extends CampaignMessageDeleteArgs>(args: SelectSubset<T, CampaignMessageDeleteArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignMessage.
     * @param {CampaignMessageUpdateArgs} args - Arguments to update one CampaignMessage.
     * @example
     * // Update one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignMessageUpdateArgs>(args: SelectSubset<T, CampaignMessageUpdateArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignMessages.
     * @param {CampaignMessageDeleteManyArgs} args - Arguments to filter CampaignMessages to delete.
     * @example
     * // Delete a few CampaignMessages
     * const { count } = await prisma.campaignMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignMessageDeleteManyArgs>(args?: SelectSubset<T, CampaignMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignMessages
     * const campaignMessage = await prisma.campaignMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignMessageUpdateManyArgs>(args: SelectSubset<T, CampaignMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignMessage.
     * @param {CampaignMessageUpsertArgs} args - Arguments to update or create a CampaignMessage.
     * @example
     * // Update or create a CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.upsert({
     *   create: {
     *     // ... data to create a CampaignMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignMessage we want to update
     *   }
     * })
     */
    upsert<T extends CampaignMessageUpsertArgs>(args: SelectSubset<T, CampaignMessageUpsertArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageCountArgs} args - Arguments to filter CampaignMessages to count.
     * @example
     * // Count the number of CampaignMessages
     * const count = await prisma.campaignMessage.count({
     *   where: {
     *     // ... the filter for the CampaignMessages we want to count
     *   }
     * })
    **/
    count<T extends CampaignMessageCountArgs>(
      args?: Subset<T, CampaignMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignMessageAggregateArgs>(args: Subset<T, CampaignMessageAggregateArgs>): Prisma.PrismaPromise<GetCampaignMessageAggregateType<T>>

    /**
     * Group by CampaignMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignMessageGroupByArgs['orderBy'] }
        : { orderBy?: CampaignMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignMessage model
   */
  readonly fields: CampaignMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignMessage model
   */ 
  interface CampaignMessageFieldRefs {
    readonly id: FieldRef<"CampaignMessage", 'String'>
    readonly campaignId: FieldRef<"CampaignMessage", 'String'>
    readonly type: FieldRef<"CampaignMessage", 'String'>
    readonly content: FieldRef<"CampaignMessage", 'String'>
    readonly order: FieldRef<"CampaignMessage", 'Int'>
    readonly caption: FieldRef<"CampaignMessage", 'String'>
    readonly createdAt: FieldRef<"CampaignMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignMessage findUnique
   */
  export type CampaignMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessage to fetch.
     */
    where: CampaignMessageWhereUniqueInput
  }

  /**
   * CampaignMessage findUniqueOrThrow
   */
  export type CampaignMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessage to fetch.
     */
    where: CampaignMessageWhereUniqueInput
  }

  /**
   * CampaignMessage findFirst
   */
  export type CampaignMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessage to fetch.
     */
    where?: CampaignMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMessages to fetch.
     */
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMessages.
     */
    cursor?: CampaignMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMessages.
     */
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * CampaignMessage findFirstOrThrow
   */
  export type CampaignMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessage to fetch.
     */
    where?: CampaignMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMessages to fetch.
     */
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMessages.
     */
    cursor?: CampaignMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMessages.
     */
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * CampaignMessage findMany
   */
  export type CampaignMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessages to fetch.
     */
    where?: CampaignMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMessages to fetch.
     */
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignMessages.
     */
    cursor?: CampaignMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMessages.
     */
    skip?: number
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * CampaignMessage create
   */
  export type CampaignMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignMessage.
     */
    data: XOR<CampaignMessageCreateInput, CampaignMessageUncheckedCreateInput>
  }

  /**
   * CampaignMessage createMany
   */
  export type CampaignMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignMessages.
     */
    data: CampaignMessageCreateManyInput | CampaignMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignMessage createManyAndReturn
   */
  export type CampaignMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignMessages.
     */
    data: CampaignMessageCreateManyInput | CampaignMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignMessage update
   */
  export type CampaignMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignMessage.
     */
    data: XOR<CampaignMessageUpdateInput, CampaignMessageUncheckedUpdateInput>
    /**
     * Choose, which CampaignMessage to update.
     */
    where: CampaignMessageWhereUniqueInput
  }

  /**
   * CampaignMessage updateMany
   */
  export type CampaignMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignMessages.
     */
    data: XOR<CampaignMessageUpdateManyMutationInput, CampaignMessageUncheckedUpdateManyInput>
    /**
     * Filter which CampaignMessages to update
     */
    where?: CampaignMessageWhereInput
  }

  /**
   * CampaignMessage upsert
   */
  export type CampaignMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignMessage to update in case it exists.
     */
    where: CampaignMessageWhereUniqueInput
    /**
     * In case the CampaignMessage found by the `where` argument doesn't exist, create a new CampaignMessage with this data.
     */
    create: XOR<CampaignMessageCreateInput, CampaignMessageUncheckedCreateInput>
    /**
     * In case the CampaignMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignMessageUpdateInput, CampaignMessageUncheckedUpdateInput>
  }

  /**
   * CampaignMessage delete
   */
  export type CampaignMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter which CampaignMessage to delete.
     */
    where: CampaignMessageWhereUniqueInput
  }

  /**
   * CampaignMessage deleteMany
   */
  export type CampaignMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMessages to delete
     */
    where?: CampaignMessageWhereInput
  }

  /**
   * CampaignMessage without action
   */
  export type CampaignMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
  }


  /**
   * Model CampaignLead
   */

  export type AggregateCampaignLead = {
    _count: CampaignLeadCountAggregateOutputType | null
    _min: CampaignLeadMinAggregateOutputType | null
    _max: CampaignLeadMaxAggregateOutputType | null
  }

  export type CampaignLeadMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    name: string | null
    phone: string | null
    status: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    messageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignLeadMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    name: string | null
    phone: string | null
    status: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    messageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignLeadCountAggregateOutputType = {
    id: number
    campaignId: number
    name: number
    phone: number
    status: number
    sentAt: number
    deliveredAt: number
    readAt: number
    failedAt: number
    failureReason: number
    messageId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignLeadMinAggregateInputType = {
    id?: true
    campaignId?: true
    name?: true
    phone?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    failedAt?: true
    failureReason?: true
    messageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignLeadMaxAggregateInputType = {
    id?: true
    campaignId?: true
    name?: true
    phone?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    failedAt?: true
    failureReason?: true
    messageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignLeadCountAggregateInputType = {
    id?: true
    campaignId?: true
    name?: true
    phone?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    failedAt?: true
    failureReason?: true
    messageId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignLeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignLead to aggregate.
     */
    where?: CampaignLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLeads to fetch.
     */
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignLeads
    **/
    _count?: true | CampaignLeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignLeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignLeadMaxAggregateInputType
  }

  export type GetCampaignLeadAggregateType<T extends CampaignLeadAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignLead[P]>
      : GetScalarType<T[P], AggregateCampaignLead[P]>
  }




  export type CampaignLeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLeadWhereInput
    orderBy?: CampaignLeadOrderByWithAggregationInput | CampaignLeadOrderByWithAggregationInput[]
    by: CampaignLeadScalarFieldEnum[] | CampaignLeadScalarFieldEnum
    having?: CampaignLeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignLeadCountAggregateInputType | true
    _min?: CampaignLeadMinAggregateInputType
    _max?: CampaignLeadMaxAggregateInputType
  }

  export type CampaignLeadGroupByOutputType = {
    id: string
    campaignId: string
    name: string | null
    phone: string
    status: string
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    messageId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignLeadCountAggregateOutputType | null
    _min: CampaignLeadMinAggregateOutputType | null
    _max: CampaignLeadMaxAggregateOutputType | null
  }

  type GetCampaignLeadGroupByPayload<T extends CampaignLeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignLeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignLeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignLeadGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignLeadGroupByOutputType[P]>
        }
      >
    >


  export type CampaignLeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    messageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messageLogs?: boolean | CampaignLead$messageLogsArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    _count?: boolean | CampaignLeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignLead"]>

  export type CampaignLeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    messageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignLead"]>

  export type CampaignLeadSelectScalar = {
    id?: boolean
    campaignId?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    messageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignLeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messageLogs?: boolean | CampaignLead$messageLogsArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    _count?: boolean | CampaignLeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignLeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignLeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignLead"
    objects: {
      messageLogs: Prisma.$MessageLogPayload<ExtArgs>[]
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      name: string | null
      phone: string
      status: string
      sentAt: Date | null
      deliveredAt: Date | null
      readAt: Date | null
      failedAt: Date | null
      failureReason: string | null
      messageId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignLead"]>
    composites: {}
  }

  type CampaignLeadGetPayload<S extends boolean | null | undefined | CampaignLeadDefaultArgs> = $Result.GetResult<Prisma.$CampaignLeadPayload, S>

  type CampaignLeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignLeadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignLeadCountAggregateInputType | true
    }

  export interface CampaignLeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignLead'], meta: { name: 'CampaignLead' } }
    /**
     * Find zero or one CampaignLead that matches the filter.
     * @param {CampaignLeadFindUniqueArgs} args - Arguments to find a CampaignLead
     * @example
     * // Get one CampaignLead
     * const campaignLead = await prisma.campaignLead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignLeadFindUniqueArgs>(args: SelectSubset<T, CampaignLeadFindUniqueArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignLead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignLeadFindUniqueOrThrowArgs} args - Arguments to find a CampaignLead
     * @example
     * // Get one CampaignLead
     * const campaignLead = await prisma.campaignLead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignLeadFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignLeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignLead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadFindFirstArgs} args - Arguments to find a CampaignLead
     * @example
     * // Get one CampaignLead
     * const campaignLead = await prisma.campaignLead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignLeadFindFirstArgs>(args?: SelectSubset<T, CampaignLeadFindFirstArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignLead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadFindFirstOrThrowArgs} args - Arguments to find a CampaignLead
     * @example
     * // Get one CampaignLead
     * const campaignLead = await prisma.campaignLead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignLeadFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignLeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignLeads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignLeads
     * const campaignLeads = await prisma.campaignLead.findMany()
     * 
     * // Get first 10 CampaignLeads
     * const campaignLeads = await prisma.campaignLead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignLeadWithIdOnly = await prisma.campaignLead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignLeadFindManyArgs>(args?: SelectSubset<T, CampaignLeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignLead.
     * @param {CampaignLeadCreateArgs} args - Arguments to create a CampaignLead.
     * @example
     * // Create one CampaignLead
     * const CampaignLead = await prisma.campaignLead.create({
     *   data: {
     *     // ... data to create a CampaignLead
     *   }
     * })
     * 
     */
    create<T extends CampaignLeadCreateArgs>(args: SelectSubset<T, CampaignLeadCreateArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignLeads.
     * @param {CampaignLeadCreateManyArgs} args - Arguments to create many CampaignLeads.
     * @example
     * // Create many CampaignLeads
     * const campaignLead = await prisma.campaignLead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignLeadCreateManyArgs>(args?: SelectSubset<T, CampaignLeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignLeads and returns the data saved in the database.
     * @param {CampaignLeadCreateManyAndReturnArgs} args - Arguments to create many CampaignLeads.
     * @example
     * // Create many CampaignLeads
     * const campaignLead = await prisma.campaignLead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignLeads and only return the `id`
     * const campaignLeadWithIdOnly = await prisma.campaignLead.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignLeadCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignLeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignLead.
     * @param {CampaignLeadDeleteArgs} args - Arguments to delete one CampaignLead.
     * @example
     * // Delete one CampaignLead
     * const CampaignLead = await prisma.campaignLead.delete({
     *   where: {
     *     // ... filter to delete one CampaignLead
     *   }
     * })
     * 
     */
    delete<T extends CampaignLeadDeleteArgs>(args: SelectSubset<T, CampaignLeadDeleteArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignLead.
     * @param {CampaignLeadUpdateArgs} args - Arguments to update one CampaignLead.
     * @example
     * // Update one CampaignLead
     * const campaignLead = await prisma.campaignLead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignLeadUpdateArgs>(args: SelectSubset<T, CampaignLeadUpdateArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignLeads.
     * @param {CampaignLeadDeleteManyArgs} args - Arguments to filter CampaignLeads to delete.
     * @example
     * // Delete a few CampaignLeads
     * const { count } = await prisma.campaignLead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignLeadDeleteManyArgs>(args?: SelectSubset<T, CampaignLeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignLeads
     * const campaignLead = await prisma.campaignLead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignLeadUpdateManyArgs>(args: SelectSubset<T, CampaignLeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignLead.
     * @param {CampaignLeadUpsertArgs} args - Arguments to update or create a CampaignLead.
     * @example
     * // Update or create a CampaignLead
     * const campaignLead = await prisma.campaignLead.upsert({
     *   create: {
     *     // ... data to create a CampaignLead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignLead we want to update
     *   }
     * })
     */
    upsert<T extends CampaignLeadUpsertArgs>(args: SelectSubset<T, CampaignLeadUpsertArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadCountArgs} args - Arguments to filter CampaignLeads to count.
     * @example
     * // Count the number of CampaignLeads
     * const count = await prisma.campaignLead.count({
     *   where: {
     *     // ... the filter for the CampaignLeads we want to count
     *   }
     * })
    **/
    count<T extends CampaignLeadCountArgs>(
      args?: Subset<T, CampaignLeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignLeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignLeadAggregateArgs>(args: Subset<T, CampaignLeadAggregateArgs>): Prisma.PrismaPromise<GetCampaignLeadAggregateType<T>>

    /**
     * Group by CampaignLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignLeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignLeadGroupByArgs['orderBy'] }
        : { orderBy?: CampaignLeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignLeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignLead model
   */
  readonly fields: CampaignLeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignLead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignLeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messageLogs<T extends CampaignLead$messageLogsArgs<ExtArgs> = {}>(args?: Subset<T, CampaignLead$messageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findMany"> | Null>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignLead model
   */ 
  interface CampaignLeadFieldRefs {
    readonly id: FieldRef<"CampaignLead", 'String'>
    readonly campaignId: FieldRef<"CampaignLead", 'String'>
    readonly name: FieldRef<"CampaignLead", 'String'>
    readonly phone: FieldRef<"CampaignLead", 'String'>
    readonly status: FieldRef<"CampaignLead", 'String'>
    readonly sentAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly deliveredAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly readAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly failedAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly failureReason: FieldRef<"CampaignLead", 'String'>
    readonly messageId: FieldRef<"CampaignLead", 'String'>
    readonly createdAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignLead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignLead findUnique
   */
  export type CampaignLeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLead to fetch.
     */
    where: CampaignLeadWhereUniqueInput
  }

  /**
   * CampaignLead findUniqueOrThrow
   */
  export type CampaignLeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLead to fetch.
     */
    where: CampaignLeadWhereUniqueInput
  }

  /**
   * CampaignLead findFirst
   */
  export type CampaignLeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLead to fetch.
     */
    where?: CampaignLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLeads to fetch.
     */
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignLeads.
     */
    cursor?: CampaignLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignLeads.
     */
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }

  /**
   * CampaignLead findFirstOrThrow
   */
  export type CampaignLeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLead to fetch.
     */
    where?: CampaignLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLeads to fetch.
     */
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignLeads.
     */
    cursor?: CampaignLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignLeads.
     */
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }

  /**
   * CampaignLead findMany
   */
  export type CampaignLeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLeads to fetch.
     */
    where?: CampaignLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLeads to fetch.
     */
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignLeads.
     */
    cursor?: CampaignLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLeads.
     */
    skip?: number
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }

  /**
   * CampaignLead create
   */
  export type CampaignLeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignLead.
     */
    data: XOR<CampaignLeadCreateInput, CampaignLeadUncheckedCreateInput>
  }

  /**
   * CampaignLead createMany
   */
  export type CampaignLeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignLeads.
     */
    data: CampaignLeadCreateManyInput | CampaignLeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignLead createManyAndReturn
   */
  export type CampaignLeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignLeads.
     */
    data: CampaignLeadCreateManyInput | CampaignLeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignLead update
   */
  export type CampaignLeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignLead.
     */
    data: XOR<CampaignLeadUpdateInput, CampaignLeadUncheckedUpdateInput>
    /**
     * Choose, which CampaignLead to update.
     */
    where: CampaignLeadWhereUniqueInput
  }

  /**
   * CampaignLead updateMany
   */
  export type CampaignLeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignLeads.
     */
    data: XOR<CampaignLeadUpdateManyMutationInput, CampaignLeadUncheckedUpdateManyInput>
    /**
     * Filter which CampaignLeads to update
     */
    where?: CampaignLeadWhereInput
  }

  /**
   * CampaignLead upsert
   */
  export type CampaignLeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignLead to update in case it exists.
     */
    where: CampaignLeadWhereUniqueInput
    /**
     * In case the CampaignLead found by the `where` argument doesn't exist, create a new CampaignLead with this data.
     */
    create: XOR<CampaignLeadCreateInput, CampaignLeadUncheckedCreateInput>
    /**
     * In case the CampaignLead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignLeadUpdateInput, CampaignLeadUncheckedUpdateInput>
  }

  /**
   * CampaignLead delete
   */
  export type CampaignLeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter which CampaignLead to delete.
     */
    where: CampaignLeadWhereUniqueInput
  }

  /**
   * CampaignLead deleteMany
   */
  export type CampaignLeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignLeads to delete
     */
    where?: CampaignLeadWhereInput
  }

  /**
   * CampaignLead.messageLogs
   */
  export type CampaignLead$messageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    where?: MessageLogWhereInput
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    cursor?: MessageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageLogScalarFieldEnum | MessageLogScalarFieldEnum[]
  }

  /**
   * CampaignLead without action
   */
  export type CampaignLeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
  }


  /**
   * Model CampaignStatistics
   */

  export type AggregateCampaignStatistics = {
    _count: CampaignStatisticsCountAggregateOutputType | null
    _avg: CampaignStatisticsAvgAggregateOutputType | null
    _sum: CampaignStatisticsSumAggregateOutputType | null
    _min: CampaignStatisticsMinAggregateOutputType | null
    _max: CampaignStatisticsMaxAggregateOutputType | null
  }

  export type CampaignStatisticsAvgAggregateOutputType = {
    totalLeads: number | null
    sentCount: number | null
    deliveredCount: number | null
    readCount: number | null
    failedCount: number | null
  }

  export type CampaignStatisticsSumAggregateOutputType = {
    totalLeads: number | null
    sentCount: number | null
    deliveredCount: number | null
    readCount: number | null
    failedCount: number | null
  }

  export type CampaignStatisticsMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    totalLeads: number | null
    sentCount: number | null
    deliveredCount: number | null
    readCount: number | null
    failedCount: number | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignStatisticsMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    totalLeads: number | null
    sentCount: number | null
    deliveredCount: number | null
    readCount: number | null
    failedCount: number | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignStatisticsCountAggregateOutputType = {
    id: number
    campaignId: number
    totalLeads: number
    sentCount: number
    deliveredCount: number
    readCount: number
    failedCount: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignStatisticsAvgAggregateInputType = {
    totalLeads?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    failedCount?: true
  }

  export type CampaignStatisticsSumAggregateInputType = {
    totalLeads?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    failedCount?: true
  }

  export type CampaignStatisticsMinAggregateInputType = {
    id?: true
    campaignId?: true
    totalLeads?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    failedCount?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignStatisticsMaxAggregateInputType = {
    id?: true
    campaignId?: true
    totalLeads?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    failedCount?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignStatisticsCountAggregateInputType = {
    id?: true
    campaignId?: true
    totalLeads?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    failedCount?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignStatisticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignStatistics to aggregate.
     */
    where?: CampaignStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignStatistics to fetch.
     */
    orderBy?: CampaignStatisticsOrderByWithRelationInput | CampaignStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignStatistics
    **/
    _count?: true | CampaignStatisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignStatisticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignStatisticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignStatisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignStatisticsMaxAggregateInputType
  }

  export type GetCampaignStatisticsAggregateType<T extends CampaignStatisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignStatistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignStatistics[P]>
      : GetScalarType<T[P], AggregateCampaignStatistics[P]>
  }




  export type CampaignStatisticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignStatisticsWhereInput
    orderBy?: CampaignStatisticsOrderByWithAggregationInput | CampaignStatisticsOrderByWithAggregationInput[]
    by: CampaignStatisticsScalarFieldEnum[] | CampaignStatisticsScalarFieldEnum
    having?: CampaignStatisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignStatisticsCountAggregateInputType | true
    _avg?: CampaignStatisticsAvgAggregateInputType
    _sum?: CampaignStatisticsSumAggregateInputType
    _min?: CampaignStatisticsMinAggregateInputType
    _max?: CampaignStatisticsMaxAggregateInputType
  }

  export type CampaignStatisticsGroupByOutputType = {
    id: string
    campaignId: string
    totalLeads: number
    sentCount: number
    deliveredCount: number
    readCount: number
    failedCount: number
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignStatisticsCountAggregateOutputType | null
    _avg: CampaignStatisticsAvgAggregateOutputType | null
    _sum: CampaignStatisticsSumAggregateOutputType | null
    _min: CampaignStatisticsMinAggregateOutputType | null
    _max: CampaignStatisticsMaxAggregateOutputType | null
  }

  type GetCampaignStatisticsGroupByPayload<T extends CampaignStatisticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignStatisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignStatisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignStatisticsGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignStatisticsGroupByOutputType[P]>
        }
      >
    >


  export type CampaignStatisticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    totalLeads?: boolean
    sentCount?: boolean
    deliveredCount?: boolean
    readCount?: boolean
    failedCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignStatistics"]>

  export type CampaignStatisticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    totalLeads?: boolean
    sentCount?: boolean
    deliveredCount?: boolean
    readCount?: boolean
    failedCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignStatistics"]>

  export type CampaignStatisticsSelectScalar = {
    id?: boolean
    campaignId?: boolean
    totalLeads?: boolean
    sentCount?: boolean
    deliveredCount?: boolean
    readCount?: boolean
    failedCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignStatisticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignStatisticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignStatisticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignStatistics"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      totalLeads: number
      sentCount: number
      deliveredCount: number
      readCount: number
      failedCount: number
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignStatistics"]>
    composites: {}
  }

  type CampaignStatisticsGetPayload<S extends boolean | null | undefined | CampaignStatisticsDefaultArgs> = $Result.GetResult<Prisma.$CampaignStatisticsPayload, S>

  type CampaignStatisticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignStatisticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignStatisticsCountAggregateInputType | true
    }

  export interface CampaignStatisticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignStatistics'], meta: { name: 'CampaignStatistics' } }
    /**
     * Find zero or one CampaignStatistics that matches the filter.
     * @param {CampaignStatisticsFindUniqueArgs} args - Arguments to find a CampaignStatistics
     * @example
     * // Get one CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignStatisticsFindUniqueArgs>(args: SelectSubset<T, CampaignStatisticsFindUniqueArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignStatistics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignStatisticsFindUniqueOrThrowArgs} args - Arguments to find a CampaignStatistics
     * @example
     * // Get one CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignStatisticsFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignStatisticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsFindFirstArgs} args - Arguments to find a CampaignStatistics
     * @example
     * // Get one CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignStatisticsFindFirstArgs>(args?: SelectSubset<T, CampaignStatisticsFindFirstArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignStatistics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsFindFirstOrThrowArgs} args - Arguments to find a CampaignStatistics
     * @example
     * // Get one CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignStatisticsFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignStatisticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.findMany()
     * 
     * // Get first 10 CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignStatisticsWithIdOnly = await prisma.campaignStatistics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignStatisticsFindManyArgs>(args?: SelectSubset<T, CampaignStatisticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignStatistics.
     * @param {CampaignStatisticsCreateArgs} args - Arguments to create a CampaignStatistics.
     * @example
     * // Create one CampaignStatistics
     * const CampaignStatistics = await prisma.campaignStatistics.create({
     *   data: {
     *     // ... data to create a CampaignStatistics
     *   }
     * })
     * 
     */
    create<T extends CampaignStatisticsCreateArgs>(args: SelectSubset<T, CampaignStatisticsCreateArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignStatistics.
     * @param {CampaignStatisticsCreateManyArgs} args - Arguments to create many CampaignStatistics.
     * @example
     * // Create many CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignStatisticsCreateManyArgs>(args?: SelectSubset<T, CampaignStatisticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignStatistics and returns the data saved in the database.
     * @param {CampaignStatisticsCreateManyAndReturnArgs} args - Arguments to create many CampaignStatistics.
     * @example
     * // Create many CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignStatistics and only return the `id`
     * const campaignStatisticsWithIdOnly = await prisma.campaignStatistics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignStatisticsCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignStatisticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignStatistics.
     * @param {CampaignStatisticsDeleteArgs} args - Arguments to delete one CampaignStatistics.
     * @example
     * // Delete one CampaignStatistics
     * const CampaignStatistics = await prisma.campaignStatistics.delete({
     *   where: {
     *     // ... filter to delete one CampaignStatistics
     *   }
     * })
     * 
     */
    delete<T extends CampaignStatisticsDeleteArgs>(args: SelectSubset<T, CampaignStatisticsDeleteArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignStatistics.
     * @param {CampaignStatisticsUpdateArgs} args - Arguments to update one CampaignStatistics.
     * @example
     * // Update one CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignStatisticsUpdateArgs>(args: SelectSubset<T, CampaignStatisticsUpdateArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignStatistics.
     * @param {CampaignStatisticsDeleteManyArgs} args - Arguments to filter CampaignStatistics to delete.
     * @example
     * // Delete a few CampaignStatistics
     * const { count } = await prisma.campaignStatistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignStatisticsDeleteManyArgs>(args?: SelectSubset<T, CampaignStatisticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignStatisticsUpdateManyArgs>(args: SelectSubset<T, CampaignStatisticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignStatistics.
     * @param {CampaignStatisticsUpsertArgs} args - Arguments to update or create a CampaignStatistics.
     * @example
     * // Update or create a CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.upsert({
     *   create: {
     *     // ... data to create a CampaignStatistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignStatistics we want to update
     *   }
     * })
     */
    upsert<T extends CampaignStatisticsUpsertArgs>(args: SelectSubset<T, CampaignStatisticsUpsertArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsCountArgs} args - Arguments to filter CampaignStatistics to count.
     * @example
     * // Count the number of CampaignStatistics
     * const count = await prisma.campaignStatistics.count({
     *   where: {
     *     // ... the filter for the CampaignStatistics we want to count
     *   }
     * })
    **/
    count<T extends CampaignStatisticsCountArgs>(
      args?: Subset<T, CampaignStatisticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignStatisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignStatisticsAggregateArgs>(args: Subset<T, CampaignStatisticsAggregateArgs>): Prisma.PrismaPromise<GetCampaignStatisticsAggregateType<T>>

    /**
     * Group by CampaignStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignStatisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignStatisticsGroupByArgs['orderBy'] }
        : { orderBy?: CampaignStatisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignStatisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignStatisticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignStatistics model
   */
  readonly fields: CampaignStatisticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignStatistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignStatisticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignStatistics model
   */ 
  interface CampaignStatisticsFieldRefs {
    readonly id: FieldRef<"CampaignStatistics", 'String'>
    readonly campaignId: FieldRef<"CampaignStatistics", 'String'>
    readonly totalLeads: FieldRef<"CampaignStatistics", 'Int'>
    readonly sentCount: FieldRef<"CampaignStatistics", 'Int'>
    readonly deliveredCount: FieldRef<"CampaignStatistics", 'Int'>
    readonly readCount: FieldRef<"CampaignStatistics", 'Int'>
    readonly failedCount: FieldRef<"CampaignStatistics", 'Int'>
    readonly startedAt: FieldRef<"CampaignStatistics", 'DateTime'>
    readonly completedAt: FieldRef<"CampaignStatistics", 'DateTime'>
    readonly createdAt: FieldRef<"CampaignStatistics", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignStatistics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignStatistics findUnique
   */
  export type CampaignStatisticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatistics to fetch.
     */
    where: CampaignStatisticsWhereUniqueInput
  }

  /**
   * CampaignStatistics findUniqueOrThrow
   */
  export type CampaignStatisticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatistics to fetch.
     */
    where: CampaignStatisticsWhereUniqueInput
  }

  /**
   * CampaignStatistics findFirst
   */
  export type CampaignStatisticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatistics to fetch.
     */
    where?: CampaignStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignStatistics to fetch.
     */
    orderBy?: CampaignStatisticsOrderByWithRelationInput | CampaignStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignStatistics.
     */
    cursor?: CampaignStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignStatistics.
     */
    distinct?: CampaignStatisticsScalarFieldEnum | CampaignStatisticsScalarFieldEnum[]
  }

  /**
   * CampaignStatistics findFirstOrThrow
   */
  export type CampaignStatisticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatistics to fetch.
     */
    where?: CampaignStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignStatistics to fetch.
     */
    orderBy?: CampaignStatisticsOrderByWithRelationInput | CampaignStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignStatistics.
     */
    cursor?: CampaignStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignStatistics.
     */
    distinct?: CampaignStatisticsScalarFieldEnum | CampaignStatisticsScalarFieldEnum[]
  }

  /**
   * CampaignStatistics findMany
   */
  export type CampaignStatisticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatistics to fetch.
     */
    where?: CampaignStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignStatistics to fetch.
     */
    orderBy?: CampaignStatisticsOrderByWithRelationInput | CampaignStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignStatistics.
     */
    cursor?: CampaignStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignStatistics.
     */
    skip?: number
    distinct?: CampaignStatisticsScalarFieldEnum | CampaignStatisticsScalarFieldEnum[]
  }

  /**
   * CampaignStatistics create
   */
  export type CampaignStatisticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignStatistics.
     */
    data: XOR<CampaignStatisticsCreateInput, CampaignStatisticsUncheckedCreateInput>
  }

  /**
   * CampaignStatistics createMany
   */
  export type CampaignStatisticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignStatistics.
     */
    data: CampaignStatisticsCreateManyInput | CampaignStatisticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignStatistics createManyAndReturn
   */
  export type CampaignStatisticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignStatistics.
     */
    data: CampaignStatisticsCreateManyInput | CampaignStatisticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignStatistics update
   */
  export type CampaignStatisticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignStatistics.
     */
    data: XOR<CampaignStatisticsUpdateInput, CampaignStatisticsUncheckedUpdateInput>
    /**
     * Choose, which CampaignStatistics to update.
     */
    where: CampaignStatisticsWhereUniqueInput
  }

  /**
   * CampaignStatistics updateMany
   */
  export type CampaignStatisticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignStatistics.
     */
    data: XOR<CampaignStatisticsUpdateManyMutationInput, CampaignStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which CampaignStatistics to update
     */
    where?: CampaignStatisticsWhereInput
  }

  /**
   * CampaignStatistics upsert
   */
  export type CampaignStatisticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignStatistics to update in case it exists.
     */
    where: CampaignStatisticsWhereUniqueInput
    /**
     * In case the CampaignStatistics found by the `where` argument doesn't exist, create a new CampaignStatistics with this data.
     */
    create: XOR<CampaignStatisticsCreateInput, CampaignStatisticsUncheckedCreateInput>
    /**
     * In case the CampaignStatistics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignStatisticsUpdateInput, CampaignStatisticsUncheckedUpdateInput>
  }

  /**
   * CampaignStatistics delete
   */
  export type CampaignStatisticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * Filter which CampaignStatistics to delete.
     */
    where: CampaignStatisticsWhereUniqueInput
  }

  /**
   * CampaignStatistics deleteMany
   */
  export type CampaignStatisticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignStatistics to delete
     */
    where?: CampaignStatisticsWhereInput
  }

  /**
   * CampaignStatistics without action
   */
  export type CampaignStatisticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
  }


  /**
   * Model MessageLog
   */

  export type AggregateMessageLog = {
    _count: MessageLogCountAggregateOutputType | null
    _min: MessageLogMinAggregateOutputType | null
    _max: MessageLogMaxAggregateOutputType | null
  }

  export type MessageLogMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    leadId: string | null
    messageId: string | null
    messageDate: Date | null
    messageType: string | null
    content: string | null
    status: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageLogMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    leadId: string | null
    messageId: string | null
    messageDate: Date | null
    messageType: string | null
    content: string | null
    status: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageLogCountAggregateOutputType = {
    id: number
    campaignId: number
    leadId: number
    messageId: number
    messageDate: number
    messageType: number
    content: number
    status: number
    statusHistory: number
    sentAt: number
    deliveredAt: number
    readAt: number
    failedAt: number
    failureReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageLogMinAggregateInputType = {
    id?: true
    campaignId?: true
    leadId?: true
    messageId?: true
    messageDate?: true
    messageType?: true
    content?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    failedAt?: true
    failureReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageLogMaxAggregateInputType = {
    id?: true
    campaignId?: true
    leadId?: true
    messageId?: true
    messageDate?: true
    messageType?: true
    content?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    failedAt?: true
    failureReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageLogCountAggregateInputType = {
    id?: true
    campaignId?: true
    leadId?: true
    messageId?: true
    messageDate?: true
    messageType?: true
    content?: true
    status?: true
    statusHistory?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    failedAt?: true
    failureReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageLog to aggregate.
     */
    where?: MessageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLogs to fetch.
     */
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageLogs
    **/
    _count?: true | MessageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageLogMaxAggregateInputType
  }

  export type GetMessageLogAggregateType<T extends MessageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageLog[P]>
      : GetScalarType<T[P], AggregateMessageLog[P]>
  }




  export type MessageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLogWhereInput
    orderBy?: MessageLogOrderByWithAggregationInput | MessageLogOrderByWithAggregationInput[]
    by: MessageLogScalarFieldEnum[] | MessageLogScalarFieldEnum
    having?: MessageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageLogCountAggregateInputType | true
    _min?: MessageLogMinAggregateInputType
    _max?: MessageLogMaxAggregateInputType
  }

  export type MessageLogGroupByOutputType = {
    id: string
    campaignId: string
    leadId: string
    messageId: string
    messageDate: Date
    messageType: string
    content: string
    status: string
    statusHistory: JsonValue[]
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: MessageLogCountAggregateOutputType | null
    _min: MessageLogMinAggregateOutputType | null
    _max: MessageLogMaxAggregateOutputType | null
  }

  type GetMessageLogGroupByPayload<T extends MessageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageLogGroupByOutputType[P]>
            : GetScalarType<T[P], MessageLogGroupByOutputType[P]>
        }
      >
    >


  export type MessageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    leadId?: boolean
    messageId?: boolean
    messageDate?: boolean
    messageType?: boolean
    content?: boolean
    status?: boolean
    statusHistory?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    CampaignLead?: boolean | MessageLog$CampaignLeadArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    _count?: boolean | MessageLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageLog"]>

  export type MessageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    leadId?: boolean
    messageId?: boolean
    messageDate?: boolean
    messageType?: boolean
    content?: boolean
    status?: boolean
    statusHistory?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageLog"]>

  export type MessageLogSelectScalar = {
    id?: boolean
    campaignId?: boolean
    leadId?: boolean
    messageId?: boolean
    messageDate?: boolean
    messageType?: boolean
    content?: boolean
    status?: boolean
    statusHistory?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    CampaignLead?: boolean | MessageLog$CampaignLeadArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    _count?: boolean | MessageLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    lead?: boolean | LeadDefaultArgs<ExtArgs>
  }

  export type $MessageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageLog"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      CampaignLead: Prisma.$CampaignLeadPayload<ExtArgs>[]
      lead: Prisma.$LeadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      leadId: string
      messageId: string
      messageDate: Date
      messageType: string
      content: string
      status: string
      statusHistory: Prisma.JsonValue[]
      sentAt: Date | null
      deliveredAt: Date | null
      readAt: Date | null
      failedAt: Date | null
      failureReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["messageLog"]>
    composites: {}
  }

  type MessageLogGetPayload<S extends boolean | null | undefined | MessageLogDefaultArgs> = $Result.GetResult<Prisma.$MessageLogPayload, S>

  type MessageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageLogCountAggregateInputType | true
    }

  export interface MessageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageLog'], meta: { name: 'MessageLog' } }
    /**
     * Find zero or one MessageLog that matches the filter.
     * @param {MessageLogFindUniqueArgs} args - Arguments to find a MessageLog
     * @example
     * // Get one MessageLog
     * const messageLog = await prisma.messageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageLogFindUniqueArgs>(args: SelectSubset<T, MessageLogFindUniqueArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageLogFindUniqueOrThrowArgs} args - Arguments to find a MessageLog
     * @example
     * // Get one MessageLog
     * const messageLog = await prisma.messageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogFindFirstArgs} args - Arguments to find a MessageLog
     * @example
     * // Get one MessageLog
     * const messageLog = await prisma.messageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageLogFindFirstArgs>(args?: SelectSubset<T, MessageLogFindFirstArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogFindFirstOrThrowArgs} args - Arguments to find a MessageLog
     * @example
     * // Get one MessageLog
     * const messageLog = await prisma.messageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageLogs
     * const messageLogs = await prisma.messageLog.findMany()
     * 
     * // Get first 10 MessageLogs
     * const messageLogs = await prisma.messageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageLogWithIdOnly = await prisma.messageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageLogFindManyArgs>(args?: SelectSubset<T, MessageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageLog.
     * @param {MessageLogCreateArgs} args - Arguments to create a MessageLog.
     * @example
     * // Create one MessageLog
     * const MessageLog = await prisma.messageLog.create({
     *   data: {
     *     // ... data to create a MessageLog
     *   }
     * })
     * 
     */
    create<T extends MessageLogCreateArgs>(args: SelectSubset<T, MessageLogCreateArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageLogs.
     * @param {MessageLogCreateManyArgs} args - Arguments to create many MessageLogs.
     * @example
     * // Create many MessageLogs
     * const messageLog = await prisma.messageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageLogCreateManyArgs>(args?: SelectSubset<T, MessageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageLogs and returns the data saved in the database.
     * @param {MessageLogCreateManyAndReturnArgs} args - Arguments to create many MessageLogs.
     * @example
     * // Create many MessageLogs
     * const messageLog = await prisma.messageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageLogs and only return the `id`
     * const messageLogWithIdOnly = await prisma.messageLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageLog.
     * @param {MessageLogDeleteArgs} args - Arguments to delete one MessageLog.
     * @example
     * // Delete one MessageLog
     * const MessageLog = await prisma.messageLog.delete({
     *   where: {
     *     // ... filter to delete one MessageLog
     *   }
     * })
     * 
     */
    delete<T extends MessageLogDeleteArgs>(args: SelectSubset<T, MessageLogDeleteArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageLog.
     * @param {MessageLogUpdateArgs} args - Arguments to update one MessageLog.
     * @example
     * // Update one MessageLog
     * const messageLog = await prisma.messageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageLogUpdateArgs>(args: SelectSubset<T, MessageLogUpdateArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageLogs.
     * @param {MessageLogDeleteManyArgs} args - Arguments to filter MessageLogs to delete.
     * @example
     * // Delete a few MessageLogs
     * const { count } = await prisma.messageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageLogDeleteManyArgs>(args?: SelectSubset<T, MessageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageLogs
     * const messageLog = await prisma.messageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageLogUpdateManyArgs>(args: SelectSubset<T, MessageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageLog.
     * @param {MessageLogUpsertArgs} args - Arguments to update or create a MessageLog.
     * @example
     * // Update or create a MessageLog
     * const messageLog = await prisma.messageLog.upsert({
     *   create: {
     *     // ... data to create a MessageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageLog we want to update
     *   }
     * })
     */
    upsert<T extends MessageLogUpsertArgs>(args: SelectSubset<T, MessageLogUpsertArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogCountArgs} args - Arguments to filter MessageLogs to count.
     * @example
     * // Count the number of MessageLogs
     * const count = await prisma.messageLog.count({
     *   where: {
     *     // ... the filter for the MessageLogs we want to count
     *   }
     * })
    **/
    count<T extends MessageLogCountArgs>(
      args?: Subset<T, MessageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageLogAggregateArgs>(args: Subset<T, MessageLogAggregateArgs>): Prisma.PrismaPromise<GetMessageLogAggregateType<T>>

    /**
     * Group by MessageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageLogGroupByArgs['orderBy'] }
        : { orderBy?: MessageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageLog model
   */
  readonly fields: MessageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    CampaignLead<T extends MessageLog$CampaignLeadArgs<ExtArgs> = {}>(args?: Subset<T, MessageLog$CampaignLeadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findMany"> | Null>
    lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageLog model
   */ 
  interface MessageLogFieldRefs {
    readonly id: FieldRef<"MessageLog", 'String'>
    readonly campaignId: FieldRef<"MessageLog", 'String'>
    readonly leadId: FieldRef<"MessageLog", 'String'>
    readonly messageId: FieldRef<"MessageLog", 'String'>
    readonly messageDate: FieldRef<"MessageLog", 'DateTime'>
    readonly messageType: FieldRef<"MessageLog", 'String'>
    readonly content: FieldRef<"MessageLog", 'String'>
    readonly status: FieldRef<"MessageLog", 'String'>
    readonly statusHistory: FieldRef<"MessageLog", 'Json[]'>
    readonly sentAt: FieldRef<"MessageLog", 'DateTime'>
    readonly deliveredAt: FieldRef<"MessageLog", 'DateTime'>
    readonly readAt: FieldRef<"MessageLog", 'DateTime'>
    readonly failedAt: FieldRef<"MessageLog", 'DateTime'>
    readonly failureReason: FieldRef<"MessageLog", 'String'>
    readonly createdAt: FieldRef<"MessageLog", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageLog findUnique
   */
  export type MessageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * Filter, which MessageLog to fetch.
     */
    where: MessageLogWhereUniqueInput
  }

  /**
   * MessageLog findUniqueOrThrow
   */
  export type MessageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * Filter, which MessageLog to fetch.
     */
    where: MessageLogWhereUniqueInput
  }

  /**
   * MessageLog findFirst
   */
  export type MessageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * Filter, which MessageLog to fetch.
     */
    where?: MessageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLogs to fetch.
     */
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageLogs.
     */
    cursor?: MessageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageLogs.
     */
    distinct?: MessageLogScalarFieldEnum | MessageLogScalarFieldEnum[]
  }

  /**
   * MessageLog findFirstOrThrow
   */
  export type MessageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * Filter, which MessageLog to fetch.
     */
    where?: MessageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLogs to fetch.
     */
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageLogs.
     */
    cursor?: MessageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageLogs.
     */
    distinct?: MessageLogScalarFieldEnum | MessageLogScalarFieldEnum[]
  }

  /**
   * MessageLog findMany
   */
  export type MessageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * Filter, which MessageLogs to fetch.
     */
    where?: MessageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLogs to fetch.
     */
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageLogs.
     */
    cursor?: MessageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLogs.
     */
    skip?: number
    distinct?: MessageLogScalarFieldEnum | MessageLogScalarFieldEnum[]
  }

  /**
   * MessageLog create
   */
  export type MessageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageLog.
     */
    data: XOR<MessageLogCreateInput, MessageLogUncheckedCreateInput>
  }

  /**
   * MessageLog createMany
   */
  export type MessageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageLogs.
     */
    data: MessageLogCreateManyInput | MessageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageLog createManyAndReturn
   */
  export type MessageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageLogs.
     */
    data: MessageLogCreateManyInput | MessageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageLog update
   */
  export type MessageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageLog.
     */
    data: XOR<MessageLogUpdateInput, MessageLogUncheckedUpdateInput>
    /**
     * Choose, which MessageLog to update.
     */
    where: MessageLogWhereUniqueInput
  }

  /**
   * MessageLog updateMany
   */
  export type MessageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageLogs.
     */
    data: XOR<MessageLogUpdateManyMutationInput, MessageLogUncheckedUpdateManyInput>
    /**
     * Filter which MessageLogs to update
     */
    where?: MessageLogWhereInput
  }

  /**
   * MessageLog upsert
   */
  export type MessageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageLog to update in case it exists.
     */
    where: MessageLogWhereUniqueInput
    /**
     * In case the MessageLog found by the `where` argument doesn't exist, create a new MessageLog with this data.
     */
    create: XOR<MessageLogCreateInput, MessageLogUncheckedCreateInput>
    /**
     * In case the MessageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageLogUpdateInput, MessageLogUncheckedUpdateInput>
  }

  /**
   * MessageLog delete
   */
  export type MessageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * Filter which MessageLog to delete.
     */
    where: MessageLogWhereUniqueInput
  }

  /**
   * MessageLog deleteMany
   */
  export type MessageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageLogs to delete
     */
    where?: MessageLogWhereInput
  }

  /**
   * MessageLog.CampaignLead
   */
  export type MessageLog$CampaignLeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    where?: CampaignLeadWhereInput
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    cursor?: CampaignLeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }

  /**
   * MessageLog without action
   */
  export type MessageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    profile: 'profile',
    phone: 'phone',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripeSubscriptionStatus: 'stripeSubscriptionStatus',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    whatleadCompanyId: 'whatleadCompanyId',
    plan: 'plan',
    status: 'status',
    maxInstances: 'maxInstances',
    messagesPerDay: 'messagesPerDay',
    features: 'features',
    support: 'support',
    trialEndDate: 'trialEndDate'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CompaniesUnitesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    productdefault: 'productdefault',
    campaignstatus: 'campaignstatus',
    enablecuration: 'enablecuration',
    enabletosendustolead: 'enabletosendustolead',
    enabled: 'enabled',
    isconversationia: 'isconversationia',
    campaignnumberbusiness: 'campaignnumberbusiness',
    whatsappprovider: 'whatsappprovider',
    enabletosendprovider: 'enabletosendprovider',
    enabletosecondcallprovider: 'enabletosecondcallprovider',
    integrationconfiguration: 'integrationconfiguration',
    integrationname: 'integrationname',
    templatelistvars: 'templatelistvars',
    metaconfiguration: 'metaconfiguration',
    messageperruns: 'messageperruns',
    notifyconfiguration: 'notifyconfiguration',
    updatedAt: 'updatedAt',
    whitelabel_config: 'whitelabel_config',
    whatleadCompanyId: 'whatleadCompanyId'
  };

  export type CompaniesUnitesScalarFieldEnum = (typeof CompaniesUnitesScalarFieldEnum)[keyof typeof CompaniesUnitesScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    externalid: 'externalid',
    sourceid: 'sourceid',
    name: 'name',
    phone: 'phone',
    email: 'email',
    lastmessagesent: 'lastmessagesent',
    stepsecondcalltemplate: 'stepsecondcalltemplate',
    stepnointeraction: 'stepnointeraction',
    nointeractionquantity: 'nointeractionquantity',
    accepttemplate: 'accepttemplate',
    acceptsecondtemplate: 'acceptsecondtemplate',
    status: 'status',
    dialog: 'dialog',
    configid: 'configid',
    whitelabelconfig: 'whitelabelconfig',
    lastintent: 'lastintent',
    broker: 'broker',
    origin: 'origin',
    send: 'send',
    sendAt: 'sendAt',
    isBusinessAutoResponder: 'isBusinessAutoResponder',
    startmessage: 'startmessage',
    schedulingdata: 'schedulingdata',
    productchoosebyclient: 'productchoosebyclient',
    productid: 'productid',
    createdat: 'createdat',
    updatedat: 'updatedat',
    curation: 'curation'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const Bot_DescritivoScalarFieldEnum: {
    id: 'id',
    name: 'name',
    descritivo: 'descritivo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Bot_DescritivoScalarFieldEnum = (typeof Bot_DescritivoScalarFieldEnum)[keyof typeof Bot_DescritivoScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    stripePaymentId: 'stripePaymentId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    customerId: 'customerId',
    metadata: 'metadata',
    disputeStatus: 'disputeStatus',
    disputeReason: 'disputeReason',
    cancelReason: 'cancelReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const InstanceScalarFieldEnum: {
    id: 'id',
    instanceName: 'instanceName',
    connectionStatus: 'connectionStatus',
    number: 'number',
    ownerJid: 'ownerJid',
    profilePicUrl: 'profilePicUrl',
    integration: 'integration',
    token: 'token',
    clientName: 'clientName',
    profileName: 'profileName',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    disconnectedAt: 'disconnectedAt',
    disconnectionObject: 'disconnectionObject',
    disconnectionReasonCode: 'disconnectionReasonCode',
    proxyConfig: 'proxyConfig',
    typebot: 'typebot'
  };

  export type InstanceScalarFieldEnum = (typeof InstanceScalarFieldEnum)[keyof typeof InstanceScalarFieldEnum]


  export const MediaStatsScalarFieldEnum: {
    id: 'id',
    instanceName: 'instanceName',
    date: 'date',
    text: 'text',
    image: 'image',
    video: 'video',
    audio: 'audio',
    sticker: 'sticker',
    reaction: 'reaction',
    isReceived: 'isReceived',
    totalDaily: 'totalDaily',
    totalAllTime: 'totalAllTime',
    totalSent: 'totalSent',
    totalReceived: 'totalReceived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaStatsScalarFieldEnum = (typeof MediaStatsScalarFieldEnum)[keyof typeof MediaStatsScalarFieldEnum]


  export const WarmupStatsScalarFieldEnum: {
    id: 'id',
    instanceName: 'instanceName',
    status: 'status',
    messagesSent: 'messagesSent',
    messagesReceived: 'messagesReceived',
    warmupTime: 'warmupTime',
    lastActive: 'lastActive',
    startTime: 'startTime',
    pauseTime: 'pauseTime',
    progress: 'progress',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    mediaStatsId: 'mediaStatsId',
    mediaReceivedId: 'mediaReceivedId'
  };

  export type WarmupStatsScalarFieldEnum = (typeof WarmupStatsScalarFieldEnum)[keyof typeof WarmupStatsScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    type: 'type',
    scheduledDate: 'scheduledDate',
    scheduledStatus: 'scheduledStatus',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    pausedAt: 'pausedAt',
    progress: 'progress',
    minDelay: 'minDelay',
    maxDelay: 'maxDelay',
    userId: 'userId',
    instanceName: 'instanceName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignMessageScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    type: 'type',
    content: 'content',
    order: 'order',
    caption: 'caption',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignMessageScalarFieldEnum = (typeof CampaignMessageScalarFieldEnum)[keyof typeof CampaignMessageScalarFieldEnum]


  export const CampaignLeadScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    name: 'name',
    phone: 'phone',
    status: 'status',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    readAt: 'readAt',
    failedAt: 'failedAt',
    failureReason: 'failureReason',
    messageId: 'messageId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignLeadScalarFieldEnum = (typeof CampaignLeadScalarFieldEnum)[keyof typeof CampaignLeadScalarFieldEnum]


  export const CampaignStatisticsScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    totalLeads: 'totalLeads',
    sentCount: 'sentCount',
    deliveredCount: 'deliveredCount',
    readCount: 'readCount',
    failedCount: 'failedCount',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignStatisticsScalarFieldEnum = (typeof CampaignStatisticsScalarFieldEnum)[keyof typeof CampaignStatisticsScalarFieldEnum]


  export const MessageLogScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    leadId: 'leadId',
    messageId: 'messageId',
    messageDate: 'messageDate',
    messageType: 'messageType',
    content: 'content',
    status: 'status',
    statusHistory: 'statusHistory',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    readAt: 'readAt',
    failedAt: 'failedAt',
    failureReason: 'failureReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageLogScalarFieldEnum = (typeof MessageLogScalarFieldEnum)[keyof typeof MessageLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    active?: BoolNullableFilter<"Company"> | boolean | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    WhatleadUser?: UserListRelationFilter
    whatleadparceiroconfigs?: CompaniesUnitesListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    WhatleadUser?: UserOrderByRelationAggregateInput
    whatleadparceiroconfigs?: CompaniesUnitesOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    active?: BoolNullableFilter<"Company"> | boolean | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    WhatleadUser?: UserListRelationFilter
    whatleadparceiroconfigs?: CompaniesUnitesListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    active?: BoolNullableWithAggregatesFilter<"Company"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profile?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionStatus?: StringNullableFilter<"User"> | string | null
    active?: BoolNullableFilter<"User"> | boolean | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    whatleadCompanyId?: StringFilter<"User"> | string
    plan?: StringFilter<"User"> | string
    status?: BoolFilter<"User"> | boolean
    maxInstances?: IntFilter<"User"> | number
    messagesPerDay?: IntFilter<"User"> | number
    features?: StringNullableListFilter<"User">
    support?: StringFilter<"User"> | string
    trialEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    instances?: InstanceListRelationFilter
    payments?: PaymentListRelationFilter
    warmupStats?: WarmupStatsListRelationFilter
    Campaign?: CampaignListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    profile?: SortOrder
    phone?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeSubscriptionStatus?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatleadCompanyId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
    features?: SortOrder
    support?: SortOrder
    trialEndDate?: SortOrderInput | SortOrder
    instances?: InstanceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    warmupStats?: WarmupStatsOrderByRelationAggregateInput
    Campaign?: CampaignOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profile?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionStatus?: StringNullableFilter<"User"> | string | null
    active?: BoolNullableFilter<"User"> | boolean | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    whatleadCompanyId?: StringFilter<"User"> | string
    plan?: StringFilter<"User"> | string
    status?: BoolFilter<"User"> | boolean
    maxInstances?: IntFilter<"User"> | number
    messagesPerDay?: IntFilter<"User"> | number
    features?: StringNullableListFilter<"User">
    support?: StringFilter<"User"> | string
    trialEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    instances?: InstanceListRelationFilter
    payments?: PaymentListRelationFilter
    warmupStats?: WarmupStatsListRelationFilter
    Campaign?: CampaignListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    profile?: SortOrder
    phone?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeSubscriptionStatus?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatleadCompanyId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
    features?: SortOrder
    support?: SortOrder
    trialEndDate?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    profile?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripeSubscriptionStatus?: StringNullableWithAggregatesFilter<"User"> | string | null
    active?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    whatleadCompanyId?: StringWithAggregatesFilter<"User"> | string
    plan?: StringWithAggregatesFilter<"User"> | string
    status?: BoolWithAggregatesFilter<"User"> | boolean
    maxInstances?: IntWithAggregatesFilter<"User"> | number
    messagesPerDay?: IntWithAggregatesFilter<"User"> | number
    features?: StringNullableListFilter<"User">
    support?: StringWithAggregatesFilter<"User"> | string
    trialEndDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type CompaniesUnitesWhereInput = {
    AND?: CompaniesUnitesWhereInput | CompaniesUnitesWhereInput[]
    OR?: CompaniesUnitesWhereInput[]
    NOT?: CompaniesUnitesWhereInput | CompaniesUnitesWhereInput[]
    id?: StringFilter<"CompaniesUnites"> | string
    createdAt?: DateTimeNullableFilter<"CompaniesUnites"> | Date | string | null
    name?: StringNullableFilter<"CompaniesUnites"> | string | null
    productdefault?: StringNullableFilter<"CompaniesUnites"> | string | null
    campaignstatus?: StringNullableFilter<"CompaniesUnites"> | string | null
    enablecuration?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabletosendustolead?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabled?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    isconversationia?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    campaignnumberbusiness?: StringNullableFilter<"CompaniesUnites"> | string | null
    whatsappprovider?: StringNullableFilter<"CompaniesUnites"> | string | null
    enabletosendprovider?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabletosecondcallprovider?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    integrationconfiguration?: JsonNullableFilter<"CompaniesUnites">
    integrationname?: StringNullableFilter<"CompaniesUnites"> | string | null
    templatelistvars?: JsonNullableListFilter<"CompaniesUnites">
    metaconfiguration?: JsonNullableFilter<"CompaniesUnites">
    messageperruns?: JsonNullableListFilter<"CompaniesUnites">
    notifyconfiguration?: JsonNullableFilter<"CompaniesUnites">
    updatedAt?: DateTimeNullableFilter<"CompaniesUnites"> | Date | string | null
    whitelabel_config?: StringFilter<"CompaniesUnites"> | string
    whatleadCompanyId?: StringNullableFilter<"CompaniesUnites"> | string | null
    leads?: LeadListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type CompaniesUnitesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    productdefault?: SortOrderInput | SortOrder
    campaignstatus?: SortOrderInput | SortOrder
    enablecuration?: SortOrderInput | SortOrder
    enabletosendustolead?: SortOrderInput | SortOrder
    enabled?: SortOrderInput | SortOrder
    isconversationia?: SortOrderInput | SortOrder
    campaignnumberbusiness?: SortOrderInput | SortOrder
    whatsappprovider?: SortOrderInput | SortOrder
    enabletosendprovider?: SortOrderInput | SortOrder
    enabletosecondcallprovider?: SortOrderInput | SortOrder
    integrationconfiguration?: SortOrderInput | SortOrder
    integrationname?: SortOrderInput | SortOrder
    templatelistvars?: SortOrder
    metaconfiguration?: SortOrderInput | SortOrder
    messageperruns?: SortOrder
    notifyconfiguration?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    whitelabel_config?: SortOrder
    whatleadCompanyId?: SortOrderInput | SortOrder
    leads?: LeadOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type CompaniesUnitesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignnumberbusiness?: string
    AND?: CompaniesUnitesWhereInput | CompaniesUnitesWhereInput[]
    OR?: CompaniesUnitesWhereInput[]
    NOT?: CompaniesUnitesWhereInput | CompaniesUnitesWhereInput[]
    createdAt?: DateTimeNullableFilter<"CompaniesUnites"> | Date | string | null
    name?: StringNullableFilter<"CompaniesUnites"> | string | null
    productdefault?: StringNullableFilter<"CompaniesUnites"> | string | null
    campaignstatus?: StringNullableFilter<"CompaniesUnites"> | string | null
    enablecuration?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabletosendustolead?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabled?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    isconversationia?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    whatsappprovider?: StringNullableFilter<"CompaniesUnites"> | string | null
    enabletosendprovider?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabletosecondcallprovider?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    integrationconfiguration?: JsonNullableFilter<"CompaniesUnites">
    integrationname?: StringNullableFilter<"CompaniesUnites"> | string | null
    templatelistvars?: JsonNullableListFilter<"CompaniesUnites">
    metaconfiguration?: JsonNullableFilter<"CompaniesUnites">
    messageperruns?: JsonNullableListFilter<"CompaniesUnites">
    notifyconfiguration?: JsonNullableFilter<"CompaniesUnites">
    updatedAt?: DateTimeNullableFilter<"CompaniesUnites"> | Date | string | null
    whitelabel_config?: StringFilter<"CompaniesUnites"> | string
    whatleadCompanyId?: StringNullableFilter<"CompaniesUnites"> | string | null
    leads?: LeadListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id" | "campaignnumberbusiness">

  export type CompaniesUnitesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    productdefault?: SortOrderInput | SortOrder
    campaignstatus?: SortOrderInput | SortOrder
    enablecuration?: SortOrderInput | SortOrder
    enabletosendustolead?: SortOrderInput | SortOrder
    enabled?: SortOrderInput | SortOrder
    isconversationia?: SortOrderInput | SortOrder
    campaignnumberbusiness?: SortOrderInput | SortOrder
    whatsappprovider?: SortOrderInput | SortOrder
    enabletosendprovider?: SortOrderInput | SortOrder
    enabletosecondcallprovider?: SortOrderInput | SortOrder
    integrationconfiguration?: SortOrderInput | SortOrder
    integrationname?: SortOrderInput | SortOrder
    templatelistvars?: SortOrder
    metaconfiguration?: SortOrderInput | SortOrder
    messageperruns?: SortOrder
    notifyconfiguration?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    whitelabel_config?: SortOrder
    whatleadCompanyId?: SortOrderInput | SortOrder
    _count?: CompaniesUnitesCountOrderByAggregateInput
    _max?: CompaniesUnitesMaxOrderByAggregateInput
    _min?: CompaniesUnitesMinOrderByAggregateInput
  }

  export type CompaniesUnitesScalarWhereWithAggregatesInput = {
    AND?: CompaniesUnitesScalarWhereWithAggregatesInput | CompaniesUnitesScalarWhereWithAggregatesInput[]
    OR?: CompaniesUnitesScalarWhereWithAggregatesInput[]
    NOT?: CompaniesUnitesScalarWhereWithAggregatesInput | CompaniesUnitesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompaniesUnites"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"CompaniesUnites"> | Date | string | null
    name?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
    productdefault?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
    campaignstatus?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
    enablecuration?: BoolNullableWithAggregatesFilter<"CompaniesUnites"> | boolean | null
    enabletosendustolead?: BoolNullableWithAggregatesFilter<"CompaniesUnites"> | boolean | null
    enabled?: BoolNullableWithAggregatesFilter<"CompaniesUnites"> | boolean | null
    isconversationia?: BoolNullableWithAggregatesFilter<"CompaniesUnites"> | boolean | null
    campaignnumberbusiness?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
    whatsappprovider?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
    enabletosendprovider?: BoolNullableWithAggregatesFilter<"CompaniesUnites"> | boolean | null
    enabletosecondcallprovider?: BoolNullableWithAggregatesFilter<"CompaniesUnites"> | boolean | null
    integrationconfiguration?: JsonNullableWithAggregatesFilter<"CompaniesUnites">
    integrationname?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
    templatelistvars?: JsonNullableListFilter<"CompaniesUnites">
    metaconfiguration?: JsonNullableWithAggregatesFilter<"CompaniesUnites">
    messageperruns?: JsonNullableListFilter<"CompaniesUnites">
    notifyconfiguration?: JsonNullableWithAggregatesFilter<"CompaniesUnites">
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CompaniesUnites"> | Date | string | null
    whitelabel_config?: StringWithAggregatesFilter<"CompaniesUnites"> | string
    whatleadCompanyId?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    externalid?: StringNullableFilter<"Lead"> | string | null
    sourceid?: StringNullableFilter<"Lead"> | string | null
    name?: StringFilter<"Lead"> | string
    phone?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    lastmessagesent?: DateTimeNullableFilter<"Lead"> | Date | string | null
    stepsecondcalltemplate?: IntNullableFilter<"Lead"> | number | null
    stepnointeraction?: IntNullableFilter<"Lead"> | number | null
    nointeractionquantity?: IntNullableFilter<"Lead"> | number | null
    accepttemplate?: BoolNullableFilter<"Lead"> | boolean | null
    acceptsecondtemplate?: BoolNullableFilter<"Lead"> | boolean | null
    status?: StringNullableFilter<"Lead"> | string | null
    dialog?: JsonNullableListFilter<"Lead">
    configid?: StringFilter<"Lead"> | string
    whitelabelconfig?: StringFilter<"Lead"> | string
    lastintent?: StringNullableFilter<"Lead"> | string | null
    broker?: StringNullableFilter<"Lead"> | string | null
    origin?: StringNullableFilter<"Lead"> | string | null
    send?: BoolNullableFilter<"Lead"> | boolean | null
    sendAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    isBusinessAutoResponder?: BoolNullableFilter<"Lead"> | boolean | null
    startmessage?: DateTimeNullableFilter<"Lead"> | Date | string | null
    schedulingdata?: StringNullableFilter<"Lead"> | string | null
    productchoosebyclient?: StringNullableFilter<"Lead"> | string | null
    productid?: IntNullableFilter<"Lead"> | number | null
    createdat?: DateTimeNullableFilter<"Lead"> | Date | string | null
    updatedat?: DateTimeNullableFilter<"Lead"> | Date | string | null
    curation?: JsonNullableFilter<"Lead">
    MessageLog?: MessageLogListRelationFilter
    config?: XOR<CompaniesUnitesScalarRelationFilter, CompaniesUnitesWhereInput>
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    externalid?: SortOrderInput | SortOrder
    sourceid?: SortOrderInput | SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    lastmessagesent?: SortOrderInput | SortOrder
    stepsecondcalltemplate?: SortOrderInput | SortOrder
    stepnointeraction?: SortOrderInput | SortOrder
    nointeractionquantity?: SortOrderInput | SortOrder
    accepttemplate?: SortOrderInput | SortOrder
    acceptsecondtemplate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    dialog?: SortOrder
    configid?: SortOrder
    whitelabelconfig?: SortOrder
    lastintent?: SortOrderInput | SortOrder
    broker?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    send?: SortOrderInput | SortOrder
    sendAt?: SortOrderInput | SortOrder
    isBusinessAutoResponder?: SortOrderInput | SortOrder
    startmessage?: SortOrderInput | SortOrder
    schedulingdata?: SortOrderInput | SortOrder
    productchoosebyclient?: SortOrderInput | SortOrder
    productid?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    curation?: SortOrderInput | SortOrder
    MessageLog?: MessageLogOrderByRelationAggregateInput
    config?: CompaniesUnitesOrderByWithRelationInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    externalid?: StringNullableFilter<"Lead"> | string | null
    sourceid?: StringNullableFilter<"Lead"> | string | null
    name?: StringFilter<"Lead"> | string
    phone?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    lastmessagesent?: DateTimeNullableFilter<"Lead"> | Date | string | null
    stepsecondcalltemplate?: IntNullableFilter<"Lead"> | number | null
    stepnointeraction?: IntNullableFilter<"Lead"> | number | null
    nointeractionquantity?: IntNullableFilter<"Lead"> | number | null
    accepttemplate?: BoolNullableFilter<"Lead"> | boolean | null
    acceptsecondtemplate?: BoolNullableFilter<"Lead"> | boolean | null
    status?: StringNullableFilter<"Lead"> | string | null
    dialog?: JsonNullableListFilter<"Lead">
    configid?: StringFilter<"Lead"> | string
    whitelabelconfig?: StringFilter<"Lead"> | string
    lastintent?: StringNullableFilter<"Lead"> | string | null
    broker?: StringNullableFilter<"Lead"> | string | null
    origin?: StringNullableFilter<"Lead"> | string | null
    send?: BoolNullableFilter<"Lead"> | boolean | null
    sendAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    isBusinessAutoResponder?: BoolNullableFilter<"Lead"> | boolean | null
    startmessage?: DateTimeNullableFilter<"Lead"> | Date | string | null
    schedulingdata?: StringNullableFilter<"Lead"> | string | null
    productchoosebyclient?: StringNullableFilter<"Lead"> | string | null
    productid?: IntNullableFilter<"Lead"> | number | null
    createdat?: DateTimeNullableFilter<"Lead"> | Date | string | null
    updatedat?: DateTimeNullableFilter<"Lead"> | Date | string | null
    curation?: JsonNullableFilter<"Lead">
    MessageLog?: MessageLogListRelationFilter
    config?: XOR<CompaniesUnitesScalarRelationFilter, CompaniesUnitesWhereInput>
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    externalid?: SortOrderInput | SortOrder
    sourceid?: SortOrderInput | SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    lastmessagesent?: SortOrderInput | SortOrder
    stepsecondcalltemplate?: SortOrderInput | SortOrder
    stepnointeraction?: SortOrderInput | SortOrder
    nointeractionquantity?: SortOrderInput | SortOrder
    accepttemplate?: SortOrderInput | SortOrder
    acceptsecondtemplate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    dialog?: SortOrder
    configid?: SortOrder
    whitelabelconfig?: SortOrder
    lastintent?: SortOrderInput | SortOrder
    broker?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    send?: SortOrderInput | SortOrder
    sendAt?: SortOrderInput | SortOrder
    isBusinessAutoResponder?: SortOrderInput | SortOrder
    startmessage?: SortOrderInput | SortOrder
    schedulingdata?: SortOrderInput | SortOrder
    productchoosebyclient?: SortOrderInput | SortOrder
    productid?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    curation?: SortOrderInput | SortOrder
    _count?: LeadCountOrderByAggregateInput
    _avg?: LeadAvgOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
    _sum?: LeadSumOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    externalid?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    sourceid?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    name?: StringWithAggregatesFilter<"Lead"> | string
    phone?: StringWithAggregatesFilter<"Lead"> | string
    email?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    lastmessagesent?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    stepsecondcalltemplate?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    stepnointeraction?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    nointeractionquantity?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    accepttemplate?: BoolNullableWithAggregatesFilter<"Lead"> | boolean | null
    acceptsecondtemplate?: BoolNullableWithAggregatesFilter<"Lead"> | boolean | null
    status?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    dialog?: JsonNullableListFilter<"Lead">
    configid?: StringWithAggregatesFilter<"Lead"> | string
    whitelabelconfig?: StringWithAggregatesFilter<"Lead"> | string
    lastintent?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    broker?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    origin?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    send?: BoolNullableWithAggregatesFilter<"Lead"> | boolean | null
    sendAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    isBusinessAutoResponder?: BoolNullableWithAggregatesFilter<"Lead"> | boolean | null
    startmessage?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    schedulingdata?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    productchoosebyclient?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    productid?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    createdat?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    updatedat?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    curation?: JsonNullableWithAggregatesFilter<"Lead">
  }

  export type Bot_DescritivoWhereInput = {
    AND?: Bot_DescritivoWhereInput | Bot_DescritivoWhereInput[]
    OR?: Bot_DescritivoWhereInput[]
    NOT?: Bot_DescritivoWhereInput | Bot_DescritivoWhereInput[]
    id?: StringFilter<"Bot_Descritivo"> | string
    name?: StringFilter<"Bot_Descritivo"> | string
    descritivo?: StringFilter<"Bot_Descritivo"> | string
    createdAt?: DateTimeFilter<"Bot_Descritivo"> | Date | string
    updatedAt?: DateTimeFilter<"Bot_Descritivo"> | Date | string
  }

  export type Bot_DescritivoOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    descritivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Bot_DescritivoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Bot_DescritivoWhereInput | Bot_DescritivoWhereInput[]
    OR?: Bot_DescritivoWhereInput[]
    NOT?: Bot_DescritivoWhereInput | Bot_DescritivoWhereInput[]
    name?: StringFilter<"Bot_Descritivo"> | string
    descritivo?: StringFilter<"Bot_Descritivo"> | string
    createdAt?: DateTimeFilter<"Bot_Descritivo"> | Date | string
    updatedAt?: DateTimeFilter<"Bot_Descritivo"> | Date | string
  }, "id">

  export type Bot_DescritivoOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    descritivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: Bot_DescritivoCountOrderByAggregateInput
    _max?: Bot_DescritivoMaxOrderByAggregateInput
    _min?: Bot_DescritivoMinOrderByAggregateInput
  }

  export type Bot_DescritivoScalarWhereWithAggregatesInput = {
    AND?: Bot_DescritivoScalarWhereWithAggregatesInput | Bot_DescritivoScalarWhereWithAggregatesInput[]
    OR?: Bot_DescritivoScalarWhereWithAggregatesInput[]
    NOT?: Bot_DescritivoScalarWhereWithAggregatesInput | Bot_DescritivoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bot_Descritivo"> | string
    name?: StringWithAggregatesFilter<"Bot_Descritivo"> | string
    descritivo?: StringWithAggregatesFilter<"Bot_Descritivo"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Bot_Descritivo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bot_Descritivo"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    stripePaymentId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    disputeStatus?: StringNullableFilter<"Payment"> | string | null
    disputeReason?: StringNullableFilter<"Payment"> | string | null
    cancelReason?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    userId?: StringNullableFilter<"Payment"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    customerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    disputeStatus?: SortOrderInput | SortOrder
    disputeReason?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePaymentId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    disputeStatus?: StringNullableFilter<"Payment"> | string | null
    disputeReason?: StringNullableFilter<"Payment"> | string | null
    cancelReason?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    userId?: StringNullableFilter<"Payment"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "stripePaymentId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    customerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    disputeStatus?: SortOrderInput | SortOrder
    disputeReason?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    stripePaymentId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: IntWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    customerId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    disputeStatus?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    disputeReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    cancelReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type InstanceWhereInput = {
    AND?: InstanceWhereInput | InstanceWhereInput[]
    OR?: InstanceWhereInput[]
    NOT?: InstanceWhereInput | InstanceWhereInput[]
    id?: StringFilter<"Instance"> | string
    instanceName?: StringFilter<"Instance"> | string
    connectionStatus?: StringFilter<"Instance"> | string
    number?: StringNullableFilter<"Instance"> | string | null
    ownerJid?: StringNullableFilter<"Instance"> | string | null
    profilePicUrl?: StringNullableFilter<"Instance"> | string | null
    integration?: StringFilter<"Instance"> | string
    token?: StringNullableFilter<"Instance"> | string | null
    clientName?: StringNullableFilter<"Instance"> | string | null
    profileName?: StringNullableFilter<"Instance"> | string | null
    userId?: StringFilter<"Instance"> | string
    createdAt?: DateTimeFilter<"Instance"> | Date | string
    updatedAt?: DateTimeFilter<"Instance"> | Date | string
    disconnectedAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    disconnectionObject?: JsonNullableFilter<"Instance">
    disconnectionReasonCode?: StringNullableFilter<"Instance"> | string | null
    proxyConfig?: JsonNullableFilter<"Instance">
    typebot?: JsonNullableFilter<"Instance">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    mediaStats?: MediaStatsListRelationFilter
    warmupStats?: XOR<WarmupStatsNullableScalarRelationFilter, WarmupStatsWhereInput> | null
    Campaign?: CampaignListRelationFilter
  }

  export type InstanceOrderByWithRelationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    connectionStatus?: SortOrder
    number?: SortOrderInput | SortOrder
    ownerJid?: SortOrderInput | SortOrder
    profilePicUrl?: SortOrderInput | SortOrder
    integration?: SortOrder
    token?: SortOrderInput | SortOrder
    clientName?: SortOrderInput | SortOrder
    profileName?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disconnectedAt?: SortOrderInput | SortOrder
    disconnectionObject?: SortOrderInput | SortOrder
    disconnectionReasonCode?: SortOrderInput | SortOrder
    proxyConfig?: SortOrderInput | SortOrder
    typebot?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    mediaStats?: MediaStatsOrderByRelationAggregateInput
    warmupStats?: WarmupStatsOrderByWithRelationInput
    Campaign?: CampaignOrderByRelationAggregateInput
  }

  export type InstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceName?: string
    AND?: InstanceWhereInput | InstanceWhereInput[]
    OR?: InstanceWhereInput[]
    NOT?: InstanceWhereInput | InstanceWhereInput[]
    connectionStatus?: StringFilter<"Instance"> | string
    number?: StringNullableFilter<"Instance"> | string | null
    ownerJid?: StringNullableFilter<"Instance"> | string | null
    profilePicUrl?: StringNullableFilter<"Instance"> | string | null
    integration?: StringFilter<"Instance"> | string
    token?: StringNullableFilter<"Instance"> | string | null
    clientName?: StringNullableFilter<"Instance"> | string | null
    profileName?: StringNullableFilter<"Instance"> | string | null
    userId?: StringFilter<"Instance"> | string
    createdAt?: DateTimeFilter<"Instance"> | Date | string
    updatedAt?: DateTimeFilter<"Instance"> | Date | string
    disconnectedAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    disconnectionObject?: JsonNullableFilter<"Instance">
    disconnectionReasonCode?: StringNullableFilter<"Instance"> | string | null
    proxyConfig?: JsonNullableFilter<"Instance">
    typebot?: JsonNullableFilter<"Instance">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    mediaStats?: MediaStatsListRelationFilter
    warmupStats?: XOR<WarmupStatsNullableScalarRelationFilter, WarmupStatsWhereInput> | null
    Campaign?: CampaignListRelationFilter
  }, "id" | "instanceName">

  export type InstanceOrderByWithAggregationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    connectionStatus?: SortOrder
    number?: SortOrderInput | SortOrder
    ownerJid?: SortOrderInput | SortOrder
    profilePicUrl?: SortOrderInput | SortOrder
    integration?: SortOrder
    token?: SortOrderInput | SortOrder
    clientName?: SortOrderInput | SortOrder
    profileName?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disconnectedAt?: SortOrderInput | SortOrder
    disconnectionObject?: SortOrderInput | SortOrder
    disconnectionReasonCode?: SortOrderInput | SortOrder
    proxyConfig?: SortOrderInput | SortOrder
    typebot?: SortOrderInput | SortOrder
    _count?: InstanceCountOrderByAggregateInput
    _max?: InstanceMaxOrderByAggregateInput
    _min?: InstanceMinOrderByAggregateInput
  }

  export type InstanceScalarWhereWithAggregatesInput = {
    AND?: InstanceScalarWhereWithAggregatesInput | InstanceScalarWhereWithAggregatesInput[]
    OR?: InstanceScalarWhereWithAggregatesInput[]
    NOT?: InstanceScalarWhereWithAggregatesInput | InstanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Instance"> | string
    instanceName?: StringWithAggregatesFilter<"Instance"> | string
    connectionStatus?: StringWithAggregatesFilter<"Instance"> | string
    number?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    ownerJid?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    profilePicUrl?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    integration?: StringWithAggregatesFilter<"Instance"> | string
    token?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    clientName?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    profileName?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    userId?: StringWithAggregatesFilter<"Instance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Instance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Instance"> | Date | string
    disconnectedAt?: DateTimeNullableWithAggregatesFilter<"Instance"> | Date | string | null
    disconnectionObject?: JsonNullableWithAggregatesFilter<"Instance">
    disconnectionReasonCode?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    proxyConfig?: JsonNullableWithAggregatesFilter<"Instance">
    typebot?: JsonNullableWithAggregatesFilter<"Instance">
  }

  export type MediaStatsWhereInput = {
    AND?: MediaStatsWhereInput | MediaStatsWhereInput[]
    OR?: MediaStatsWhereInput[]
    NOT?: MediaStatsWhereInput | MediaStatsWhereInput[]
    id?: StringFilter<"MediaStats"> | string
    instanceName?: StringFilter<"MediaStats"> | string
    date?: DateTimeFilter<"MediaStats"> | Date | string
    text?: IntFilter<"MediaStats"> | number
    image?: IntFilter<"MediaStats"> | number
    video?: IntFilter<"MediaStats"> | number
    audio?: IntFilter<"MediaStats"> | number
    sticker?: IntFilter<"MediaStats"> | number
    reaction?: IntFilter<"MediaStats"> | number
    isReceived?: BoolFilter<"MediaStats"> | boolean
    totalDaily?: IntFilter<"MediaStats"> | number
    totalAllTime?: IntFilter<"MediaStats"> | number
    totalSent?: IntFilter<"MediaStats"> | number
    totalReceived?: IntFilter<"MediaStats"> | number
    createdAt?: DateTimeFilter<"MediaStats"> | Date | string
    updatedAt?: DateTimeFilter<"MediaStats"> | Date | string
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    warmupStatsReceived?: WarmupStatsListRelationFilter
    warmupStatsSent?: WarmupStatsListRelationFilter
  }

  export type MediaStatsOrderByWithRelationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    date?: SortOrder
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    isReceived?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: InstanceOrderByWithRelationInput
    warmupStatsReceived?: WarmupStatsOrderByRelationAggregateInput
    warmupStatsSent?: WarmupStatsOrderByRelationAggregateInput
  }

  export type MediaStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaStatsWhereInput | MediaStatsWhereInput[]
    OR?: MediaStatsWhereInput[]
    NOT?: MediaStatsWhereInput | MediaStatsWhereInput[]
    instanceName?: StringFilter<"MediaStats"> | string
    date?: DateTimeFilter<"MediaStats"> | Date | string
    text?: IntFilter<"MediaStats"> | number
    image?: IntFilter<"MediaStats"> | number
    video?: IntFilter<"MediaStats"> | number
    audio?: IntFilter<"MediaStats"> | number
    sticker?: IntFilter<"MediaStats"> | number
    reaction?: IntFilter<"MediaStats"> | number
    isReceived?: BoolFilter<"MediaStats"> | boolean
    totalDaily?: IntFilter<"MediaStats"> | number
    totalAllTime?: IntFilter<"MediaStats"> | number
    totalSent?: IntFilter<"MediaStats"> | number
    totalReceived?: IntFilter<"MediaStats"> | number
    createdAt?: DateTimeFilter<"MediaStats"> | Date | string
    updatedAt?: DateTimeFilter<"MediaStats"> | Date | string
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    warmupStatsReceived?: WarmupStatsListRelationFilter
    warmupStatsSent?: WarmupStatsListRelationFilter
  }, "id">

  export type MediaStatsOrderByWithAggregationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    date?: SortOrder
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    isReceived?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaStatsCountOrderByAggregateInput
    _avg?: MediaStatsAvgOrderByAggregateInput
    _max?: MediaStatsMaxOrderByAggregateInput
    _min?: MediaStatsMinOrderByAggregateInput
    _sum?: MediaStatsSumOrderByAggregateInput
  }

  export type MediaStatsScalarWhereWithAggregatesInput = {
    AND?: MediaStatsScalarWhereWithAggregatesInput | MediaStatsScalarWhereWithAggregatesInput[]
    OR?: MediaStatsScalarWhereWithAggregatesInput[]
    NOT?: MediaStatsScalarWhereWithAggregatesInput | MediaStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaStats"> | string
    instanceName?: StringWithAggregatesFilter<"MediaStats"> | string
    date?: DateTimeWithAggregatesFilter<"MediaStats"> | Date | string
    text?: IntWithAggregatesFilter<"MediaStats"> | number
    image?: IntWithAggregatesFilter<"MediaStats"> | number
    video?: IntWithAggregatesFilter<"MediaStats"> | number
    audio?: IntWithAggregatesFilter<"MediaStats"> | number
    sticker?: IntWithAggregatesFilter<"MediaStats"> | number
    reaction?: IntWithAggregatesFilter<"MediaStats"> | number
    isReceived?: BoolWithAggregatesFilter<"MediaStats"> | boolean
    totalDaily?: IntWithAggregatesFilter<"MediaStats"> | number
    totalAllTime?: IntWithAggregatesFilter<"MediaStats"> | number
    totalSent?: IntWithAggregatesFilter<"MediaStats"> | number
    totalReceived?: IntWithAggregatesFilter<"MediaStats"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MediaStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MediaStats"> | Date | string
  }

  export type WarmupStatsWhereInput = {
    AND?: WarmupStatsWhereInput | WarmupStatsWhereInput[]
    OR?: WarmupStatsWhereInput[]
    NOT?: WarmupStatsWhereInput | WarmupStatsWhereInput[]
    id?: StringFilter<"WarmupStats"> | string
    instanceName?: StringFilter<"WarmupStats"> | string
    status?: StringFilter<"WarmupStats"> | string
    messagesSent?: IntFilter<"WarmupStats"> | number
    messagesReceived?: IntFilter<"WarmupStats"> | number
    warmupTime?: IntFilter<"WarmupStats"> | number
    lastActive?: DateTimeFilter<"WarmupStats"> | Date | string
    startTime?: DateTimeNullableFilter<"WarmupStats"> | Date | string | null
    pauseTime?: DateTimeNullableFilter<"WarmupStats"> | Date | string | null
    progress?: IntFilter<"WarmupStats"> | number
    userId?: StringFilter<"WarmupStats"> | string
    createdAt?: DateTimeFilter<"WarmupStats"> | Date | string
    updatedAt?: DateTimeFilter<"WarmupStats"> | Date | string
    mediaStatsId?: StringNullableFilter<"WarmupStats"> | string | null
    mediaReceivedId?: StringNullableFilter<"WarmupStats"> | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    mediaReceived?: XOR<MediaStatsNullableScalarRelationFilter, MediaStatsWhereInput> | null
    mediaStats?: XOR<MediaStatsNullableScalarRelationFilter, MediaStatsWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WarmupStatsOrderByWithRelationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    lastActive?: SortOrder
    startTime?: SortOrderInput | SortOrder
    pauseTime?: SortOrderInput | SortOrder
    progress?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaStatsId?: SortOrderInput | SortOrder
    mediaReceivedId?: SortOrderInput | SortOrder
    instance?: InstanceOrderByWithRelationInput
    mediaReceived?: MediaStatsOrderByWithRelationInput
    mediaStats?: MediaStatsOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type WarmupStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceName?: string
    AND?: WarmupStatsWhereInput | WarmupStatsWhereInput[]
    OR?: WarmupStatsWhereInput[]
    NOT?: WarmupStatsWhereInput | WarmupStatsWhereInput[]
    status?: StringFilter<"WarmupStats"> | string
    messagesSent?: IntFilter<"WarmupStats"> | number
    messagesReceived?: IntFilter<"WarmupStats"> | number
    warmupTime?: IntFilter<"WarmupStats"> | number
    lastActive?: DateTimeFilter<"WarmupStats"> | Date | string
    startTime?: DateTimeNullableFilter<"WarmupStats"> | Date | string | null
    pauseTime?: DateTimeNullableFilter<"WarmupStats"> | Date | string | null
    progress?: IntFilter<"WarmupStats"> | number
    userId?: StringFilter<"WarmupStats"> | string
    createdAt?: DateTimeFilter<"WarmupStats"> | Date | string
    updatedAt?: DateTimeFilter<"WarmupStats"> | Date | string
    mediaStatsId?: StringNullableFilter<"WarmupStats"> | string | null
    mediaReceivedId?: StringNullableFilter<"WarmupStats"> | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    mediaReceived?: XOR<MediaStatsNullableScalarRelationFilter, MediaStatsWhereInput> | null
    mediaStats?: XOR<MediaStatsNullableScalarRelationFilter, MediaStatsWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "instanceName">

  export type WarmupStatsOrderByWithAggregationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    lastActive?: SortOrder
    startTime?: SortOrderInput | SortOrder
    pauseTime?: SortOrderInput | SortOrder
    progress?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaStatsId?: SortOrderInput | SortOrder
    mediaReceivedId?: SortOrderInput | SortOrder
    _count?: WarmupStatsCountOrderByAggregateInput
    _avg?: WarmupStatsAvgOrderByAggregateInput
    _max?: WarmupStatsMaxOrderByAggregateInput
    _min?: WarmupStatsMinOrderByAggregateInput
    _sum?: WarmupStatsSumOrderByAggregateInput
  }

  export type WarmupStatsScalarWhereWithAggregatesInput = {
    AND?: WarmupStatsScalarWhereWithAggregatesInput | WarmupStatsScalarWhereWithAggregatesInput[]
    OR?: WarmupStatsScalarWhereWithAggregatesInput[]
    NOT?: WarmupStatsScalarWhereWithAggregatesInput | WarmupStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarmupStats"> | string
    instanceName?: StringWithAggregatesFilter<"WarmupStats"> | string
    status?: StringWithAggregatesFilter<"WarmupStats"> | string
    messagesSent?: IntWithAggregatesFilter<"WarmupStats"> | number
    messagesReceived?: IntWithAggregatesFilter<"WarmupStats"> | number
    warmupTime?: IntWithAggregatesFilter<"WarmupStats"> | number
    lastActive?: DateTimeWithAggregatesFilter<"WarmupStats"> | Date | string
    startTime?: DateTimeNullableWithAggregatesFilter<"WarmupStats"> | Date | string | null
    pauseTime?: DateTimeNullableWithAggregatesFilter<"WarmupStats"> | Date | string | null
    progress?: IntWithAggregatesFilter<"WarmupStats"> | number
    userId?: StringWithAggregatesFilter<"WarmupStats"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WarmupStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarmupStats"> | Date | string
    mediaStatsId?: StringNullableWithAggregatesFilter<"WarmupStats"> | string | null
    mediaReceivedId?: StringNullableWithAggregatesFilter<"WarmupStats"> | string | null
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    status?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    scheduledDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    scheduledStatus?: StringNullableFilter<"Campaign"> | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    progress?: IntFilter<"Campaign"> | number
    minDelay?: IntFilter<"Campaign"> | number
    maxDelay?: IntFilter<"Campaign"> | number
    userId?: StringFilter<"Campaign"> | string
    instanceName?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    MessageLog?: MessageLogListRelationFilter
    leads?: CampaignLeadListRelationFilter
    messages?: CampaignMessageListRelationFilter
    statistics?: XOR<CampaignStatisticsNullableScalarRelationFilter, CampaignStatisticsWhereInput> | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    scheduledStatus?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    pausedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    userId?: SortOrder
    instanceName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    MessageLog?: MessageLogOrderByRelationAggregateInput
    leads?: CampaignLeadOrderByRelationAggregateInput
    messages?: CampaignMessageOrderByRelationAggregateInput
    statistics?: CampaignStatisticsOrderByWithRelationInput
    instance?: InstanceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    status?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    scheduledDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    scheduledStatus?: StringNullableFilter<"Campaign"> | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    progress?: IntFilter<"Campaign"> | number
    minDelay?: IntFilter<"Campaign"> | number
    maxDelay?: IntFilter<"Campaign"> | number
    userId?: StringFilter<"Campaign"> | string
    instanceName?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    MessageLog?: MessageLogListRelationFilter
    leads?: CampaignLeadListRelationFilter
    messages?: CampaignMessageListRelationFilter
    statistics?: XOR<CampaignStatisticsNullableScalarRelationFilter, CampaignStatisticsWhereInput> | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    scheduledStatus?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    pausedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    userId?: SortOrder
    instanceName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    status?: StringWithAggregatesFilter<"Campaign"> | string
    type?: StringWithAggregatesFilter<"Campaign"> | string
    scheduledDate?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    scheduledStatus?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    pausedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    progress?: IntWithAggregatesFilter<"Campaign"> | number
    minDelay?: IntWithAggregatesFilter<"Campaign"> | number
    maxDelay?: IntWithAggregatesFilter<"Campaign"> | number
    userId?: StringWithAggregatesFilter<"Campaign"> | string
    instanceName?: StringWithAggregatesFilter<"Campaign"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type CampaignMessageWhereInput = {
    AND?: CampaignMessageWhereInput | CampaignMessageWhereInput[]
    OR?: CampaignMessageWhereInput[]
    NOT?: CampaignMessageWhereInput | CampaignMessageWhereInput[]
    id?: StringFilter<"CampaignMessage"> | string
    campaignId?: StringFilter<"CampaignMessage"> | string
    type?: StringFilter<"CampaignMessage"> | string
    content?: StringFilter<"CampaignMessage"> | string
    order?: IntFilter<"CampaignMessage"> | number
    caption?: StringNullableFilter<"CampaignMessage"> | string | null
    createdAt?: DateTimeFilter<"CampaignMessage"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignMessage"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignMessageOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    caption?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignMessageWhereInput | CampaignMessageWhereInput[]
    OR?: CampaignMessageWhereInput[]
    NOT?: CampaignMessageWhereInput | CampaignMessageWhereInput[]
    campaignId?: StringFilter<"CampaignMessage"> | string
    type?: StringFilter<"CampaignMessage"> | string
    content?: StringFilter<"CampaignMessage"> | string
    order?: IntFilter<"CampaignMessage"> | number
    caption?: StringNullableFilter<"CampaignMessage"> | string | null
    createdAt?: DateTimeFilter<"CampaignMessage"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignMessage"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignMessageOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    caption?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignMessageCountOrderByAggregateInput
    _avg?: CampaignMessageAvgOrderByAggregateInput
    _max?: CampaignMessageMaxOrderByAggregateInput
    _min?: CampaignMessageMinOrderByAggregateInput
    _sum?: CampaignMessageSumOrderByAggregateInput
  }

  export type CampaignMessageScalarWhereWithAggregatesInput = {
    AND?: CampaignMessageScalarWhereWithAggregatesInput | CampaignMessageScalarWhereWithAggregatesInput[]
    OR?: CampaignMessageScalarWhereWithAggregatesInput[]
    NOT?: CampaignMessageScalarWhereWithAggregatesInput | CampaignMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignMessage"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignMessage"> | string
    type?: StringWithAggregatesFilter<"CampaignMessage"> | string
    content?: StringWithAggregatesFilter<"CampaignMessage"> | string
    order?: IntWithAggregatesFilter<"CampaignMessage"> | number
    caption?: StringNullableWithAggregatesFilter<"CampaignMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignMessage"> | Date | string
  }

  export type CampaignLeadWhereInput = {
    AND?: CampaignLeadWhereInput | CampaignLeadWhereInput[]
    OR?: CampaignLeadWhereInput[]
    NOT?: CampaignLeadWhereInput | CampaignLeadWhereInput[]
    id?: StringFilter<"CampaignLead"> | string
    campaignId?: StringFilter<"CampaignLead"> | string
    name?: StringNullableFilter<"CampaignLead"> | string | null
    phone?: StringFilter<"CampaignLead"> | string
    status?: StringFilter<"CampaignLead"> | string
    sentAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    readAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    failureReason?: StringNullableFilter<"CampaignLead"> | string | null
    messageId?: StringNullableFilter<"CampaignLead"> | string | null
    createdAt?: DateTimeFilter<"CampaignLead"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignLead"> | Date | string
    messageLogs?: MessageLogListRelationFilter
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignLeadOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messageLogs?: MessageLogOrderByRelationAggregateInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignLeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignLeadWhereInput | CampaignLeadWhereInput[]
    OR?: CampaignLeadWhereInput[]
    NOT?: CampaignLeadWhereInput | CampaignLeadWhereInput[]
    campaignId?: StringFilter<"CampaignLead"> | string
    name?: StringNullableFilter<"CampaignLead"> | string | null
    phone?: StringFilter<"CampaignLead"> | string
    status?: StringFilter<"CampaignLead"> | string
    sentAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    readAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    failureReason?: StringNullableFilter<"CampaignLead"> | string | null
    messageId?: StringNullableFilter<"CampaignLead"> | string | null
    createdAt?: DateTimeFilter<"CampaignLead"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignLead"> | Date | string
    messageLogs?: MessageLogListRelationFilter
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignLeadOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignLeadCountOrderByAggregateInput
    _max?: CampaignLeadMaxOrderByAggregateInput
    _min?: CampaignLeadMinOrderByAggregateInput
  }

  export type CampaignLeadScalarWhereWithAggregatesInput = {
    AND?: CampaignLeadScalarWhereWithAggregatesInput | CampaignLeadScalarWhereWithAggregatesInput[]
    OR?: CampaignLeadScalarWhereWithAggregatesInput[]
    NOT?: CampaignLeadScalarWhereWithAggregatesInput | CampaignLeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignLead"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignLead"> | string
    name?: StringNullableWithAggregatesFilter<"CampaignLead"> | string | null
    phone?: StringWithAggregatesFilter<"CampaignLead"> | string
    status?: StringWithAggregatesFilter<"CampaignLead"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
    failureReason?: StringNullableWithAggregatesFilter<"CampaignLead"> | string | null
    messageId?: StringNullableWithAggregatesFilter<"CampaignLead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignLead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignLead"> | Date | string
  }

  export type CampaignStatisticsWhereInput = {
    AND?: CampaignStatisticsWhereInput | CampaignStatisticsWhereInput[]
    OR?: CampaignStatisticsWhereInput[]
    NOT?: CampaignStatisticsWhereInput | CampaignStatisticsWhereInput[]
    id?: StringFilter<"CampaignStatistics"> | string
    campaignId?: StringFilter<"CampaignStatistics"> | string
    totalLeads?: IntFilter<"CampaignStatistics"> | number
    sentCount?: IntFilter<"CampaignStatistics"> | number
    deliveredCount?: IntFilter<"CampaignStatistics"> | number
    readCount?: IntFilter<"CampaignStatistics"> | number
    failedCount?: IntFilter<"CampaignStatistics"> | number
    startedAt?: DateTimeNullableFilter<"CampaignStatistics"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CampaignStatistics"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignStatistics"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignStatistics"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignStatisticsOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignStatisticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId?: string
    AND?: CampaignStatisticsWhereInput | CampaignStatisticsWhereInput[]
    OR?: CampaignStatisticsWhereInput[]
    NOT?: CampaignStatisticsWhereInput | CampaignStatisticsWhereInput[]
    totalLeads?: IntFilter<"CampaignStatistics"> | number
    sentCount?: IntFilter<"CampaignStatistics"> | number
    deliveredCount?: IntFilter<"CampaignStatistics"> | number
    readCount?: IntFilter<"CampaignStatistics"> | number
    failedCount?: IntFilter<"CampaignStatistics"> | number
    startedAt?: DateTimeNullableFilter<"CampaignStatistics"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CampaignStatistics"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignStatistics"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignStatistics"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id" | "campaignId">

  export type CampaignStatisticsOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignStatisticsCountOrderByAggregateInput
    _avg?: CampaignStatisticsAvgOrderByAggregateInput
    _max?: CampaignStatisticsMaxOrderByAggregateInput
    _min?: CampaignStatisticsMinOrderByAggregateInput
    _sum?: CampaignStatisticsSumOrderByAggregateInput
  }

  export type CampaignStatisticsScalarWhereWithAggregatesInput = {
    AND?: CampaignStatisticsScalarWhereWithAggregatesInput | CampaignStatisticsScalarWhereWithAggregatesInput[]
    OR?: CampaignStatisticsScalarWhereWithAggregatesInput[]
    NOT?: CampaignStatisticsScalarWhereWithAggregatesInput | CampaignStatisticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignStatistics"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignStatistics"> | string
    totalLeads?: IntWithAggregatesFilter<"CampaignStatistics"> | number
    sentCount?: IntWithAggregatesFilter<"CampaignStatistics"> | number
    deliveredCount?: IntWithAggregatesFilter<"CampaignStatistics"> | number
    readCount?: IntWithAggregatesFilter<"CampaignStatistics"> | number
    failedCount?: IntWithAggregatesFilter<"CampaignStatistics"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"CampaignStatistics"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"CampaignStatistics"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignStatistics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignStatistics"> | Date | string
  }

  export type MessageLogWhereInput = {
    AND?: MessageLogWhereInput | MessageLogWhereInput[]
    OR?: MessageLogWhereInput[]
    NOT?: MessageLogWhereInput | MessageLogWhereInput[]
    id?: StringFilter<"MessageLog"> | string
    campaignId?: StringFilter<"MessageLog"> | string
    leadId?: StringFilter<"MessageLog"> | string
    messageId?: StringFilter<"MessageLog"> | string
    messageDate?: DateTimeFilter<"MessageLog"> | Date | string
    messageType?: StringFilter<"MessageLog"> | string
    content?: StringFilter<"MessageLog"> | string
    status?: StringFilter<"MessageLog"> | string
    statusHistory?: JsonNullableListFilter<"MessageLog">
    sentAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    readAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    failureReason?: StringNullableFilter<"MessageLog"> | string | null
    createdAt?: DateTimeFilter<"MessageLog"> | Date | string
    updatedAt?: DateTimeFilter<"MessageLog"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    CampaignLead?: CampaignLeadListRelationFilter
    lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
  }

  export type MessageLogOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    messageId?: SortOrder
    messageDate?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    status?: SortOrder
    statusHistory?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    CampaignLead?: CampaignLeadOrderByRelationAggregateInput
    lead?: LeadOrderByWithRelationInput
  }

  export type MessageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_messageDate?: MessageLogMessageIdMessageDateCompoundUniqueInput
    AND?: MessageLogWhereInput | MessageLogWhereInput[]
    OR?: MessageLogWhereInput[]
    NOT?: MessageLogWhereInput | MessageLogWhereInput[]
    campaignId?: StringFilter<"MessageLog"> | string
    leadId?: StringFilter<"MessageLog"> | string
    messageId?: StringFilter<"MessageLog"> | string
    messageDate?: DateTimeFilter<"MessageLog"> | Date | string
    messageType?: StringFilter<"MessageLog"> | string
    content?: StringFilter<"MessageLog"> | string
    status?: StringFilter<"MessageLog"> | string
    statusHistory?: JsonNullableListFilter<"MessageLog">
    sentAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    readAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    failureReason?: StringNullableFilter<"MessageLog"> | string | null
    createdAt?: DateTimeFilter<"MessageLog"> | Date | string
    updatedAt?: DateTimeFilter<"MessageLog"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    CampaignLead?: CampaignLeadListRelationFilter
    lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
  }, "id" | "messageId_messageDate">

  export type MessageLogOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    messageId?: SortOrder
    messageDate?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    status?: SortOrder
    statusHistory?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageLogCountOrderByAggregateInput
    _max?: MessageLogMaxOrderByAggregateInput
    _min?: MessageLogMinOrderByAggregateInput
  }

  export type MessageLogScalarWhereWithAggregatesInput = {
    AND?: MessageLogScalarWhereWithAggregatesInput | MessageLogScalarWhereWithAggregatesInput[]
    OR?: MessageLogScalarWhereWithAggregatesInput[]
    NOT?: MessageLogScalarWhereWithAggregatesInput | MessageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageLog"> | string
    campaignId?: StringWithAggregatesFilter<"MessageLog"> | string
    leadId?: StringWithAggregatesFilter<"MessageLog"> | string
    messageId?: StringWithAggregatesFilter<"MessageLog"> | string
    messageDate?: DateTimeWithAggregatesFilter<"MessageLog"> | Date | string
    messageType?: StringWithAggregatesFilter<"MessageLog"> | string
    content?: StringWithAggregatesFilter<"MessageLog"> | string
    status?: StringWithAggregatesFilter<"MessageLog"> | string
    statusHistory?: JsonNullableListFilter<"MessageLog">
    sentAt?: DateTimeNullableWithAggregatesFilter<"MessageLog"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"MessageLog"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"MessageLog"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"MessageLog"> | Date | string | null
    failureReason?: StringNullableWithAggregatesFilter<"MessageLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MessageLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageLog"> | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    WhatleadUser?: UserCreateNestedManyWithoutCompanyInput
    whatleadparceiroconfigs?: CompaniesUnitesCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    WhatleadUser?: UserUncheckedCreateNestedManyWithoutCompanyInput
    whatleadparceiroconfigs?: CompaniesUnitesUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WhatleadUser?: UserUpdateManyWithoutCompanyNestedInput
    whatleadparceiroconfigs?: CompaniesUnitesUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WhatleadUser?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    whatleadparceiroconfigs?: CompaniesUnitesUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompaniesUnitesCreateInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    leads?: LeadCreateNestedManyWithoutConfigInput
    company?: CompanyCreateNestedOneWithoutWhatleadparceiroconfigsInput
  }

  export type CompaniesUnitesUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    whatleadCompanyId?: string | null
    leads?: LeadUncheckedCreateNestedManyWithoutConfigInput
  }

  export type CompaniesUnitesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    leads?: LeadUpdateManyWithoutConfigNestedInput
    company?: CompanyUpdateOneWithoutWhatleadparceiroconfigsNestedInput
  }

  export type CompaniesUnitesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    whatleadCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    leads?: LeadUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type CompaniesUnitesCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    whatleadCompanyId?: string | null
  }

  export type CompaniesUnitesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesUnitesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    whatleadCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadCreateInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string | null
    updatedat?: Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutLeadInput
    config: CompaniesUnitesCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    configid: string
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string | null
    updatedat?: Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutLeadNestedInput
    config?: CompaniesUnitesUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    configid?: StringFieldUpdateOperationsInput | string
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    configid: string
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string | null
    updatedat?: Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    configid?: StringFieldUpdateOperationsInput | string
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type Bot_DescritivoCreateInput = {
    id?: string
    name: string
    descritivo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Bot_DescritivoUncheckedCreateInput = {
    id?: string
    name: string
    descritivo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Bot_DescritivoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descritivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Bot_DescritivoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descritivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Bot_DescritivoCreateManyInput = {
    id?: string
    name: string
    descritivo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Bot_DescritivoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descritivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Bot_DescritivoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    descritivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    customerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: string | null
    disputeReason?: string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    customerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: string | null
    disputeReason?: string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    customerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: string | null
    disputeReason?: string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstanceCreateInput = {
    id?: string
    instanceName: string
    connectionStatus?: string
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutInstancesInput
    mediaStats?: MediaStatsCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsCreateNestedOneWithoutInstanceInput
    Campaign?: CampaignCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateInput = {
    id?: string
    instanceName: string
    connectionStatus?: string
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    mediaStats?: MediaStatsUncheckedCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsUncheckedCreateNestedOneWithoutInstanceInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutInstancesNestedInput
    mediaStats?: MediaStatsUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUpdateOneWithoutInstanceNestedInput
    Campaign?: CampaignUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    mediaStats?: MediaStatsUncheckedUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateOneWithoutInstanceNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceCreateManyInput = {
    id?: string
    instanceName: string
    connectionStatus?: string
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InstanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InstanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MediaStatsCreateInput = {
    id?: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutMediaStatsInput
    warmupStatsReceived?: WarmupStatsCreateNestedManyWithoutMediaReceivedInput
    warmupStatsSent?: WarmupStatsCreateNestedManyWithoutMediaStatsInput
  }

  export type MediaStatsUncheckedCreateInput = {
    id?: string
    instanceName: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warmupStatsReceived?: WarmupStatsUncheckedCreateNestedManyWithoutMediaReceivedInput
    warmupStatsSent?: WarmupStatsUncheckedCreateNestedManyWithoutMediaStatsInput
  }

  export type MediaStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutMediaStatsNestedInput
    warmupStatsReceived?: WarmupStatsUpdateManyWithoutMediaReceivedNestedInput
    warmupStatsSent?: WarmupStatsUpdateManyWithoutMediaStatsNestedInput
  }

  export type MediaStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warmupStatsReceived?: WarmupStatsUncheckedUpdateManyWithoutMediaReceivedNestedInput
    warmupStatsSent?: WarmupStatsUncheckedUpdateManyWithoutMediaStatsNestedInput
  }

  export type MediaStatsCreateManyInput = {
    id?: string
    instanceName: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarmupStatsCreateInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutWarmupStatsInput
    mediaReceived?: MediaStatsCreateNestedOneWithoutWarmupStatsReceivedInput
    mediaStats?: MediaStatsCreateNestedOneWithoutWarmupStatsSentInput
    user: UserCreateNestedOneWithoutWarmupStatsInput
  }

  export type WarmupStatsUncheckedCreateInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
    mediaReceivedId?: string | null
  }

  export type WarmupStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutWarmupStatsNestedInput
    mediaReceived?: MediaStatsUpdateOneWithoutWarmupStatsReceivedNestedInput
    mediaStats?: MediaStatsUpdateOneWithoutWarmupStatsSentNestedInput
    user?: UserUpdateOneRequiredWithoutWarmupStatsNestedInput
  }

  export type WarmupStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarmupStatsCreateManyInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
    mediaReceivedId?: string | null
  }

  export type WarmupStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarmupStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    instance: InstanceCreateNestedOneWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    instance?: InstanceUpdateOneRequiredWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMessageCreateInput = {
    id?: string
    type: string
    content: string
    order: number
    caption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMessagesInput
  }

  export type CampaignMessageUncheckedCreateInput = {
    id?: string
    campaignId: string
    type: string
    content: string
    order: number
    caption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type CampaignMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMessageCreateManyInput = {
    id?: string
    campaignId: string
    type: string
    content: string
    order: number
    caption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLeadCreateInput = {
    id?: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messageLogs?: MessageLogCreateNestedManyWithoutCampaignLeadInput
    campaign: CampaignCreateNestedOneWithoutLeadsInput
  }

  export type CampaignLeadUncheckedCreateInput = {
    id?: string
    campaignId: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messageLogs?: MessageLogUncheckedCreateNestedManyWithoutCampaignLeadInput
  }

  export type CampaignLeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageLogs?: MessageLogUpdateManyWithoutCampaignLeadNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type CampaignLeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageLogs?: MessageLogUncheckedUpdateManyWithoutCampaignLeadNestedInput
  }

  export type CampaignLeadCreateManyInput = {
    id?: string
    campaignId: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignLeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignStatisticsCreateInput = {
    id?: string
    totalLeads?: number
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutStatisticsInput
  }

  export type CampaignStatisticsUncheckedCreateInput = {
    id?: string
    campaignId: string
    totalLeads?: number
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignStatisticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutStatisticsNestedInput
  }

  export type CampaignStatisticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignStatisticsCreateManyInput = {
    id?: string
    campaignId: string
    totalLeads?: number
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignStatisticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignStatisticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLogCreateInput = {
    id?: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMessageLogInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutMessageLogsInput
    lead: LeadCreateNestedOneWithoutMessageLogInput
  }

  export type MessageLogUncheckedCreateInput = {
    id?: string
    campaignId: string
    leadId: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutMessageLogsInput
  }

  export type MessageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMessageLogNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutMessageLogsNestedInput
    lead?: LeadUpdateOneRequiredWithoutMessageLogNestedInput
  }

  export type MessageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutMessageLogsNestedInput
  }

  export type MessageLogCreateManyInput = {
    id?: string
    campaignId: string
    leadId: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type CompaniesUnitesListRelationFilter = {
    every?: CompaniesUnitesWhereInput
    some?: CompaniesUnitesWhereInput
    none?: CompaniesUnitesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompaniesUnitesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type InstanceListRelationFilter = {
    every?: InstanceWhereInput
    some?: InstanceWhereInput
    none?: InstanceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type WarmupStatsListRelationFilter = {
    every?: WarmupStatsWhereInput
    some?: WarmupStatsWhereInput
    none?: WarmupStatsWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type InstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarmupStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    profile?: SortOrder
    phone?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeSubscriptionStatus?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatleadCompanyId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
    features?: SortOrder
    support?: SortOrder
    trialEndDate?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    profile?: SortOrder
    phone?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeSubscriptionStatus?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatleadCompanyId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
    support?: SortOrder
    trialEndDate?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    profile?: SortOrder
    phone?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeSubscriptionStatus?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatleadCompanyId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
    support?: SortOrder
    trialEndDate?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableListFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompaniesUnitesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    productdefault?: SortOrder
    campaignstatus?: SortOrder
    enablecuration?: SortOrder
    enabletosendustolead?: SortOrder
    enabled?: SortOrder
    isconversationia?: SortOrder
    campaignnumberbusiness?: SortOrder
    whatsappprovider?: SortOrder
    enabletosendprovider?: SortOrder
    enabletosecondcallprovider?: SortOrder
    integrationconfiguration?: SortOrder
    integrationname?: SortOrder
    templatelistvars?: SortOrder
    metaconfiguration?: SortOrder
    messageperruns?: SortOrder
    notifyconfiguration?: SortOrder
    updatedAt?: SortOrder
    whitelabel_config?: SortOrder
    whatleadCompanyId?: SortOrder
  }

  export type CompaniesUnitesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    productdefault?: SortOrder
    campaignstatus?: SortOrder
    enablecuration?: SortOrder
    enabletosendustolead?: SortOrder
    enabled?: SortOrder
    isconversationia?: SortOrder
    campaignnumberbusiness?: SortOrder
    whatsappprovider?: SortOrder
    enabletosendprovider?: SortOrder
    enabletosecondcallprovider?: SortOrder
    integrationname?: SortOrder
    updatedAt?: SortOrder
    whitelabel_config?: SortOrder
    whatleadCompanyId?: SortOrder
  }

  export type CompaniesUnitesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    productdefault?: SortOrder
    campaignstatus?: SortOrder
    enablecuration?: SortOrder
    enabletosendustolead?: SortOrder
    enabled?: SortOrder
    isconversationia?: SortOrder
    campaignnumberbusiness?: SortOrder
    whatsappprovider?: SortOrder
    enabletosendprovider?: SortOrder
    enabletosecondcallprovider?: SortOrder
    integrationname?: SortOrder
    updatedAt?: SortOrder
    whitelabel_config?: SortOrder
    whatleadCompanyId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MessageLogListRelationFilter = {
    every?: MessageLogWhereInput
    some?: MessageLogWhereInput
    none?: MessageLogWhereInput
  }

  export type CompaniesUnitesScalarRelationFilter = {
    is?: CompaniesUnitesWhereInput
    isNot?: CompaniesUnitesWhereInput
  }

  export type MessageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    externalid?: SortOrder
    sourceid?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    lastmessagesent?: SortOrder
    stepsecondcalltemplate?: SortOrder
    stepnointeraction?: SortOrder
    nointeractionquantity?: SortOrder
    accepttemplate?: SortOrder
    acceptsecondtemplate?: SortOrder
    status?: SortOrder
    dialog?: SortOrder
    configid?: SortOrder
    whitelabelconfig?: SortOrder
    lastintent?: SortOrder
    broker?: SortOrder
    origin?: SortOrder
    send?: SortOrder
    sendAt?: SortOrder
    isBusinessAutoResponder?: SortOrder
    startmessage?: SortOrder
    schedulingdata?: SortOrder
    productchoosebyclient?: SortOrder
    productid?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
    curation?: SortOrder
  }

  export type LeadAvgOrderByAggregateInput = {
    stepsecondcalltemplate?: SortOrder
    stepnointeraction?: SortOrder
    nointeractionquantity?: SortOrder
    productid?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    externalid?: SortOrder
    sourceid?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    lastmessagesent?: SortOrder
    stepsecondcalltemplate?: SortOrder
    stepnointeraction?: SortOrder
    nointeractionquantity?: SortOrder
    accepttemplate?: SortOrder
    acceptsecondtemplate?: SortOrder
    status?: SortOrder
    configid?: SortOrder
    whitelabelconfig?: SortOrder
    lastintent?: SortOrder
    broker?: SortOrder
    origin?: SortOrder
    send?: SortOrder
    sendAt?: SortOrder
    isBusinessAutoResponder?: SortOrder
    startmessage?: SortOrder
    schedulingdata?: SortOrder
    productchoosebyclient?: SortOrder
    productid?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    externalid?: SortOrder
    sourceid?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    lastmessagesent?: SortOrder
    stepsecondcalltemplate?: SortOrder
    stepnointeraction?: SortOrder
    nointeractionquantity?: SortOrder
    accepttemplate?: SortOrder
    acceptsecondtemplate?: SortOrder
    status?: SortOrder
    configid?: SortOrder
    whitelabelconfig?: SortOrder
    lastintent?: SortOrder
    broker?: SortOrder
    origin?: SortOrder
    send?: SortOrder
    sendAt?: SortOrder
    isBusinessAutoResponder?: SortOrder
    startmessage?: SortOrder
    schedulingdata?: SortOrder
    productchoosebyclient?: SortOrder
    productid?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
  }

  export type LeadSumOrderByAggregateInput = {
    stepsecondcalltemplate?: SortOrder
    stepnointeraction?: SortOrder
    nointeractionquantity?: SortOrder
    productid?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Bot_DescritivoCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    descritivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Bot_DescritivoMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    descritivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Bot_DescritivoMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    descritivo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    metadata?: SortOrder
    disputeStatus?: SortOrder
    disputeReason?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    disputeStatus?: SortOrder
    disputeReason?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    disputeStatus?: SortOrder
    disputeReason?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type MediaStatsListRelationFilter = {
    every?: MediaStatsWhereInput
    some?: MediaStatsWhereInput
    none?: MediaStatsWhereInput
  }

  export type WarmupStatsNullableScalarRelationFilter = {
    is?: WarmupStatsWhereInput | null
    isNot?: WarmupStatsWhereInput | null
  }

  export type MediaStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstanceCountOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    connectionStatus?: SortOrder
    number?: SortOrder
    ownerJid?: SortOrder
    profilePicUrl?: SortOrder
    integration?: SortOrder
    token?: SortOrder
    clientName?: SortOrder
    profileName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disconnectedAt?: SortOrder
    disconnectionObject?: SortOrder
    disconnectionReasonCode?: SortOrder
    proxyConfig?: SortOrder
    typebot?: SortOrder
  }

  export type InstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    connectionStatus?: SortOrder
    number?: SortOrder
    ownerJid?: SortOrder
    profilePicUrl?: SortOrder
    integration?: SortOrder
    token?: SortOrder
    clientName?: SortOrder
    profileName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disconnectedAt?: SortOrder
    disconnectionReasonCode?: SortOrder
  }

  export type InstanceMinOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    connectionStatus?: SortOrder
    number?: SortOrder
    ownerJid?: SortOrder
    profilePicUrl?: SortOrder
    integration?: SortOrder
    token?: SortOrder
    clientName?: SortOrder
    profileName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disconnectedAt?: SortOrder
    disconnectionReasonCode?: SortOrder
  }

  export type InstanceScalarRelationFilter = {
    is?: InstanceWhereInput
    isNot?: InstanceWhereInput
  }

  export type MediaStatsCountOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    date?: SortOrder
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    isReceived?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaStatsAvgOrderByAggregateInput = {
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
  }

  export type MediaStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    date?: SortOrder
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    isReceived?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaStatsMinOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    date?: SortOrder
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    isReceived?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaStatsSumOrderByAggregateInput = {
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
  }

  export type MediaStatsNullableScalarRelationFilter = {
    is?: MediaStatsWhereInput | null
    isNot?: MediaStatsWhereInput | null
  }

  export type WarmupStatsCountOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    lastActive?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrder
    progress?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaStatsId?: SortOrder
    mediaReceivedId?: SortOrder
  }

  export type WarmupStatsAvgOrderByAggregateInput = {
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    progress?: SortOrder
  }

  export type WarmupStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    lastActive?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrder
    progress?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaStatsId?: SortOrder
    mediaReceivedId?: SortOrder
  }

  export type WarmupStatsMinOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    lastActive?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrder
    progress?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaStatsId?: SortOrder
    mediaReceivedId?: SortOrder
  }

  export type WarmupStatsSumOrderByAggregateInput = {
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    progress?: SortOrder
  }

  export type CampaignLeadListRelationFilter = {
    every?: CampaignLeadWhereInput
    some?: CampaignLeadWhereInput
    none?: CampaignLeadWhereInput
  }

  export type CampaignMessageListRelationFilter = {
    every?: CampaignMessageWhereInput
    some?: CampaignMessageWhereInput
    none?: CampaignMessageWhereInput
  }

  export type CampaignStatisticsNullableScalarRelationFilter = {
    is?: CampaignStatisticsWhereInput | null
    isNot?: CampaignStatisticsWhereInput | null
  }

  export type CampaignLeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
    scheduledDate?: SortOrder
    scheduledStatus?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    pausedAt?: SortOrder
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    userId?: SortOrder
    instanceName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
    scheduledDate?: SortOrder
    scheduledStatus?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    pausedAt?: SortOrder
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    userId?: SortOrder
    instanceName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
    scheduledDate?: SortOrder
    scheduledStatus?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    pausedAt?: SortOrder
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    userId?: SortOrder
    instanceName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
  }

  export type CampaignScalarRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignMessageCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMessageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CampaignMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMessageMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMessageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CampaignLeadCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignLeadMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignLeadMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignStatisticsCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignStatisticsAvgOrderByAggregateInput = {
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
  }

  export type CampaignStatisticsMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignStatisticsMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignStatisticsSumOrderByAggregateInput = {
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
  }

  export type LeadScalarRelationFilter = {
    is?: LeadWhereInput
    isNot?: LeadWhereInput
  }

  export type MessageLogMessageIdMessageDateCompoundUniqueInput = {
    messageId: string
    messageDate: Date | string
  }

  export type MessageLogCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    messageId?: SortOrder
    messageDate?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    status?: SortOrder
    statusHistory?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    messageId?: SortOrder
    messageDate?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageLogMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    leadId?: SortOrder
    messageId?: SortOrder
    messageDate?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CompaniesUnitesCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompaniesUnitesCreateWithoutCompanyInput, CompaniesUnitesUncheckedCreateWithoutCompanyInput> | CompaniesUnitesCreateWithoutCompanyInput[] | CompaniesUnitesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompaniesUnitesCreateOrConnectWithoutCompanyInput | CompaniesUnitesCreateOrConnectWithoutCompanyInput[]
    createMany?: CompaniesUnitesCreateManyCompanyInputEnvelope
    connect?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CompaniesUnitesUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompaniesUnitesCreateWithoutCompanyInput, CompaniesUnitesUncheckedCreateWithoutCompanyInput> | CompaniesUnitesCreateWithoutCompanyInput[] | CompaniesUnitesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompaniesUnitesCreateOrConnectWithoutCompanyInput | CompaniesUnitesCreateOrConnectWithoutCompanyInput[]
    createMany?: CompaniesUnitesCreateManyCompanyInputEnvelope
    connect?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CompaniesUnitesUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompaniesUnitesCreateWithoutCompanyInput, CompaniesUnitesUncheckedCreateWithoutCompanyInput> | CompaniesUnitesCreateWithoutCompanyInput[] | CompaniesUnitesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompaniesUnitesCreateOrConnectWithoutCompanyInput | CompaniesUnitesCreateOrConnectWithoutCompanyInput[]
    upsert?: CompaniesUnitesUpsertWithWhereUniqueWithoutCompanyInput | CompaniesUnitesUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompaniesUnitesCreateManyCompanyInputEnvelope
    set?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    disconnect?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    delete?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    connect?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    update?: CompaniesUnitesUpdateWithWhereUniqueWithoutCompanyInput | CompaniesUnitesUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompaniesUnitesUpdateManyWithWhereWithoutCompanyInput | CompaniesUnitesUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompaniesUnitesScalarWhereInput | CompaniesUnitesScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CompaniesUnitesUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompaniesUnitesCreateWithoutCompanyInput, CompaniesUnitesUncheckedCreateWithoutCompanyInput> | CompaniesUnitesCreateWithoutCompanyInput[] | CompaniesUnitesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompaniesUnitesCreateOrConnectWithoutCompanyInput | CompaniesUnitesCreateOrConnectWithoutCompanyInput[]
    upsert?: CompaniesUnitesUpsertWithWhereUniqueWithoutCompanyInput | CompaniesUnitesUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompaniesUnitesCreateManyCompanyInputEnvelope
    set?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    disconnect?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    delete?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    connect?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    update?: CompaniesUnitesUpdateWithWhereUniqueWithoutCompanyInput | CompaniesUnitesUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompaniesUnitesUpdateManyWithWhereWithoutCompanyInput | CompaniesUnitesUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompaniesUnitesScalarWhereInput | CompaniesUnitesScalarWhereInput[]
  }

  export type UserCreatefeaturesInput = {
    set: string[]
  }

  export type InstanceCreateNestedManyWithoutUserInput = {
    create?: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput> | InstanceCreateWithoutUserInput[] | InstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutUserInput | InstanceCreateOrConnectWithoutUserInput[]
    createMany?: InstanceCreateManyUserInputEnvelope
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type WarmupStatsCreateNestedManyWithoutUserInput = {
    create?: XOR<WarmupStatsCreateWithoutUserInput, WarmupStatsUncheckedCreateWithoutUserInput> | WarmupStatsCreateWithoutUserInput[] | WarmupStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutUserInput | WarmupStatsCreateOrConnectWithoutUserInput[]
    createMany?: WarmupStatsCreateManyUserInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutWhatleadUserInput = {
    create?: XOR<CompanyCreateWithoutWhatleadUserInput, CompanyUncheckedCreateWithoutWhatleadUserInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWhatleadUserInput
    connect?: CompanyWhereUniqueInput
  }

  export type InstanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput> | InstanceCreateWithoutUserInput[] | InstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutUserInput | InstanceCreateOrConnectWithoutUserInput[]
    createMany?: InstanceCreateManyUserInputEnvelope
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type WarmupStatsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WarmupStatsCreateWithoutUserInput, WarmupStatsUncheckedCreateWithoutUserInput> | WarmupStatsCreateWithoutUserInput[] | WarmupStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutUserInput | WarmupStatsCreateOrConnectWithoutUserInput[]
    createMany?: WarmupStatsCreateManyUserInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type InstanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput> | InstanceCreateWithoutUserInput[] | InstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutUserInput | InstanceCreateOrConnectWithoutUserInput[]
    upsert?: InstanceUpsertWithWhereUniqueWithoutUserInput | InstanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstanceCreateManyUserInputEnvelope
    set?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    disconnect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    delete?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    update?: InstanceUpdateWithWhereUniqueWithoutUserInput | InstanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstanceUpdateManyWithWhereWithoutUserInput | InstanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type WarmupStatsUpdateManyWithoutUserNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutUserInput, WarmupStatsUncheckedCreateWithoutUserInput> | WarmupStatsCreateWithoutUserInput[] | WarmupStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutUserInput | WarmupStatsCreateOrConnectWithoutUserInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutUserInput | WarmupStatsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WarmupStatsCreateManyUserInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutUserInput | WarmupStatsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutUserInput | WarmupStatsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput = {
    create?: XOR<CompanyCreateWithoutWhatleadUserInput, CompanyUncheckedCreateWithoutWhatleadUserInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWhatleadUserInput
    upsert?: CompanyUpsertWithoutWhatleadUserInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutWhatleadUserInput, CompanyUpdateWithoutWhatleadUserInput>, CompanyUncheckedUpdateWithoutWhatleadUserInput>
  }

  export type InstanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput> | InstanceCreateWithoutUserInput[] | InstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutUserInput | InstanceCreateOrConnectWithoutUserInput[]
    upsert?: InstanceUpsertWithWhereUniqueWithoutUserInput | InstanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstanceCreateManyUserInputEnvelope
    set?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    disconnect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    delete?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    update?: InstanceUpdateWithWhereUniqueWithoutUserInput | InstanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstanceUpdateManyWithWhereWithoutUserInput | InstanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type WarmupStatsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutUserInput, WarmupStatsUncheckedCreateWithoutUserInput> | WarmupStatsCreateWithoutUserInput[] | WarmupStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutUserInput | WarmupStatsCreateOrConnectWithoutUserInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutUserInput | WarmupStatsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WarmupStatsCreateManyUserInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutUserInput | WarmupStatsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutUserInput | WarmupStatsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CompaniesUnitesCreatetemplatelistvarsInput = {
    set: InputJsonValue[]
  }

  export type CompaniesUnitesCreatemessageperrunsInput = {
    set: InputJsonValue[]
  }

  export type LeadCreateNestedManyWithoutConfigInput = {
    create?: XOR<LeadCreateWithoutConfigInput, LeadUncheckedCreateWithoutConfigInput> | LeadCreateWithoutConfigInput[] | LeadUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutConfigInput | LeadCreateOrConnectWithoutConfigInput[]
    createMany?: LeadCreateManyConfigInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutWhatleadparceiroconfigsInput = {
    create?: XOR<CompanyCreateWithoutWhatleadparceiroconfigsInput, CompanyUncheckedCreateWithoutWhatleadparceiroconfigsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWhatleadparceiroconfigsInput
    connect?: CompanyWhereUniqueInput
  }

  export type LeadUncheckedCreateNestedManyWithoutConfigInput = {
    create?: XOR<LeadCreateWithoutConfigInput, LeadUncheckedCreateWithoutConfigInput> | LeadCreateWithoutConfigInput[] | LeadUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutConfigInput | LeadCreateOrConnectWithoutConfigInput[]
    createMany?: LeadCreateManyConfigInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type CompaniesUnitesUpdatetemplatelistvarsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type CompaniesUnitesUpdatemessageperrunsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type LeadUpdateManyWithoutConfigNestedInput = {
    create?: XOR<LeadCreateWithoutConfigInput, LeadUncheckedCreateWithoutConfigInput> | LeadCreateWithoutConfigInput[] | LeadUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutConfigInput | LeadCreateOrConnectWithoutConfigInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutConfigInput | LeadUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: LeadCreateManyConfigInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutConfigInput | LeadUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutConfigInput | LeadUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutWhatleadparceiroconfigsNestedInput = {
    create?: XOR<CompanyCreateWithoutWhatleadparceiroconfigsInput, CompanyUncheckedCreateWithoutWhatleadparceiroconfigsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWhatleadparceiroconfigsInput
    upsert?: CompanyUpsertWithoutWhatleadparceiroconfigsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutWhatleadparceiroconfigsInput, CompanyUpdateWithoutWhatleadparceiroconfigsInput>, CompanyUncheckedUpdateWithoutWhatleadparceiroconfigsInput>
  }

  export type LeadUncheckedUpdateManyWithoutConfigNestedInput = {
    create?: XOR<LeadCreateWithoutConfigInput, LeadUncheckedCreateWithoutConfigInput> | LeadCreateWithoutConfigInput[] | LeadUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutConfigInput | LeadCreateOrConnectWithoutConfigInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutConfigInput | LeadUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: LeadCreateManyConfigInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutConfigInput | LeadUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutConfigInput | LeadUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type LeadCreatedialogInput = {
    set: InputJsonValue[]
  }

  export type MessageLogCreateNestedManyWithoutLeadInput = {
    create?: XOR<MessageLogCreateWithoutLeadInput, MessageLogUncheckedCreateWithoutLeadInput> | MessageLogCreateWithoutLeadInput[] | MessageLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutLeadInput | MessageLogCreateOrConnectWithoutLeadInput[]
    createMany?: MessageLogCreateManyLeadInputEnvelope
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
  }

  export type CompaniesUnitesCreateNestedOneWithoutLeadsInput = {
    create?: XOR<CompaniesUnitesCreateWithoutLeadsInput, CompaniesUnitesUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: CompaniesUnitesCreateOrConnectWithoutLeadsInput
    connect?: CompaniesUnitesWhereUniqueInput
  }

  export type MessageLogUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<MessageLogCreateWithoutLeadInput, MessageLogUncheckedCreateWithoutLeadInput> | MessageLogCreateWithoutLeadInput[] | MessageLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutLeadInput | MessageLogCreateOrConnectWithoutLeadInput[]
    createMany?: MessageLogCreateManyLeadInputEnvelope
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LeadUpdatedialogInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type MessageLogUpdateManyWithoutLeadNestedInput = {
    create?: XOR<MessageLogCreateWithoutLeadInput, MessageLogUncheckedCreateWithoutLeadInput> | MessageLogCreateWithoutLeadInput[] | MessageLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutLeadInput | MessageLogCreateOrConnectWithoutLeadInput[]
    upsert?: MessageLogUpsertWithWhereUniqueWithoutLeadInput | MessageLogUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: MessageLogCreateManyLeadInputEnvelope
    set?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    disconnect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    delete?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    update?: MessageLogUpdateWithWhereUniqueWithoutLeadInput | MessageLogUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: MessageLogUpdateManyWithWhereWithoutLeadInput | MessageLogUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
  }

  export type CompaniesUnitesUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<CompaniesUnitesCreateWithoutLeadsInput, CompaniesUnitesUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: CompaniesUnitesCreateOrConnectWithoutLeadsInput
    upsert?: CompaniesUnitesUpsertWithoutLeadsInput
    connect?: CompaniesUnitesWhereUniqueInput
    update?: XOR<XOR<CompaniesUnitesUpdateToOneWithWhereWithoutLeadsInput, CompaniesUnitesUpdateWithoutLeadsInput>, CompaniesUnitesUncheckedUpdateWithoutLeadsInput>
  }

  export type MessageLogUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<MessageLogCreateWithoutLeadInput, MessageLogUncheckedCreateWithoutLeadInput> | MessageLogCreateWithoutLeadInput[] | MessageLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutLeadInput | MessageLogCreateOrConnectWithoutLeadInput[]
    upsert?: MessageLogUpsertWithWhereUniqueWithoutLeadInput | MessageLogUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: MessageLogCreateManyLeadInputEnvelope
    set?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    disconnect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    delete?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    update?: MessageLogUpdateWithWhereUniqueWithoutLeadInput | MessageLogUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: MessageLogUpdateManyWithWhereWithoutLeadInput | MessageLogUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutInstancesInput = {
    create?: XOR<UserCreateWithoutInstancesInput, UserUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstancesInput
    connect?: UserWhereUniqueInput
  }

  export type MediaStatsCreateNestedManyWithoutInstanceInput = {
    create?: XOR<MediaStatsCreateWithoutInstanceInput, MediaStatsUncheckedCreateWithoutInstanceInput> | MediaStatsCreateWithoutInstanceInput[] | MediaStatsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MediaStatsCreateOrConnectWithoutInstanceInput | MediaStatsCreateOrConnectWithoutInstanceInput[]
    createMany?: MediaStatsCreateManyInstanceInputEnvelope
    connect?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
  }

  export type WarmupStatsCreateNestedOneWithoutInstanceInput = {
    create?: XOR<WarmupStatsCreateWithoutInstanceInput, WarmupStatsUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutInstanceInput
    connect?: WarmupStatsWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutInstanceInput = {
    create?: XOR<CampaignCreateWithoutInstanceInput, CampaignUncheckedCreateWithoutInstanceInput> | CampaignCreateWithoutInstanceInput[] | CampaignUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutInstanceInput | CampaignCreateOrConnectWithoutInstanceInput[]
    createMany?: CampaignCreateManyInstanceInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type MediaStatsUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<MediaStatsCreateWithoutInstanceInput, MediaStatsUncheckedCreateWithoutInstanceInput> | MediaStatsCreateWithoutInstanceInput[] | MediaStatsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MediaStatsCreateOrConnectWithoutInstanceInput | MediaStatsCreateOrConnectWithoutInstanceInput[]
    createMany?: MediaStatsCreateManyInstanceInputEnvelope
    connect?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
  }

  export type WarmupStatsUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<WarmupStatsCreateWithoutInstanceInput, WarmupStatsUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutInstanceInput
    connect?: WarmupStatsWhereUniqueInput
  }

  export type CampaignUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<CampaignCreateWithoutInstanceInput, CampaignUncheckedCreateWithoutInstanceInput> | CampaignCreateWithoutInstanceInput[] | CampaignUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutInstanceInput | CampaignCreateOrConnectWithoutInstanceInput[]
    createMany?: CampaignCreateManyInstanceInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutInstancesNestedInput = {
    create?: XOR<UserCreateWithoutInstancesInput, UserUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstancesInput
    upsert?: UserUpsertWithoutInstancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInstancesInput, UserUpdateWithoutInstancesInput>, UserUncheckedUpdateWithoutInstancesInput>
  }

  export type MediaStatsUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<MediaStatsCreateWithoutInstanceInput, MediaStatsUncheckedCreateWithoutInstanceInput> | MediaStatsCreateWithoutInstanceInput[] | MediaStatsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MediaStatsCreateOrConnectWithoutInstanceInput | MediaStatsCreateOrConnectWithoutInstanceInput[]
    upsert?: MediaStatsUpsertWithWhereUniqueWithoutInstanceInput | MediaStatsUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: MediaStatsCreateManyInstanceInputEnvelope
    set?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    disconnect?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    delete?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    connect?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    update?: MediaStatsUpdateWithWhereUniqueWithoutInstanceInput | MediaStatsUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: MediaStatsUpdateManyWithWhereWithoutInstanceInput | MediaStatsUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: MediaStatsScalarWhereInput | MediaStatsScalarWhereInput[]
  }

  export type WarmupStatsUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutInstanceInput, WarmupStatsUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutInstanceInput
    upsert?: WarmupStatsUpsertWithoutInstanceInput
    disconnect?: WarmupStatsWhereInput | boolean
    delete?: WarmupStatsWhereInput | boolean
    connect?: WarmupStatsWhereUniqueInput
    update?: XOR<XOR<WarmupStatsUpdateToOneWithWhereWithoutInstanceInput, WarmupStatsUpdateWithoutInstanceInput>, WarmupStatsUncheckedUpdateWithoutInstanceInput>
  }

  export type CampaignUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<CampaignCreateWithoutInstanceInput, CampaignUncheckedCreateWithoutInstanceInput> | CampaignCreateWithoutInstanceInput[] | CampaignUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutInstanceInput | CampaignCreateOrConnectWithoutInstanceInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutInstanceInput | CampaignUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: CampaignCreateManyInstanceInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutInstanceInput | CampaignUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutInstanceInput | CampaignUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type MediaStatsUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<MediaStatsCreateWithoutInstanceInput, MediaStatsUncheckedCreateWithoutInstanceInput> | MediaStatsCreateWithoutInstanceInput[] | MediaStatsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MediaStatsCreateOrConnectWithoutInstanceInput | MediaStatsCreateOrConnectWithoutInstanceInput[]
    upsert?: MediaStatsUpsertWithWhereUniqueWithoutInstanceInput | MediaStatsUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: MediaStatsCreateManyInstanceInputEnvelope
    set?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    disconnect?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    delete?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    connect?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    update?: MediaStatsUpdateWithWhereUniqueWithoutInstanceInput | MediaStatsUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: MediaStatsUpdateManyWithWhereWithoutInstanceInput | MediaStatsUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: MediaStatsScalarWhereInput | MediaStatsScalarWhereInput[]
  }

  export type WarmupStatsUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutInstanceInput, WarmupStatsUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutInstanceInput
    upsert?: WarmupStatsUpsertWithoutInstanceInput
    disconnect?: WarmupStatsWhereInput | boolean
    delete?: WarmupStatsWhereInput | boolean
    connect?: WarmupStatsWhereUniqueInput
    update?: XOR<XOR<WarmupStatsUpdateToOneWithWhereWithoutInstanceInput, WarmupStatsUpdateWithoutInstanceInput>, WarmupStatsUncheckedUpdateWithoutInstanceInput>
  }

  export type CampaignUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<CampaignCreateWithoutInstanceInput, CampaignUncheckedCreateWithoutInstanceInput> | CampaignCreateWithoutInstanceInput[] | CampaignUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutInstanceInput | CampaignCreateOrConnectWithoutInstanceInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutInstanceInput | CampaignUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: CampaignCreateManyInstanceInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutInstanceInput | CampaignUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutInstanceInput | CampaignUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type InstanceCreateNestedOneWithoutMediaStatsInput = {
    create?: XOR<InstanceCreateWithoutMediaStatsInput, InstanceUncheckedCreateWithoutMediaStatsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutMediaStatsInput
    connect?: InstanceWhereUniqueInput
  }

  export type WarmupStatsCreateNestedManyWithoutMediaReceivedInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaReceivedInput, WarmupStatsUncheckedCreateWithoutMediaReceivedInput> | WarmupStatsCreateWithoutMediaReceivedInput[] | WarmupStatsUncheckedCreateWithoutMediaReceivedInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaReceivedInput | WarmupStatsCreateOrConnectWithoutMediaReceivedInput[]
    createMany?: WarmupStatsCreateManyMediaReceivedInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type WarmupStatsCreateNestedManyWithoutMediaStatsInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaStatsInput, WarmupStatsUncheckedCreateWithoutMediaStatsInput> | WarmupStatsCreateWithoutMediaStatsInput[] | WarmupStatsUncheckedCreateWithoutMediaStatsInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaStatsInput | WarmupStatsCreateOrConnectWithoutMediaStatsInput[]
    createMany?: WarmupStatsCreateManyMediaStatsInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type WarmupStatsUncheckedCreateNestedManyWithoutMediaReceivedInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaReceivedInput, WarmupStatsUncheckedCreateWithoutMediaReceivedInput> | WarmupStatsCreateWithoutMediaReceivedInput[] | WarmupStatsUncheckedCreateWithoutMediaReceivedInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaReceivedInput | WarmupStatsCreateOrConnectWithoutMediaReceivedInput[]
    createMany?: WarmupStatsCreateManyMediaReceivedInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type WarmupStatsUncheckedCreateNestedManyWithoutMediaStatsInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaStatsInput, WarmupStatsUncheckedCreateWithoutMediaStatsInput> | WarmupStatsCreateWithoutMediaStatsInput[] | WarmupStatsUncheckedCreateWithoutMediaStatsInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaStatsInput | WarmupStatsCreateOrConnectWithoutMediaStatsInput[]
    createMany?: WarmupStatsCreateManyMediaStatsInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type InstanceUpdateOneRequiredWithoutMediaStatsNestedInput = {
    create?: XOR<InstanceCreateWithoutMediaStatsInput, InstanceUncheckedCreateWithoutMediaStatsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutMediaStatsInput
    upsert?: InstanceUpsertWithoutMediaStatsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutMediaStatsInput, InstanceUpdateWithoutMediaStatsInput>, InstanceUncheckedUpdateWithoutMediaStatsInput>
  }

  export type WarmupStatsUpdateManyWithoutMediaReceivedNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaReceivedInput, WarmupStatsUncheckedCreateWithoutMediaReceivedInput> | WarmupStatsCreateWithoutMediaReceivedInput[] | WarmupStatsUncheckedCreateWithoutMediaReceivedInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaReceivedInput | WarmupStatsCreateOrConnectWithoutMediaReceivedInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutMediaReceivedInput | WarmupStatsUpsertWithWhereUniqueWithoutMediaReceivedInput[]
    createMany?: WarmupStatsCreateManyMediaReceivedInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutMediaReceivedInput | WarmupStatsUpdateWithWhereUniqueWithoutMediaReceivedInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutMediaReceivedInput | WarmupStatsUpdateManyWithWhereWithoutMediaReceivedInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type WarmupStatsUpdateManyWithoutMediaStatsNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaStatsInput, WarmupStatsUncheckedCreateWithoutMediaStatsInput> | WarmupStatsCreateWithoutMediaStatsInput[] | WarmupStatsUncheckedCreateWithoutMediaStatsInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaStatsInput | WarmupStatsCreateOrConnectWithoutMediaStatsInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutMediaStatsInput | WarmupStatsUpsertWithWhereUniqueWithoutMediaStatsInput[]
    createMany?: WarmupStatsCreateManyMediaStatsInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutMediaStatsInput | WarmupStatsUpdateWithWhereUniqueWithoutMediaStatsInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutMediaStatsInput | WarmupStatsUpdateManyWithWhereWithoutMediaStatsInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type WarmupStatsUncheckedUpdateManyWithoutMediaReceivedNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaReceivedInput, WarmupStatsUncheckedCreateWithoutMediaReceivedInput> | WarmupStatsCreateWithoutMediaReceivedInput[] | WarmupStatsUncheckedCreateWithoutMediaReceivedInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaReceivedInput | WarmupStatsCreateOrConnectWithoutMediaReceivedInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutMediaReceivedInput | WarmupStatsUpsertWithWhereUniqueWithoutMediaReceivedInput[]
    createMany?: WarmupStatsCreateManyMediaReceivedInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutMediaReceivedInput | WarmupStatsUpdateWithWhereUniqueWithoutMediaReceivedInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutMediaReceivedInput | WarmupStatsUpdateManyWithWhereWithoutMediaReceivedInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type WarmupStatsUncheckedUpdateManyWithoutMediaStatsNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaStatsInput, WarmupStatsUncheckedCreateWithoutMediaStatsInput> | WarmupStatsCreateWithoutMediaStatsInput[] | WarmupStatsUncheckedCreateWithoutMediaStatsInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaStatsInput | WarmupStatsCreateOrConnectWithoutMediaStatsInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutMediaStatsInput | WarmupStatsUpsertWithWhereUniqueWithoutMediaStatsInput[]
    createMany?: WarmupStatsCreateManyMediaStatsInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutMediaStatsInput | WarmupStatsUpdateWithWhereUniqueWithoutMediaStatsInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutMediaStatsInput | WarmupStatsUpdateManyWithWhereWithoutMediaStatsInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type InstanceCreateNestedOneWithoutWarmupStatsInput = {
    create?: XOR<InstanceCreateWithoutWarmupStatsInput, InstanceUncheckedCreateWithoutWarmupStatsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutWarmupStatsInput
    connect?: InstanceWhereUniqueInput
  }

  export type MediaStatsCreateNestedOneWithoutWarmupStatsReceivedInput = {
    create?: XOR<MediaStatsCreateWithoutWarmupStatsReceivedInput, MediaStatsUncheckedCreateWithoutWarmupStatsReceivedInput>
    connectOrCreate?: MediaStatsCreateOrConnectWithoutWarmupStatsReceivedInput
    connect?: MediaStatsWhereUniqueInput
  }

  export type MediaStatsCreateNestedOneWithoutWarmupStatsSentInput = {
    create?: XOR<MediaStatsCreateWithoutWarmupStatsSentInput, MediaStatsUncheckedCreateWithoutWarmupStatsSentInput>
    connectOrCreate?: MediaStatsCreateOrConnectWithoutWarmupStatsSentInput
    connect?: MediaStatsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWarmupStatsInput = {
    create?: XOR<UserCreateWithoutWarmupStatsInput, UserUncheckedCreateWithoutWarmupStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWarmupStatsInput
    connect?: UserWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutWarmupStatsNestedInput = {
    create?: XOR<InstanceCreateWithoutWarmupStatsInput, InstanceUncheckedCreateWithoutWarmupStatsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutWarmupStatsInput
    upsert?: InstanceUpsertWithoutWarmupStatsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutWarmupStatsInput, InstanceUpdateWithoutWarmupStatsInput>, InstanceUncheckedUpdateWithoutWarmupStatsInput>
  }

  export type MediaStatsUpdateOneWithoutWarmupStatsReceivedNestedInput = {
    create?: XOR<MediaStatsCreateWithoutWarmupStatsReceivedInput, MediaStatsUncheckedCreateWithoutWarmupStatsReceivedInput>
    connectOrCreate?: MediaStatsCreateOrConnectWithoutWarmupStatsReceivedInput
    upsert?: MediaStatsUpsertWithoutWarmupStatsReceivedInput
    disconnect?: MediaStatsWhereInput | boolean
    delete?: MediaStatsWhereInput | boolean
    connect?: MediaStatsWhereUniqueInput
    update?: XOR<XOR<MediaStatsUpdateToOneWithWhereWithoutWarmupStatsReceivedInput, MediaStatsUpdateWithoutWarmupStatsReceivedInput>, MediaStatsUncheckedUpdateWithoutWarmupStatsReceivedInput>
  }

  export type MediaStatsUpdateOneWithoutWarmupStatsSentNestedInput = {
    create?: XOR<MediaStatsCreateWithoutWarmupStatsSentInput, MediaStatsUncheckedCreateWithoutWarmupStatsSentInput>
    connectOrCreate?: MediaStatsCreateOrConnectWithoutWarmupStatsSentInput
    upsert?: MediaStatsUpsertWithoutWarmupStatsSentInput
    disconnect?: MediaStatsWhereInput | boolean
    delete?: MediaStatsWhereInput | boolean
    connect?: MediaStatsWhereUniqueInput
    update?: XOR<XOR<MediaStatsUpdateToOneWithWhereWithoutWarmupStatsSentInput, MediaStatsUpdateWithoutWarmupStatsSentInput>, MediaStatsUncheckedUpdateWithoutWarmupStatsSentInput>
  }

  export type UserUpdateOneRequiredWithoutWarmupStatsNestedInput = {
    create?: XOR<UserCreateWithoutWarmupStatsInput, UserUncheckedCreateWithoutWarmupStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWarmupStatsInput
    upsert?: UserUpsertWithoutWarmupStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWarmupStatsInput, UserUpdateWithoutWarmupStatsInput>, UserUncheckedUpdateWithoutWarmupStatsInput>
  }

  export type MessageLogCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MessageLogCreateWithoutCampaignInput, MessageLogUncheckedCreateWithoutCampaignInput> | MessageLogCreateWithoutCampaignInput[] | MessageLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignInput | MessageLogCreateOrConnectWithoutCampaignInput[]
    createMany?: MessageLogCreateManyCampaignInputEnvelope
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
  }

  export type CampaignLeadCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput> | CampaignLeadCreateWithoutCampaignInput[] | CampaignLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutCampaignInput | CampaignLeadCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignLeadCreateManyCampaignInputEnvelope
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
  }

  export type CampaignMessageCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput> | CampaignMessageCreateWithoutCampaignInput[] | CampaignMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutCampaignInput | CampaignMessageCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignMessageCreateManyCampaignInputEnvelope
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
  }

  export type CampaignStatisticsCreateNestedOneWithoutCampaignInput = {
    create?: XOR<CampaignStatisticsCreateWithoutCampaignInput, CampaignStatisticsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignStatisticsCreateOrConnectWithoutCampaignInput
    connect?: CampaignStatisticsWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutCampaignInput = {
    create?: XOR<InstanceCreateWithoutCampaignInput, InstanceUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutCampaignInput
    connect?: InstanceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCampaignInput = {
    create?: XOR<UserCreateWithoutCampaignInput, UserUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignInput
    connect?: UserWhereUniqueInput
  }

  export type MessageLogUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MessageLogCreateWithoutCampaignInput, MessageLogUncheckedCreateWithoutCampaignInput> | MessageLogCreateWithoutCampaignInput[] | MessageLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignInput | MessageLogCreateOrConnectWithoutCampaignInput[]
    createMany?: MessageLogCreateManyCampaignInputEnvelope
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
  }

  export type CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput> | CampaignLeadCreateWithoutCampaignInput[] | CampaignLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutCampaignInput | CampaignLeadCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignLeadCreateManyCampaignInputEnvelope
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
  }

  export type CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput> | CampaignMessageCreateWithoutCampaignInput[] | CampaignMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutCampaignInput | CampaignMessageCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignMessageCreateManyCampaignInputEnvelope
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
  }

  export type CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput = {
    create?: XOR<CampaignStatisticsCreateWithoutCampaignInput, CampaignStatisticsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignStatisticsCreateOrConnectWithoutCampaignInput
    connect?: CampaignStatisticsWhereUniqueInput
  }

  export type MessageLogUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MessageLogCreateWithoutCampaignInput, MessageLogUncheckedCreateWithoutCampaignInput> | MessageLogCreateWithoutCampaignInput[] | MessageLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignInput | MessageLogCreateOrConnectWithoutCampaignInput[]
    upsert?: MessageLogUpsertWithWhereUniqueWithoutCampaignInput | MessageLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MessageLogCreateManyCampaignInputEnvelope
    set?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    disconnect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    delete?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    update?: MessageLogUpdateWithWhereUniqueWithoutCampaignInput | MessageLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MessageLogUpdateManyWithWhereWithoutCampaignInput | MessageLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
  }

  export type CampaignLeadUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput> | CampaignLeadCreateWithoutCampaignInput[] | CampaignLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutCampaignInput | CampaignLeadCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput | CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignLeadCreateManyCampaignInputEnvelope
    set?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    disconnect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    delete?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    update?: CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput | CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignLeadUpdateManyWithWhereWithoutCampaignInput | CampaignLeadUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
  }

  export type CampaignMessageUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput> | CampaignMessageCreateWithoutCampaignInput[] | CampaignMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutCampaignInput | CampaignMessageCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput | CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignMessageCreateManyCampaignInputEnvelope
    set?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    disconnect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    delete?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    update?: CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput | CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignMessageUpdateManyWithWhereWithoutCampaignInput | CampaignMessageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
  }

  export type CampaignStatisticsUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<CampaignStatisticsCreateWithoutCampaignInput, CampaignStatisticsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignStatisticsCreateOrConnectWithoutCampaignInput
    upsert?: CampaignStatisticsUpsertWithoutCampaignInput
    disconnect?: CampaignStatisticsWhereInput | boolean
    delete?: CampaignStatisticsWhereInput | boolean
    connect?: CampaignStatisticsWhereUniqueInput
    update?: XOR<XOR<CampaignStatisticsUpdateToOneWithWhereWithoutCampaignInput, CampaignStatisticsUpdateWithoutCampaignInput>, CampaignStatisticsUncheckedUpdateWithoutCampaignInput>
  }

  export type InstanceUpdateOneRequiredWithoutCampaignNestedInput = {
    create?: XOR<InstanceCreateWithoutCampaignInput, InstanceUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutCampaignInput
    upsert?: InstanceUpsertWithoutCampaignInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutCampaignInput, InstanceUpdateWithoutCampaignInput>, InstanceUncheckedUpdateWithoutCampaignInput>
  }

  export type UserUpdateOneRequiredWithoutCampaignNestedInput = {
    create?: XOR<UserCreateWithoutCampaignInput, UserUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignInput
    upsert?: UserUpsertWithoutCampaignInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignInput, UserUpdateWithoutCampaignInput>, UserUncheckedUpdateWithoutCampaignInput>
  }

  export type MessageLogUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MessageLogCreateWithoutCampaignInput, MessageLogUncheckedCreateWithoutCampaignInput> | MessageLogCreateWithoutCampaignInput[] | MessageLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignInput | MessageLogCreateOrConnectWithoutCampaignInput[]
    upsert?: MessageLogUpsertWithWhereUniqueWithoutCampaignInput | MessageLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MessageLogCreateManyCampaignInputEnvelope
    set?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    disconnect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    delete?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    update?: MessageLogUpdateWithWhereUniqueWithoutCampaignInput | MessageLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MessageLogUpdateManyWithWhereWithoutCampaignInput | MessageLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
  }

  export type CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput> | CampaignLeadCreateWithoutCampaignInput[] | CampaignLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutCampaignInput | CampaignLeadCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput | CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignLeadCreateManyCampaignInputEnvelope
    set?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    disconnect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    delete?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    update?: CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput | CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignLeadUpdateManyWithWhereWithoutCampaignInput | CampaignLeadUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
  }

  export type CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput> | CampaignMessageCreateWithoutCampaignInput[] | CampaignMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutCampaignInput | CampaignMessageCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput | CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignMessageCreateManyCampaignInputEnvelope
    set?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    disconnect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    delete?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    update?: CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput | CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignMessageUpdateManyWithWhereWithoutCampaignInput | CampaignMessageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
  }

  export type CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<CampaignStatisticsCreateWithoutCampaignInput, CampaignStatisticsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignStatisticsCreateOrConnectWithoutCampaignInput
    upsert?: CampaignStatisticsUpsertWithoutCampaignInput
    disconnect?: CampaignStatisticsWhereInput | boolean
    delete?: CampaignStatisticsWhereInput | boolean
    connect?: CampaignStatisticsWhereUniqueInput
    update?: XOR<XOR<CampaignStatisticsUpdateToOneWithWhereWithoutCampaignInput, CampaignStatisticsUpdateWithoutCampaignInput>, CampaignStatisticsUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignCreateNestedOneWithoutMessagesInput = {
    create?: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessagesInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessagesInput
    upsert?: CampaignUpsertWithoutMessagesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMessagesInput, CampaignUpdateWithoutMessagesInput>, CampaignUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageLogCreateNestedManyWithoutCampaignLeadInput = {
    create?: XOR<MessageLogCreateWithoutCampaignLeadInput, MessageLogUncheckedCreateWithoutCampaignLeadInput> | MessageLogCreateWithoutCampaignLeadInput[] | MessageLogUncheckedCreateWithoutCampaignLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignLeadInput | MessageLogCreateOrConnectWithoutCampaignLeadInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
  }

  export type CampaignCreateNestedOneWithoutLeadsInput = {
    create?: XOR<CampaignCreateWithoutLeadsInput, CampaignUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLeadsInput
    connect?: CampaignWhereUniqueInput
  }

  export type MessageLogUncheckedCreateNestedManyWithoutCampaignLeadInput = {
    create?: XOR<MessageLogCreateWithoutCampaignLeadInput, MessageLogUncheckedCreateWithoutCampaignLeadInput> | MessageLogCreateWithoutCampaignLeadInput[] | MessageLogUncheckedCreateWithoutCampaignLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignLeadInput | MessageLogCreateOrConnectWithoutCampaignLeadInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
  }

  export type MessageLogUpdateManyWithoutCampaignLeadNestedInput = {
    create?: XOR<MessageLogCreateWithoutCampaignLeadInput, MessageLogUncheckedCreateWithoutCampaignLeadInput> | MessageLogCreateWithoutCampaignLeadInput[] | MessageLogUncheckedCreateWithoutCampaignLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignLeadInput | MessageLogCreateOrConnectWithoutCampaignLeadInput[]
    upsert?: MessageLogUpsertWithWhereUniqueWithoutCampaignLeadInput | MessageLogUpsertWithWhereUniqueWithoutCampaignLeadInput[]
    set?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    disconnect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    delete?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    update?: MessageLogUpdateWithWhereUniqueWithoutCampaignLeadInput | MessageLogUpdateWithWhereUniqueWithoutCampaignLeadInput[]
    updateMany?: MessageLogUpdateManyWithWhereWithoutCampaignLeadInput | MessageLogUpdateManyWithWhereWithoutCampaignLeadInput[]
    deleteMany?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
  }

  export type CampaignUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<CampaignCreateWithoutLeadsInput, CampaignUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLeadsInput
    upsert?: CampaignUpsertWithoutLeadsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutLeadsInput, CampaignUpdateWithoutLeadsInput>, CampaignUncheckedUpdateWithoutLeadsInput>
  }

  export type MessageLogUncheckedUpdateManyWithoutCampaignLeadNestedInput = {
    create?: XOR<MessageLogCreateWithoutCampaignLeadInput, MessageLogUncheckedCreateWithoutCampaignLeadInput> | MessageLogCreateWithoutCampaignLeadInput[] | MessageLogUncheckedCreateWithoutCampaignLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignLeadInput | MessageLogCreateOrConnectWithoutCampaignLeadInput[]
    upsert?: MessageLogUpsertWithWhereUniqueWithoutCampaignLeadInput | MessageLogUpsertWithWhereUniqueWithoutCampaignLeadInput[]
    set?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    disconnect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    delete?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    update?: MessageLogUpdateWithWhereUniqueWithoutCampaignLeadInput | MessageLogUpdateWithWhereUniqueWithoutCampaignLeadInput[]
    updateMany?: MessageLogUpdateManyWithWhereWithoutCampaignLeadInput | MessageLogUpdateManyWithWhereWithoutCampaignLeadInput[]
    deleteMany?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutStatisticsInput = {
    create?: XOR<CampaignCreateWithoutStatisticsInput, CampaignUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutStatisticsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutStatisticsNestedInput = {
    create?: XOR<CampaignCreateWithoutStatisticsInput, CampaignUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutStatisticsInput
    upsert?: CampaignUpsertWithoutStatisticsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutStatisticsInput, CampaignUpdateWithoutStatisticsInput>, CampaignUncheckedUpdateWithoutStatisticsInput>
  }

  export type MessageLogCreatestatusHistoryInput = {
    set: InputJsonValue[]
  }

  export type CampaignCreateNestedOneWithoutMessageLogInput = {
    create?: XOR<CampaignCreateWithoutMessageLogInput, CampaignUncheckedCreateWithoutMessageLogInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessageLogInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignLeadCreateNestedManyWithoutMessageLogsInput = {
    create?: XOR<CampaignLeadCreateWithoutMessageLogsInput, CampaignLeadUncheckedCreateWithoutMessageLogsInput> | CampaignLeadCreateWithoutMessageLogsInput[] | CampaignLeadUncheckedCreateWithoutMessageLogsInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutMessageLogsInput | CampaignLeadCreateOrConnectWithoutMessageLogsInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
  }

  export type LeadCreateNestedOneWithoutMessageLogInput = {
    create?: XOR<LeadCreateWithoutMessageLogInput, LeadUncheckedCreateWithoutMessageLogInput>
    connectOrCreate?: LeadCreateOrConnectWithoutMessageLogInput
    connect?: LeadWhereUniqueInput
  }

  export type CampaignLeadUncheckedCreateNestedManyWithoutMessageLogsInput = {
    create?: XOR<CampaignLeadCreateWithoutMessageLogsInput, CampaignLeadUncheckedCreateWithoutMessageLogsInput> | CampaignLeadCreateWithoutMessageLogsInput[] | CampaignLeadUncheckedCreateWithoutMessageLogsInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutMessageLogsInput | CampaignLeadCreateOrConnectWithoutMessageLogsInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
  }

  export type MessageLogUpdatestatusHistoryInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type CampaignUpdateOneRequiredWithoutMessageLogNestedInput = {
    create?: XOR<CampaignCreateWithoutMessageLogInput, CampaignUncheckedCreateWithoutMessageLogInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessageLogInput
    upsert?: CampaignUpsertWithoutMessageLogInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMessageLogInput, CampaignUpdateWithoutMessageLogInput>, CampaignUncheckedUpdateWithoutMessageLogInput>
  }

  export type CampaignLeadUpdateManyWithoutMessageLogsNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutMessageLogsInput, CampaignLeadUncheckedCreateWithoutMessageLogsInput> | CampaignLeadCreateWithoutMessageLogsInput[] | CampaignLeadUncheckedCreateWithoutMessageLogsInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutMessageLogsInput | CampaignLeadCreateOrConnectWithoutMessageLogsInput[]
    upsert?: CampaignLeadUpsertWithWhereUniqueWithoutMessageLogsInput | CampaignLeadUpsertWithWhereUniqueWithoutMessageLogsInput[]
    set?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    disconnect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    delete?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    update?: CampaignLeadUpdateWithWhereUniqueWithoutMessageLogsInput | CampaignLeadUpdateWithWhereUniqueWithoutMessageLogsInput[]
    updateMany?: CampaignLeadUpdateManyWithWhereWithoutMessageLogsInput | CampaignLeadUpdateManyWithWhereWithoutMessageLogsInput[]
    deleteMany?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
  }

  export type LeadUpdateOneRequiredWithoutMessageLogNestedInput = {
    create?: XOR<LeadCreateWithoutMessageLogInput, LeadUncheckedCreateWithoutMessageLogInput>
    connectOrCreate?: LeadCreateOrConnectWithoutMessageLogInput
    upsert?: LeadUpsertWithoutMessageLogInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutMessageLogInput, LeadUpdateWithoutMessageLogInput>, LeadUncheckedUpdateWithoutMessageLogInput>
  }

  export type CampaignLeadUncheckedUpdateManyWithoutMessageLogsNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutMessageLogsInput, CampaignLeadUncheckedCreateWithoutMessageLogsInput> | CampaignLeadCreateWithoutMessageLogsInput[] | CampaignLeadUncheckedCreateWithoutMessageLogsInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutMessageLogsInput | CampaignLeadCreateOrConnectWithoutMessageLogsInput[]
    upsert?: CampaignLeadUpsertWithWhereUniqueWithoutMessageLogsInput | CampaignLeadUpsertWithWhereUniqueWithoutMessageLogsInput[]
    set?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    disconnect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    delete?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    update?: CampaignLeadUpdateWithWhereUniqueWithoutMessageLogsInput | CampaignLeadUpdateWithWhereUniqueWithoutMessageLogsInput[]
    updateMany?: CampaignLeadUpdateManyWithWhereWithoutMessageLogsInput | CampaignLeadUpdateManyWithWhereWithoutMessageLogsInput[]
    deleteMany?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompaniesUnitesCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    leads?: LeadCreateNestedManyWithoutConfigInput
  }

  export type CompaniesUnitesUncheckedCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    leads?: LeadUncheckedCreateNestedManyWithoutConfigInput
  }

  export type CompaniesUnitesCreateOrConnectWithoutCompanyInput = {
    where: CompaniesUnitesWhereUniqueInput
    create: XOR<CompaniesUnitesCreateWithoutCompanyInput, CompaniesUnitesUncheckedCreateWithoutCompanyInput>
  }

  export type CompaniesUnitesCreateManyCompanyInputEnvelope = {
    data: CompaniesUnitesCreateManyCompanyInput | CompaniesUnitesCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profile?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionStatus?: StringNullableFilter<"User"> | string | null
    active?: BoolNullableFilter<"User"> | boolean | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    whatleadCompanyId?: StringFilter<"User"> | string
    plan?: StringFilter<"User"> | string
    status?: BoolFilter<"User"> | boolean
    maxInstances?: IntFilter<"User"> | number
    messagesPerDay?: IntFilter<"User"> | number
    features?: StringNullableListFilter<"User">
    support?: StringFilter<"User"> | string
    trialEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type CompaniesUnitesUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompaniesUnitesWhereUniqueInput
    update: XOR<CompaniesUnitesUpdateWithoutCompanyInput, CompaniesUnitesUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompaniesUnitesCreateWithoutCompanyInput, CompaniesUnitesUncheckedCreateWithoutCompanyInput>
  }

  export type CompaniesUnitesUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompaniesUnitesWhereUniqueInput
    data: XOR<CompaniesUnitesUpdateWithoutCompanyInput, CompaniesUnitesUncheckedUpdateWithoutCompanyInput>
  }

  export type CompaniesUnitesUpdateManyWithWhereWithoutCompanyInput = {
    where: CompaniesUnitesScalarWhereInput
    data: XOR<CompaniesUnitesUpdateManyMutationInput, CompaniesUnitesUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompaniesUnitesScalarWhereInput = {
    AND?: CompaniesUnitesScalarWhereInput | CompaniesUnitesScalarWhereInput[]
    OR?: CompaniesUnitesScalarWhereInput[]
    NOT?: CompaniesUnitesScalarWhereInput | CompaniesUnitesScalarWhereInput[]
    id?: StringFilter<"CompaniesUnites"> | string
    createdAt?: DateTimeNullableFilter<"CompaniesUnites"> | Date | string | null
    name?: StringNullableFilter<"CompaniesUnites"> | string | null
    productdefault?: StringNullableFilter<"CompaniesUnites"> | string | null
    campaignstatus?: StringNullableFilter<"CompaniesUnites"> | string | null
    enablecuration?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabletosendustolead?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabled?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    isconversationia?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    campaignnumberbusiness?: StringNullableFilter<"CompaniesUnites"> | string | null
    whatsappprovider?: StringNullableFilter<"CompaniesUnites"> | string | null
    enabletosendprovider?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabletosecondcallprovider?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    integrationconfiguration?: JsonNullableFilter<"CompaniesUnites">
    integrationname?: StringNullableFilter<"CompaniesUnites"> | string | null
    templatelistvars?: JsonNullableListFilter<"CompaniesUnites">
    metaconfiguration?: JsonNullableFilter<"CompaniesUnites">
    messageperruns?: JsonNullableListFilter<"CompaniesUnites">
    notifyconfiguration?: JsonNullableFilter<"CompaniesUnites">
    updatedAt?: DateTimeNullableFilter<"CompaniesUnites"> | Date | string | null
    whitelabel_config?: StringFilter<"CompaniesUnites"> | string
    whatleadCompanyId?: StringNullableFilter<"CompaniesUnites"> | string | null
  }

  export type InstanceCreateWithoutUserInput = {
    id?: string
    instanceName: string
    connectionStatus?: string
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    mediaStats?: MediaStatsCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsCreateNestedOneWithoutInstanceInput
    Campaign?: CampaignCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutUserInput = {
    id?: string
    instanceName: string
    connectionStatus?: string
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    mediaStats?: MediaStatsUncheckedCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsUncheckedCreateNestedOneWithoutInstanceInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutUserInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput>
  }

  export type InstanceCreateManyUserInputEnvelope = {
    data: InstanceCreateManyUserInput | InstanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    customerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: string | null
    disputeReason?: string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    customerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: string | null
    disputeReason?: string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WarmupStatsCreateWithoutUserInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutWarmupStatsInput
    mediaReceived?: MediaStatsCreateNestedOneWithoutWarmupStatsReceivedInput
    mediaStats?: MediaStatsCreateNestedOneWithoutWarmupStatsSentInput
  }

  export type WarmupStatsUncheckedCreateWithoutUserInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
    mediaReceivedId?: string | null
  }

  export type WarmupStatsCreateOrConnectWithoutUserInput = {
    where: WarmupStatsWhereUniqueInput
    create: XOR<WarmupStatsCreateWithoutUserInput, WarmupStatsUncheckedCreateWithoutUserInput>
  }

  export type WarmupStatsCreateManyUserInputEnvelope = {
    data: WarmupStatsCreateManyUserInput | WarmupStatsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    instance: InstanceCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    instanceName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutUserInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignCreateManyUserInputEnvelope = {
    data: CampaignCreateManyUserInput | CampaignCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutWhatleadUserInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadparceiroconfigs?: CompaniesUnitesCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutWhatleadUserInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadparceiroconfigs?: CompaniesUnitesUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutWhatleadUserInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutWhatleadUserInput, CompanyUncheckedCreateWithoutWhatleadUserInput>
  }

  export type InstanceUpsertWithWhereUniqueWithoutUserInput = {
    where: InstanceWhereUniqueInput
    update: XOR<InstanceUpdateWithoutUserInput, InstanceUncheckedUpdateWithoutUserInput>
    create: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput>
  }

  export type InstanceUpdateWithWhereUniqueWithoutUserInput = {
    where: InstanceWhereUniqueInput
    data: XOR<InstanceUpdateWithoutUserInput, InstanceUncheckedUpdateWithoutUserInput>
  }

  export type InstanceUpdateManyWithWhereWithoutUserInput = {
    where: InstanceScalarWhereInput
    data: XOR<InstanceUpdateManyMutationInput, InstanceUncheckedUpdateManyWithoutUserInput>
  }

  export type InstanceScalarWhereInput = {
    AND?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
    OR?: InstanceScalarWhereInput[]
    NOT?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
    id?: StringFilter<"Instance"> | string
    instanceName?: StringFilter<"Instance"> | string
    connectionStatus?: StringFilter<"Instance"> | string
    number?: StringNullableFilter<"Instance"> | string | null
    ownerJid?: StringNullableFilter<"Instance"> | string | null
    profilePicUrl?: StringNullableFilter<"Instance"> | string | null
    integration?: StringFilter<"Instance"> | string
    token?: StringNullableFilter<"Instance"> | string | null
    clientName?: StringNullableFilter<"Instance"> | string | null
    profileName?: StringNullableFilter<"Instance"> | string | null
    userId?: StringFilter<"Instance"> | string
    createdAt?: DateTimeFilter<"Instance"> | Date | string
    updatedAt?: DateTimeFilter<"Instance"> | Date | string
    disconnectedAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    disconnectionObject?: JsonNullableFilter<"Instance">
    disconnectionReasonCode?: StringNullableFilter<"Instance"> | string | null
    proxyConfig?: JsonNullableFilter<"Instance">
    typebot?: JsonNullableFilter<"Instance">
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    stripePaymentId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    disputeStatus?: StringNullableFilter<"Payment"> | string | null
    disputeReason?: StringNullableFilter<"Payment"> | string | null
    cancelReason?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    userId?: StringNullableFilter<"Payment"> | string | null
  }

  export type WarmupStatsUpsertWithWhereUniqueWithoutUserInput = {
    where: WarmupStatsWhereUniqueInput
    update: XOR<WarmupStatsUpdateWithoutUserInput, WarmupStatsUncheckedUpdateWithoutUserInput>
    create: XOR<WarmupStatsCreateWithoutUserInput, WarmupStatsUncheckedCreateWithoutUserInput>
  }

  export type WarmupStatsUpdateWithWhereUniqueWithoutUserInput = {
    where: WarmupStatsWhereUniqueInput
    data: XOR<WarmupStatsUpdateWithoutUserInput, WarmupStatsUncheckedUpdateWithoutUserInput>
  }

  export type WarmupStatsUpdateManyWithWhereWithoutUserInput = {
    where: WarmupStatsScalarWhereInput
    data: XOR<WarmupStatsUpdateManyMutationInput, WarmupStatsUncheckedUpdateManyWithoutUserInput>
  }

  export type WarmupStatsScalarWhereInput = {
    AND?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
    OR?: WarmupStatsScalarWhereInput[]
    NOT?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
    id?: StringFilter<"WarmupStats"> | string
    instanceName?: StringFilter<"WarmupStats"> | string
    status?: StringFilter<"WarmupStats"> | string
    messagesSent?: IntFilter<"WarmupStats"> | number
    messagesReceived?: IntFilter<"WarmupStats"> | number
    warmupTime?: IntFilter<"WarmupStats"> | number
    lastActive?: DateTimeFilter<"WarmupStats"> | Date | string
    startTime?: DateTimeNullableFilter<"WarmupStats"> | Date | string | null
    pauseTime?: DateTimeNullableFilter<"WarmupStats"> | Date | string | null
    progress?: IntFilter<"WarmupStats"> | number
    userId?: StringFilter<"WarmupStats"> | string
    createdAt?: DateTimeFilter<"WarmupStats"> | Date | string
    updatedAt?: DateTimeFilter<"WarmupStats"> | Date | string
    mediaStatsId?: StringNullableFilter<"WarmupStats"> | string | null
    mediaReceivedId?: StringNullableFilter<"WarmupStats"> | string | null
  }

  export type CampaignUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
  }

  export type CampaignUpdateManyWithWhereWithoutUserInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    status?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    scheduledDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    scheduledStatus?: StringNullableFilter<"Campaign"> | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    progress?: IntFilter<"Campaign"> | number
    minDelay?: IntFilter<"Campaign"> | number
    maxDelay?: IntFilter<"Campaign"> | number
    userId?: StringFilter<"Campaign"> | string
    instanceName?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type CompanyUpsertWithoutWhatleadUserInput = {
    update: XOR<CompanyUpdateWithoutWhatleadUserInput, CompanyUncheckedUpdateWithoutWhatleadUserInput>
    create: XOR<CompanyCreateWithoutWhatleadUserInput, CompanyUncheckedCreateWithoutWhatleadUserInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutWhatleadUserInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutWhatleadUserInput, CompanyUncheckedUpdateWithoutWhatleadUserInput>
  }

  export type CompanyUpdateWithoutWhatleadUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadparceiroconfigs?: CompaniesUnitesUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutWhatleadUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadparceiroconfigs?: CompaniesUnitesUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type LeadCreateWithoutConfigInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string | null
    updatedat?: Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutConfigInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string | null
    updatedat?: Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutConfigInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutConfigInput, LeadUncheckedCreateWithoutConfigInput>
  }

  export type LeadCreateManyConfigInputEnvelope = {
    data: LeadCreateManyConfigInput | LeadCreateManyConfigInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutWhatleadparceiroconfigsInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    WhatleadUser?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutWhatleadparceiroconfigsInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    WhatleadUser?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutWhatleadparceiroconfigsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutWhatleadparceiroconfigsInput, CompanyUncheckedCreateWithoutWhatleadparceiroconfigsInput>
  }

  export type LeadUpsertWithWhereUniqueWithoutConfigInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutConfigInput, LeadUncheckedUpdateWithoutConfigInput>
    create: XOR<LeadCreateWithoutConfigInput, LeadUncheckedCreateWithoutConfigInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutConfigInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutConfigInput, LeadUncheckedUpdateWithoutConfigInput>
  }

  export type LeadUpdateManyWithWhereWithoutConfigInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutConfigInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    externalid?: StringNullableFilter<"Lead"> | string | null
    sourceid?: StringNullableFilter<"Lead"> | string | null
    name?: StringFilter<"Lead"> | string
    phone?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    lastmessagesent?: DateTimeNullableFilter<"Lead"> | Date | string | null
    stepsecondcalltemplate?: IntNullableFilter<"Lead"> | number | null
    stepnointeraction?: IntNullableFilter<"Lead"> | number | null
    nointeractionquantity?: IntNullableFilter<"Lead"> | number | null
    accepttemplate?: BoolNullableFilter<"Lead"> | boolean | null
    acceptsecondtemplate?: BoolNullableFilter<"Lead"> | boolean | null
    status?: StringNullableFilter<"Lead"> | string | null
    dialog?: JsonNullableListFilter<"Lead">
    configid?: StringFilter<"Lead"> | string
    whitelabelconfig?: StringFilter<"Lead"> | string
    lastintent?: StringNullableFilter<"Lead"> | string | null
    broker?: StringNullableFilter<"Lead"> | string | null
    origin?: StringNullableFilter<"Lead"> | string | null
    send?: BoolNullableFilter<"Lead"> | boolean | null
    sendAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    isBusinessAutoResponder?: BoolNullableFilter<"Lead"> | boolean | null
    startmessage?: DateTimeNullableFilter<"Lead"> | Date | string | null
    schedulingdata?: StringNullableFilter<"Lead"> | string | null
    productchoosebyclient?: StringNullableFilter<"Lead"> | string | null
    productid?: IntNullableFilter<"Lead"> | number | null
    createdat?: DateTimeNullableFilter<"Lead"> | Date | string | null
    updatedat?: DateTimeNullableFilter<"Lead"> | Date | string | null
    curation?: JsonNullableFilter<"Lead">
  }

  export type CompanyUpsertWithoutWhatleadparceiroconfigsInput = {
    update: XOR<CompanyUpdateWithoutWhatleadparceiroconfigsInput, CompanyUncheckedUpdateWithoutWhatleadparceiroconfigsInput>
    create: XOR<CompanyCreateWithoutWhatleadparceiroconfigsInput, CompanyUncheckedCreateWithoutWhatleadparceiroconfigsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutWhatleadparceiroconfigsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutWhatleadparceiroconfigsInput, CompanyUncheckedUpdateWithoutWhatleadparceiroconfigsInput>
  }

  export type CompanyUpdateWithoutWhatleadparceiroconfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WhatleadUser?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutWhatleadparceiroconfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WhatleadUser?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type MessageLogCreateWithoutLeadInput = {
    id?: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMessageLogInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutMessageLogsInput
  }

  export type MessageLogUncheckedCreateWithoutLeadInput = {
    id?: string
    campaignId: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutMessageLogsInput
  }

  export type MessageLogCreateOrConnectWithoutLeadInput = {
    where: MessageLogWhereUniqueInput
    create: XOR<MessageLogCreateWithoutLeadInput, MessageLogUncheckedCreateWithoutLeadInput>
  }

  export type MessageLogCreateManyLeadInputEnvelope = {
    data: MessageLogCreateManyLeadInput | MessageLogCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type CompaniesUnitesCreateWithoutLeadsInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    company?: CompanyCreateNestedOneWithoutWhatleadparceiroconfigsInput
  }

  export type CompaniesUnitesUncheckedCreateWithoutLeadsInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    whatleadCompanyId?: string | null
  }

  export type CompaniesUnitesCreateOrConnectWithoutLeadsInput = {
    where: CompaniesUnitesWhereUniqueInput
    create: XOR<CompaniesUnitesCreateWithoutLeadsInput, CompaniesUnitesUncheckedCreateWithoutLeadsInput>
  }

  export type MessageLogUpsertWithWhereUniqueWithoutLeadInput = {
    where: MessageLogWhereUniqueInput
    update: XOR<MessageLogUpdateWithoutLeadInput, MessageLogUncheckedUpdateWithoutLeadInput>
    create: XOR<MessageLogCreateWithoutLeadInput, MessageLogUncheckedCreateWithoutLeadInput>
  }

  export type MessageLogUpdateWithWhereUniqueWithoutLeadInput = {
    where: MessageLogWhereUniqueInput
    data: XOR<MessageLogUpdateWithoutLeadInput, MessageLogUncheckedUpdateWithoutLeadInput>
  }

  export type MessageLogUpdateManyWithWhereWithoutLeadInput = {
    where: MessageLogScalarWhereInput
    data: XOR<MessageLogUpdateManyMutationInput, MessageLogUncheckedUpdateManyWithoutLeadInput>
  }

  export type MessageLogScalarWhereInput = {
    AND?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
    OR?: MessageLogScalarWhereInput[]
    NOT?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
    id?: StringFilter<"MessageLog"> | string
    campaignId?: StringFilter<"MessageLog"> | string
    leadId?: StringFilter<"MessageLog"> | string
    messageId?: StringFilter<"MessageLog"> | string
    messageDate?: DateTimeFilter<"MessageLog"> | Date | string
    messageType?: StringFilter<"MessageLog"> | string
    content?: StringFilter<"MessageLog"> | string
    status?: StringFilter<"MessageLog"> | string
    statusHistory?: JsonNullableListFilter<"MessageLog">
    sentAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    readAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    failureReason?: StringNullableFilter<"MessageLog"> | string | null
    createdAt?: DateTimeFilter<"MessageLog"> | Date | string
    updatedAt?: DateTimeFilter<"MessageLog"> | Date | string
  }

  export type CompaniesUnitesUpsertWithoutLeadsInput = {
    update: XOR<CompaniesUnitesUpdateWithoutLeadsInput, CompaniesUnitesUncheckedUpdateWithoutLeadsInput>
    create: XOR<CompaniesUnitesCreateWithoutLeadsInput, CompaniesUnitesUncheckedCreateWithoutLeadsInput>
    where?: CompaniesUnitesWhereInput
  }

  export type CompaniesUnitesUpdateToOneWithWhereWithoutLeadsInput = {
    where?: CompaniesUnitesWhereInput
    data: XOR<CompaniesUnitesUpdateWithoutLeadsInput, CompaniesUnitesUncheckedUpdateWithoutLeadsInput>
  }

  export type CompaniesUnitesUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneWithoutWhatleadparceiroconfigsNestedInput
  }

  export type CompaniesUnitesUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    whatleadCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    instances?: InstanceCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instances?: InstanceUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInstancesInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
  }

  export type UserUncheckedCreateWithoutInstancesInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInstancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstancesInput, UserUncheckedCreateWithoutInstancesInput>
  }

  export type MediaStatsCreateWithoutInstanceInput = {
    id?: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warmupStatsReceived?: WarmupStatsCreateNestedManyWithoutMediaReceivedInput
    warmupStatsSent?: WarmupStatsCreateNestedManyWithoutMediaStatsInput
  }

  export type MediaStatsUncheckedCreateWithoutInstanceInput = {
    id?: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warmupStatsReceived?: WarmupStatsUncheckedCreateNestedManyWithoutMediaReceivedInput
    warmupStatsSent?: WarmupStatsUncheckedCreateNestedManyWithoutMediaStatsInput
  }

  export type MediaStatsCreateOrConnectWithoutInstanceInput = {
    where: MediaStatsWhereUniqueInput
    create: XOR<MediaStatsCreateWithoutInstanceInput, MediaStatsUncheckedCreateWithoutInstanceInput>
  }

  export type MediaStatsCreateManyInstanceInputEnvelope = {
    data: MediaStatsCreateManyInstanceInput | MediaStatsCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type WarmupStatsCreateWithoutInstanceInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaReceived?: MediaStatsCreateNestedOneWithoutWarmupStatsReceivedInput
    mediaStats?: MediaStatsCreateNestedOneWithoutWarmupStatsSentInput
    user: UserCreateNestedOneWithoutWarmupStatsInput
  }

  export type WarmupStatsUncheckedCreateWithoutInstanceInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
    mediaReceivedId?: string | null
  }

  export type WarmupStatsCreateOrConnectWithoutInstanceInput = {
    where: WarmupStatsWhereUniqueInput
    create: XOR<WarmupStatsCreateWithoutInstanceInput, WarmupStatsUncheckedCreateWithoutInstanceInput>
  }

  export type CampaignCreateWithoutInstanceInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutInstanceInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutInstanceInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutInstanceInput, CampaignUncheckedCreateWithoutInstanceInput>
  }

  export type CampaignCreateManyInstanceInputEnvelope = {
    data: CampaignCreateManyInstanceInput | CampaignCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInstancesInput = {
    update: XOR<UserUpdateWithoutInstancesInput, UserUncheckedUpdateWithoutInstancesInput>
    create: XOR<UserCreateWithoutInstancesInput, UserUncheckedCreateWithoutInstancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInstancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInstancesInput, UserUncheckedUpdateWithoutInstancesInput>
  }

  export type UserUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MediaStatsUpsertWithWhereUniqueWithoutInstanceInput = {
    where: MediaStatsWhereUniqueInput
    update: XOR<MediaStatsUpdateWithoutInstanceInput, MediaStatsUncheckedUpdateWithoutInstanceInput>
    create: XOR<MediaStatsCreateWithoutInstanceInput, MediaStatsUncheckedCreateWithoutInstanceInput>
  }

  export type MediaStatsUpdateWithWhereUniqueWithoutInstanceInput = {
    where: MediaStatsWhereUniqueInput
    data: XOR<MediaStatsUpdateWithoutInstanceInput, MediaStatsUncheckedUpdateWithoutInstanceInput>
  }

  export type MediaStatsUpdateManyWithWhereWithoutInstanceInput = {
    where: MediaStatsScalarWhereInput
    data: XOR<MediaStatsUpdateManyMutationInput, MediaStatsUncheckedUpdateManyWithoutInstanceInput>
  }

  export type MediaStatsScalarWhereInput = {
    AND?: MediaStatsScalarWhereInput | MediaStatsScalarWhereInput[]
    OR?: MediaStatsScalarWhereInput[]
    NOT?: MediaStatsScalarWhereInput | MediaStatsScalarWhereInput[]
    id?: StringFilter<"MediaStats"> | string
    instanceName?: StringFilter<"MediaStats"> | string
    date?: DateTimeFilter<"MediaStats"> | Date | string
    text?: IntFilter<"MediaStats"> | number
    image?: IntFilter<"MediaStats"> | number
    video?: IntFilter<"MediaStats"> | number
    audio?: IntFilter<"MediaStats"> | number
    sticker?: IntFilter<"MediaStats"> | number
    reaction?: IntFilter<"MediaStats"> | number
    isReceived?: BoolFilter<"MediaStats"> | boolean
    totalDaily?: IntFilter<"MediaStats"> | number
    totalAllTime?: IntFilter<"MediaStats"> | number
    totalSent?: IntFilter<"MediaStats"> | number
    totalReceived?: IntFilter<"MediaStats"> | number
    createdAt?: DateTimeFilter<"MediaStats"> | Date | string
    updatedAt?: DateTimeFilter<"MediaStats"> | Date | string
  }

  export type WarmupStatsUpsertWithoutInstanceInput = {
    update: XOR<WarmupStatsUpdateWithoutInstanceInput, WarmupStatsUncheckedUpdateWithoutInstanceInput>
    create: XOR<WarmupStatsCreateWithoutInstanceInput, WarmupStatsUncheckedCreateWithoutInstanceInput>
    where?: WarmupStatsWhereInput
  }

  export type WarmupStatsUpdateToOneWithWhereWithoutInstanceInput = {
    where?: WarmupStatsWhereInput
    data: XOR<WarmupStatsUpdateWithoutInstanceInput, WarmupStatsUncheckedUpdateWithoutInstanceInput>
  }

  export type WarmupStatsUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaReceived?: MediaStatsUpdateOneWithoutWarmupStatsReceivedNestedInput
    mediaStats?: MediaStatsUpdateOneWithoutWarmupStatsSentNestedInput
    user?: UserUpdateOneRequiredWithoutWarmupStatsNestedInput
  }

  export type WarmupStatsUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignUpsertWithWhereUniqueWithoutInstanceInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutInstanceInput, CampaignUncheckedUpdateWithoutInstanceInput>
    create: XOR<CampaignCreateWithoutInstanceInput, CampaignUncheckedCreateWithoutInstanceInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutInstanceInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutInstanceInput, CampaignUncheckedUpdateWithoutInstanceInput>
  }

  export type CampaignUpdateManyWithWhereWithoutInstanceInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutInstanceInput>
  }

  export type InstanceCreateWithoutMediaStatsInput = {
    id?: string
    instanceName: string
    connectionStatus?: string
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutInstancesInput
    warmupStats?: WarmupStatsCreateNestedOneWithoutInstanceInput
    Campaign?: CampaignCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutMediaStatsInput = {
    id?: string
    instanceName: string
    connectionStatus?: string
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    warmupStats?: WarmupStatsUncheckedCreateNestedOneWithoutInstanceInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutMediaStatsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutMediaStatsInput, InstanceUncheckedCreateWithoutMediaStatsInput>
  }

  export type WarmupStatsCreateWithoutMediaReceivedInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutWarmupStatsInput
    mediaStats?: MediaStatsCreateNestedOneWithoutWarmupStatsSentInput
    user: UserCreateNestedOneWithoutWarmupStatsInput
  }

  export type WarmupStatsUncheckedCreateWithoutMediaReceivedInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
  }

  export type WarmupStatsCreateOrConnectWithoutMediaReceivedInput = {
    where: WarmupStatsWhereUniqueInput
    create: XOR<WarmupStatsCreateWithoutMediaReceivedInput, WarmupStatsUncheckedCreateWithoutMediaReceivedInput>
  }

  export type WarmupStatsCreateManyMediaReceivedInputEnvelope = {
    data: WarmupStatsCreateManyMediaReceivedInput | WarmupStatsCreateManyMediaReceivedInput[]
    skipDuplicates?: boolean
  }

  export type WarmupStatsCreateWithoutMediaStatsInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutWarmupStatsInput
    mediaReceived?: MediaStatsCreateNestedOneWithoutWarmupStatsReceivedInput
    user: UserCreateNestedOneWithoutWarmupStatsInput
  }

  export type WarmupStatsUncheckedCreateWithoutMediaStatsInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaReceivedId?: string | null
  }

  export type WarmupStatsCreateOrConnectWithoutMediaStatsInput = {
    where: WarmupStatsWhereUniqueInput
    create: XOR<WarmupStatsCreateWithoutMediaStatsInput, WarmupStatsUncheckedCreateWithoutMediaStatsInput>
  }

  export type WarmupStatsCreateManyMediaStatsInputEnvelope = {
    data: WarmupStatsCreateManyMediaStatsInput | WarmupStatsCreateManyMediaStatsInput[]
    skipDuplicates?: boolean
  }

  export type InstanceUpsertWithoutMediaStatsInput = {
    update: XOR<InstanceUpdateWithoutMediaStatsInput, InstanceUncheckedUpdateWithoutMediaStatsInput>
    create: XOR<InstanceCreateWithoutMediaStatsInput, InstanceUncheckedCreateWithoutMediaStatsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutMediaStatsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutMediaStatsInput, InstanceUncheckedUpdateWithoutMediaStatsInput>
  }

  export type InstanceUpdateWithoutMediaStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutInstancesNestedInput
    warmupStats?: WarmupStatsUpdateOneWithoutInstanceNestedInput
    Campaign?: CampaignUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutMediaStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    warmupStats?: WarmupStatsUncheckedUpdateOneWithoutInstanceNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WarmupStatsUpsertWithWhereUniqueWithoutMediaReceivedInput = {
    where: WarmupStatsWhereUniqueInput
    update: XOR<WarmupStatsUpdateWithoutMediaReceivedInput, WarmupStatsUncheckedUpdateWithoutMediaReceivedInput>
    create: XOR<WarmupStatsCreateWithoutMediaReceivedInput, WarmupStatsUncheckedCreateWithoutMediaReceivedInput>
  }

  export type WarmupStatsUpdateWithWhereUniqueWithoutMediaReceivedInput = {
    where: WarmupStatsWhereUniqueInput
    data: XOR<WarmupStatsUpdateWithoutMediaReceivedInput, WarmupStatsUncheckedUpdateWithoutMediaReceivedInput>
  }

  export type WarmupStatsUpdateManyWithWhereWithoutMediaReceivedInput = {
    where: WarmupStatsScalarWhereInput
    data: XOR<WarmupStatsUpdateManyMutationInput, WarmupStatsUncheckedUpdateManyWithoutMediaReceivedInput>
  }

  export type WarmupStatsUpsertWithWhereUniqueWithoutMediaStatsInput = {
    where: WarmupStatsWhereUniqueInput
    update: XOR<WarmupStatsUpdateWithoutMediaStatsInput, WarmupStatsUncheckedUpdateWithoutMediaStatsInput>
    create: XOR<WarmupStatsCreateWithoutMediaStatsInput, WarmupStatsUncheckedCreateWithoutMediaStatsInput>
  }

  export type WarmupStatsUpdateWithWhereUniqueWithoutMediaStatsInput = {
    where: WarmupStatsWhereUniqueInput
    data: XOR<WarmupStatsUpdateWithoutMediaStatsInput, WarmupStatsUncheckedUpdateWithoutMediaStatsInput>
  }

  export type WarmupStatsUpdateManyWithWhereWithoutMediaStatsInput = {
    where: WarmupStatsScalarWhereInput
    data: XOR<WarmupStatsUpdateManyMutationInput, WarmupStatsUncheckedUpdateManyWithoutMediaStatsInput>
  }

  export type InstanceCreateWithoutWarmupStatsInput = {
    id?: string
    instanceName: string
    connectionStatus?: string
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutInstancesInput
    mediaStats?: MediaStatsCreateNestedManyWithoutInstanceInput
    Campaign?: CampaignCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutWarmupStatsInput = {
    id?: string
    instanceName: string
    connectionStatus?: string
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    mediaStats?: MediaStatsUncheckedCreateNestedManyWithoutInstanceInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutWarmupStatsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutWarmupStatsInput, InstanceUncheckedCreateWithoutWarmupStatsInput>
  }

  export type MediaStatsCreateWithoutWarmupStatsReceivedInput = {
    id?: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutMediaStatsInput
    warmupStatsSent?: WarmupStatsCreateNestedManyWithoutMediaStatsInput
  }

  export type MediaStatsUncheckedCreateWithoutWarmupStatsReceivedInput = {
    id?: string
    instanceName: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warmupStatsSent?: WarmupStatsUncheckedCreateNestedManyWithoutMediaStatsInput
  }

  export type MediaStatsCreateOrConnectWithoutWarmupStatsReceivedInput = {
    where: MediaStatsWhereUniqueInput
    create: XOR<MediaStatsCreateWithoutWarmupStatsReceivedInput, MediaStatsUncheckedCreateWithoutWarmupStatsReceivedInput>
  }

  export type MediaStatsCreateWithoutWarmupStatsSentInput = {
    id?: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutMediaStatsInput
    warmupStatsReceived?: WarmupStatsCreateNestedManyWithoutMediaReceivedInput
  }

  export type MediaStatsUncheckedCreateWithoutWarmupStatsSentInput = {
    id?: string
    instanceName: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warmupStatsReceived?: WarmupStatsUncheckedCreateNestedManyWithoutMediaReceivedInput
  }

  export type MediaStatsCreateOrConnectWithoutWarmupStatsSentInput = {
    where: MediaStatsWhereUniqueInput
    create: XOR<MediaStatsCreateWithoutWarmupStatsSentInput, MediaStatsUncheckedCreateWithoutWarmupStatsSentInput>
  }

  export type UserCreateWithoutWarmupStatsInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
  }

  export type UserUncheckedCreateWithoutWarmupStatsInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWarmupStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWarmupStatsInput, UserUncheckedCreateWithoutWarmupStatsInput>
  }

  export type InstanceUpsertWithoutWarmupStatsInput = {
    update: XOR<InstanceUpdateWithoutWarmupStatsInput, InstanceUncheckedUpdateWithoutWarmupStatsInput>
    create: XOR<InstanceCreateWithoutWarmupStatsInput, InstanceUncheckedCreateWithoutWarmupStatsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutWarmupStatsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutWarmupStatsInput, InstanceUncheckedUpdateWithoutWarmupStatsInput>
  }

  export type InstanceUpdateWithoutWarmupStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutInstancesNestedInput
    mediaStats?: MediaStatsUpdateManyWithoutInstanceNestedInput
    Campaign?: CampaignUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutWarmupStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    mediaStats?: MediaStatsUncheckedUpdateManyWithoutInstanceNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type MediaStatsUpsertWithoutWarmupStatsReceivedInput = {
    update: XOR<MediaStatsUpdateWithoutWarmupStatsReceivedInput, MediaStatsUncheckedUpdateWithoutWarmupStatsReceivedInput>
    create: XOR<MediaStatsCreateWithoutWarmupStatsReceivedInput, MediaStatsUncheckedCreateWithoutWarmupStatsReceivedInput>
    where?: MediaStatsWhereInput
  }

  export type MediaStatsUpdateToOneWithWhereWithoutWarmupStatsReceivedInput = {
    where?: MediaStatsWhereInput
    data: XOR<MediaStatsUpdateWithoutWarmupStatsReceivedInput, MediaStatsUncheckedUpdateWithoutWarmupStatsReceivedInput>
  }

  export type MediaStatsUpdateWithoutWarmupStatsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutMediaStatsNestedInput
    warmupStatsSent?: WarmupStatsUpdateManyWithoutMediaStatsNestedInput
  }

  export type MediaStatsUncheckedUpdateWithoutWarmupStatsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warmupStatsSent?: WarmupStatsUncheckedUpdateManyWithoutMediaStatsNestedInput
  }

  export type MediaStatsUpsertWithoutWarmupStatsSentInput = {
    update: XOR<MediaStatsUpdateWithoutWarmupStatsSentInput, MediaStatsUncheckedUpdateWithoutWarmupStatsSentInput>
    create: XOR<MediaStatsCreateWithoutWarmupStatsSentInput, MediaStatsUncheckedCreateWithoutWarmupStatsSentInput>
    where?: MediaStatsWhereInput
  }

  export type MediaStatsUpdateToOneWithWhereWithoutWarmupStatsSentInput = {
    where?: MediaStatsWhereInput
    data: XOR<MediaStatsUpdateWithoutWarmupStatsSentInput, MediaStatsUncheckedUpdateWithoutWarmupStatsSentInput>
  }

  export type MediaStatsUpdateWithoutWarmupStatsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutMediaStatsNestedInput
    warmupStatsReceived?: WarmupStatsUpdateManyWithoutMediaReceivedNestedInput
  }

  export type MediaStatsUncheckedUpdateWithoutWarmupStatsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warmupStatsReceived?: WarmupStatsUncheckedUpdateManyWithoutMediaReceivedNestedInput
  }

  export type UserUpsertWithoutWarmupStatsInput = {
    update: XOR<UserUpdateWithoutWarmupStatsInput, UserUncheckedUpdateWithoutWarmupStatsInput>
    create: XOR<UserCreateWithoutWarmupStatsInput, UserUncheckedCreateWithoutWarmupStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWarmupStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWarmupStatsInput, UserUncheckedUpdateWithoutWarmupStatsInput>
  }

  export type UserUpdateWithoutWarmupStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWarmupStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageLogCreateWithoutCampaignInput = {
    id?: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CampaignLead?: CampaignLeadCreateNestedManyWithoutMessageLogsInput
    lead: LeadCreateNestedOneWithoutMessageLogInput
  }

  export type MessageLogUncheckedCreateWithoutCampaignInput = {
    id?: string
    leadId: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutMessageLogsInput
  }

  export type MessageLogCreateOrConnectWithoutCampaignInput = {
    where: MessageLogWhereUniqueInput
    create: XOR<MessageLogCreateWithoutCampaignInput, MessageLogUncheckedCreateWithoutCampaignInput>
  }

  export type MessageLogCreateManyCampaignInputEnvelope = {
    data: MessageLogCreateManyCampaignInput | MessageLogCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignLeadCreateWithoutCampaignInput = {
    id?: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messageLogs?: MessageLogCreateNestedManyWithoutCampaignLeadInput
  }

  export type CampaignLeadUncheckedCreateWithoutCampaignInput = {
    id?: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messageLogs?: MessageLogUncheckedCreateNestedManyWithoutCampaignLeadInput
  }

  export type CampaignLeadCreateOrConnectWithoutCampaignInput = {
    where: CampaignLeadWhereUniqueInput
    create: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignLeadCreateManyCampaignInputEnvelope = {
    data: CampaignLeadCreateManyCampaignInput | CampaignLeadCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignMessageCreateWithoutCampaignInput = {
    id?: string
    type: string
    content: string
    order: number
    caption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignMessageUncheckedCreateWithoutCampaignInput = {
    id?: string
    type: string
    content: string
    order: number
    caption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignMessageCreateOrConnectWithoutCampaignInput = {
    where: CampaignMessageWhereUniqueInput
    create: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignMessageCreateManyCampaignInputEnvelope = {
    data: CampaignMessageCreateManyCampaignInput | CampaignMessageCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignStatisticsCreateWithoutCampaignInput = {
    id?: string
    totalLeads?: number
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignStatisticsUncheckedCreateWithoutCampaignInput = {
    id?: string
    totalLeads?: number
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignStatisticsCreateOrConnectWithoutCampaignInput = {
    where: CampaignStatisticsWhereUniqueInput
    create: XOR<CampaignStatisticsCreateWithoutCampaignInput, CampaignStatisticsUncheckedCreateWithoutCampaignInput>
  }

  export type InstanceCreateWithoutCampaignInput = {
    id?: string
    instanceName: string
    connectionStatus?: string
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutInstancesInput
    mediaStats?: MediaStatsCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutCampaignInput = {
    id?: string
    instanceName: string
    connectionStatus?: string
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    mediaStats?: MediaStatsUncheckedCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutCampaignInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutCampaignInput, InstanceUncheckedCreateWithoutCampaignInput>
  }

  export type UserCreateWithoutCampaignInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
  }

  export type UserUncheckedCreateWithoutCampaignInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCampaignInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignInput, UserUncheckedCreateWithoutCampaignInput>
  }

  export type MessageLogUpsertWithWhereUniqueWithoutCampaignInput = {
    where: MessageLogWhereUniqueInput
    update: XOR<MessageLogUpdateWithoutCampaignInput, MessageLogUncheckedUpdateWithoutCampaignInput>
    create: XOR<MessageLogCreateWithoutCampaignInput, MessageLogUncheckedCreateWithoutCampaignInput>
  }

  export type MessageLogUpdateWithWhereUniqueWithoutCampaignInput = {
    where: MessageLogWhereUniqueInput
    data: XOR<MessageLogUpdateWithoutCampaignInput, MessageLogUncheckedUpdateWithoutCampaignInput>
  }

  export type MessageLogUpdateManyWithWhereWithoutCampaignInput = {
    where: MessageLogScalarWhereInput
    data: XOR<MessageLogUpdateManyMutationInput, MessageLogUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignLeadWhereUniqueInput
    update: XOR<CampaignLeadUpdateWithoutCampaignInput, CampaignLeadUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignLeadWhereUniqueInput
    data: XOR<CampaignLeadUpdateWithoutCampaignInput, CampaignLeadUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignLeadUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignLeadScalarWhereInput
    data: XOR<CampaignLeadUpdateManyMutationInput, CampaignLeadUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignLeadScalarWhereInput = {
    AND?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
    OR?: CampaignLeadScalarWhereInput[]
    NOT?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
    id?: StringFilter<"CampaignLead"> | string
    campaignId?: StringFilter<"CampaignLead"> | string
    name?: StringNullableFilter<"CampaignLead"> | string | null
    phone?: StringFilter<"CampaignLead"> | string
    status?: StringFilter<"CampaignLead"> | string
    sentAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    readAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    failureReason?: StringNullableFilter<"CampaignLead"> | string | null
    messageId?: StringNullableFilter<"CampaignLead"> | string | null
    createdAt?: DateTimeFilter<"CampaignLead"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignLead"> | Date | string
  }

  export type CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignMessageWhereUniqueInput
    update: XOR<CampaignMessageUpdateWithoutCampaignInput, CampaignMessageUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignMessageWhereUniqueInput
    data: XOR<CampaignMessageUpdateWithoutCampaignInput, CampaignMessageUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignMessageUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignMessageScalarWhereInput
    data: XOR<CampaignMessageUpdateManyMutationInput, CampaignMessageUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignMessageScalarWhereInput = {
    AND?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
    OR?: CampaignMessageScalarWhereInput[]
    NOT?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
    id?: StringFilter<"CampaignMessage"> | string
    campaignId?: StringFilter<"CampaignMessage"> | string
    type?: StringFilter<"CampaignMessage"> | string
    content?: StringFilter<"CampaignMessage"> | string
    order?: IntFilter<"CampaignMessage"> | number
    caption?: StringNullableFilter<"CampaignMessage"> | string | null
    createdAt?: DateTimeFilter<"CampaignMessage"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignMessage"> | Date | string
  }

  export type CampaignStatisticsUpsertWithoutCampaignInput = {
    update: XOR<CampaignStatisticsUpdateWithoutCampaignInput, CampaignStatisticsUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignStatisticsCreateWithoutCampaignInput, CampaignStatisticsUncheckedCreateWithoutCampaignInput>
    where?: CampaignStatisticsWhereInput
  }

  export type CampaignStatisticsUpdateToOneWithWhereWithoutCampaignInput = {
    where?: CampaignStatisticsWhereInput
    data: XOR<CampaignStatisticsUpdateWithoutCampaignInput, CampaignStatisticsUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignStatisticsUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignStatisticsUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstanceUpsertWithoutCampaignInput = {
    update: XOR<InstanceUpdateWithoutCampaignInput, InstanceUncheckedUpdateWithoutCampaignInput>
    create: XOR<InstanceCreateWithoutCampaignInput, InstanceUncheckedCreateWithoutCampaignInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutCampaignInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutCampaignInput, InstanceUncheckedUpdateWithoutCampaignInput>
  }

  export type InstanceUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutInstancesNestedInput
    mediaStats?: MediaStatsUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    mediaStats?: MediaStatsUncheckedUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type UserUpsertWithoutCampaignInput = {
    update: XOR<UserUpdateWithoutCampaignInput, UserUncheckedUpdateWithoutCampaignInput>
    create: XOR<UserCreateWithoutCampaignInput, UserUncheckedCreateWithoutCampaignInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignInput, UserUncheckedUpdateWithoutCampaignInput>
  }

  export type UserUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    instance: InstanceCreateNestedOneWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMessagesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
  }

  export type CampaignUpsertWithoutMessagesInput = {
    update: XOR<CampaignUpdateWithoutMessagesInput, CampaignUncheckedUpdateWithoutMessagesInput>
    create: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMessagesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMessagesInput, CampaignUncheckedUpdateWithoutMessagesInput>
  }

  export type CampaignUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    instance?: InstanceUpdateOneRequiredWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
  }

  export type MessageLogCreateWithoutCampaignLeadInput = {
    id?: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMessageLogInput
    lead: LeadCreateNestedOneWithoutMessageLogInput
  }

  export type MessageLogUncheckedCreateWithoutCampaignLeadInput = {
    id?: string
    campaignId: string
    leadId: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageLogCreateOrConnectWithoutCampaignLeadInput = {
    where: MessageLogWhereUniqueInput
    create: XOR<MessageLogCreateWithoutCampaignLeadInput, MessageLogUncheckedCreateWithoutCampaignLeadInput>
  }

  export type CampaignCreateWithoutLeadsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    instance: InstanceCreateNestedOneWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutLeadsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutLeadsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutLeadsInput, CampaignUncheckedCreateWithoutLeadsInput>
  }

  export type MessageLogUpsertWithWhereUniqueWithoutCampaignLeadInput = {
    where: MessageLogWhereUniqueInput
    update: XOR<MessageLogUpdateWithoutCampaignLeadInput, MessageLogUncheckedUpdateWithoutCampaignLeadInput>
    create: XOR<MessageLogCreateWithoutCampaignLeadInput, MessageLogUncheckedCreateWithoutCampaignLeadInput>
  }

  export type MessageLogUpdateWithWhereUniqueWithoutCampaignLeadInput = {
    where: MessageLogWhereUniqueInput
    data: XOR<MessageLogUpdateWithoutCampaignLeadInput, MessageLogUncheckedUpdateWithoutCampaignLeadInput>
  }

  export type MessageLogUpdateManyWithWhereWithoutCampaignLeadInput = {
    where: MessageLogScalarWhereInput
    data: XOR<MessageLogUpdateManyMutationInput, MessageLogUncheckedUpdateManyWithoutCampaignLeadInput>
  }

  export type CampaignUpsertWithoutLeadsInput = {
    update: XOR<CampaignUpdateWithoutLeadsInput, CampaignUncheckedUpdateWithoutLeadsInput>
    create: XOR<CampaignCreateWithoutLeadsInput, CampaignUncheckedCreateWithoutLeadsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutLeadsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutLeadsInput, CampaignUncheckedUpdateWithoutLeadsInput>
  }

  export type CampaignUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    instance?: InstanceUpdateOneRequiredWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutStatisticsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    instance: InstanceCreateNestedOneWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutStatisticsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutStatisticsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutStatisticsInput, CampaignUncheckedCreateWithoutStatisticsInput>
  }

  export type CampaignUpsertWithoutStatisticsInput = {
    update: XOR<CampaignUpdateWithoutStatisticsInput, CampaignUncheckedUpdateWithoutStatisticsInput>
    create: XOR<CampaignCreateWithoutStatisticsInput, CampaignUncheckedCreateWithoutStatisticsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutStatisticsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutStatisticsInput, CampaignUncheckedUpdateWithoutStatisticsInput>
  }

  export type CampaignUpdateWithoutStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    instance?: InstanceUpdateOneRequiredWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutMessageLogInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    instance: InstanceCreateNestedOneWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutMessageLogInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMessageLogInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMessageLogInput, CampaignUncheckedCreateWithoutMessageLogInput>
  }

  export type CampaignLeadCreateWithoutMessageLogsInput = {
    id?: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutLeadsInput
  }

  export type CampaignLeadUncheckedCreateWithoutMessageLogsInput = {
    id?: string
    campaignId: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignLeadCreateOrConnectWithoutMessageLogsInput = {
    where: CampaignLeadWhereUniqueInput
    create: XOR<CampaignLeadCreateWithoutMessageLogsInput, CampaignLeadUncheckedCreateWithoutMessageLogsInput>
  }

  export type LeadCreateWithoutMessageLogInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string | null
    updatedat?: Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
    config: CompaniesUnitesCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutMessageLogInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    configid: string
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string | null
    updatedat?: Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LeadCreateOrConnectWithoutMessageLogInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutMessageLogInput, LeadUncheckedCreateWithoutMessageLogInput>
  }

  export type CampaignUpsertWithoutMessageLogInput = {
    update: XOR<CampaignUpdateWithoutMessageLogInput, CampaignUncheckedUpdateWithoutMessageLogInput>
    create: XOR<CampaignCreateWithoutMessageLogInput, CampaignUncheckedCreateWithoutMessageLogInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMessageLogInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMessageLogInput, CampaignUncheckedUpdateWithoutMessageLogInput>
  }

  export type CampaignUpdateWithoutMessageLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    instance?: InstanceUpdateOneRequiredWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMessageLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
  }

  export type CampaignLeadUpsertWithWhereUniqueWithoutMessageLogsInput = {
    where: CampaignLeadWhereUniqueInput
    update: XOR<CampaignLeadUpdateWithoutMessageLogsInput, CampaignLeadUncheckedUpdateWithoutMessageLogsInput>
    create: XOR<CampaignLeadCreateWithoutMessageLogsInput, CampaignLeadUncheckedCreateWithoutMessageLogsInput>
  }

  export type CampaignLeadUpdateWithWhereUniqueWithoutMessageLogsInput = {
    where: CampaignLeadWhereUniqueInput
    data: XOR<CampaignLeadUpdateWithoutMessageLogsInput, CampaignLeadUncheckedUpdateWithoutMessageLogsInput>
  }

  export type CampaignLeadUpdateManyWithWhereWithoutMessageLogsInput = {
    where: CampaignLeadScalarWhereInput
    data: XOR<CampaignLeadUpdateManyMutationInput, CampaignLeadUncheckedUpdateManyWithoutMessageLogsInput>
  }

  export type LeadUpsertWithoutMessageLogInput = {
    update: XOR<LeadUpdateWithoutMessageLogInput, LeadUncheckedUpdateWithoutMessageLogInput>
    create: XOR<LeadCreateWithoutMessageLogInput, LeadUncheckedCreateWithoutMessageLogInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutMessageLogInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutMessageLogInput, LeadUncheckedUpdateWithoutMessageLogInput>
  }

  export type LeadUpdateWithoutMessageLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
    config?: CompaniesUnitesUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutMessageLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    configid?: StringFieldUpdateOperationsInput | string
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
  }

  export type CompaniesUnitesCreateManyCompanyInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompaniesUnitesUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    leads?: LeadUpdateManyWithoutConfigNestedInput
  }

  export type CompaniesUnitesUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    leads?: LeadUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type CompaniesUnitesUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
  }

  export type InstanceCreateManyUserInput = {
    id?: string
    instanceName: string
    connectionStatus?: string
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    customerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: string | null
    disputeReason?: string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarmupStatsCreateManyUserInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
    mediaReceivedId?: string | null
  }

  export type CampaignCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    instanceName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    mediaStats?: MediaStatsUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUpdateOneWithoutInstanceNestedInput
    Campaign?: CampaignUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    mediaStats?: MediaStatsUncheckedUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateOneWithoutInstanceNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarmupStatsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutWarmupStatsNestedInput
    mediaReceived?: MediaStatsUpdateOneWithoutWarmupStatsReceivedNestedInput
    mediaStats?: MediaStatsUpdateOneWithoutWarmupStatsSentNestedInput
  }

  export type WarmupStatsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarmupStatsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    instance?: InstanceUpdateOneRequiredWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    instanceName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    instanceName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyConfigInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string | null
    updatedat?: Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LeadUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageLogCreateManyLeadInput = {
    id?: string
    campaignId: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageLogUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMessageLogNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutMessageLogsNestedInput
  }

  export type MessageLogUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutMessageLogsNestedInput
  }

  export type MessageLogUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaStatsCreateManyInstanceInput = {
    id?: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignCreateManyInstanceInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaStatsUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warmupStatsReceived?: WarmupStatsUpdateManyWithoutMediaReceivedNestedInput
    warmupStatsSent?: WarmupStatsUpdateManyWithoutMediaStatsNestedInput
  }

  export type MediaStatsUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warmupStatsReceived?: WarmupStatsUncheckedUpdateManyWithoutMediaReceivedNestedInput
    warmupStatsSent?: WarmupStatsUncheckedUpdateManyWithoutMediaStatsNestedInput
  }

  export type MediaStatsUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarmupStatsCreateManyMediaReceivedInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
  }

  export type WarmupStatsCreateManyMediaStatsInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaReceivedId?: string | null
  }

  export type WarmupStatsUpdateWithoutMediaReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutWarmupStatsNestedInput
    mediaStats?: MediaStatsUpdateOneWithoutWarmupStatsSentNestedInput
    user?: UserUpdateOneRequiredWithoutWarmupStatsNestedInput
  }

  export type WarmupStatsUncheckedUpdateWithoutMediaReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarmupStatsUncheckedUpdateManyWithoutMediaReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarmupStatsUpdateWithoutMediaStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutWarmupStatsNestedInput
    mediaReceived?: MediaStatsUpdateOneWithoutWarmupStatsReceivedNestedInput
    user?: UserUpdateOneRequiredWithoutWarmupStatsNestedInput
  }

  export type WarmupStatsUncheckedUpdateWithoutMediaStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarmupStatsUncheckedUpdateManyWithoutMediaStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageLogCreateManyCampaignInput = {
    id?: string
    leadId: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignLeadCreateManyCampaignInput = {
    id?: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignMessageCreateManyCampaignInput = {
    id?: string
    type: string
    content: string
    order: number
    caption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageLogUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CampaignLead?: CampaignLeadUpdateManyWithoutMessageLogsNestedInput
    lead?: LeadUpdateOneRequiredWithoutMessageLogNestedInput
  }

  export type MessageLogUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutMessageLogsNestedInput
  }

  export type MessageLogUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLeadUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageLogs?: MessageLogUpdateManyWithoutCampaignLeadNestedInput
  }

  export type CampaignLeadUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageLogs?: MessageLogUncheckedUpdateManyWithoutCampaignLeadNestedInput
  }

  export type CampaignLeadUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMessageUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMessageUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMessageUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLogUpdateWithoutCampaignLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMessageLogNestedInput
    lead?: LeadUpdateOneRequiredWithoutMessageLogNestedInput
  }

  export type MessageLogUncheckedUpdateWithoutCampaignLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLogUncheckedUpdateManyWithoutCampaignLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLeadUpdateWithoutMessageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type CampaignLeadUncheckedUpdateWithoutMessageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLeadUncheckedUpdateManyWithoutMessageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}