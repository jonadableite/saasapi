
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model CompaniesUnites
 * 
 */
export type CompaniesUnites = $Result.DefaultSelection<Prisma.$CompaniesUnitesPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Instance
 * 
 */
export type Instance = $Result.DefaultSelection<Prisma.$InstancePayload>
/**
 * Model MediaStats
 * 
 */
export type MediaStats = $Result.DefaultSelection<Prisma.$MediaStatsPayload>
/**
 * Model WarmupStats
 * 
 */
export type WarmupStats = $Result.DefaultSelection<Prisma.$WarmupStatsPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignDispatch
 * 
 */
export type CampaignDispatch = $Result.DefaultSelection<Prisma.$CampaignDispatchPayload>
/**
 * Model CampaignMessage
 * 
 */
export type CampaignMessage = $Result.DefaultSelection<Prisma.$CampaignMessagePayload>
/**
 * Model CampaignLead
 * 
 */
export type CampaignLead = $Result.DefaultSelection<Prisma.$CampaignLeadPayload>
/**
 * Model CampaignSchedule
 * 
 */
export type CampaignSchedule = $Result.DefaultSelection<Prisma.$CampaignSchedulePayload>
/**
 * Model CampaignStatistics
 * 
 */
export type CampaignStatistics = $Result.DefaultSelection<Prisma.$CampaignStatisticsPayload>
/**
 * Model MessageLog
 * 
 */
export type MessageLog = $Result.DefaultSelection<Prisma.$MessageLogPayload>
/**
 * Model MessageAnalytics
 * 
 */
export type MessageAnalytics = $Result.DefaultSelection<Prisma.$MessageAnalyticsPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model MessageAttachment
 * 
 */
export type MessageAttachment = $Result.DefaultSelection<Prisma.$MessageAttachmentPayload>
/**
 * Model CampaignErrorLog
 * 
 */
export type CampaignErrorLog = $Result.DefaultSelection<Prisma.$CampaignErrorLogPayload>
/**
 * Model ContactNote
 * 
 */
export type ContactNote = $Result.DefaultSelection<Prisma.$ContactNotePayload>
/**
 * Model MessageReaction
 * 
 */
export type MessageReaction = $Result.DefaultSelection<Prisma.$MessageReactionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const InstanceStatus: {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  CONNECTED: 'CONNECTED',
  DISCONNECTED: 'DISCONNECTED',
  CONNECTING: 'CONNECTING',
  OFFLINE: 'OFFLINE',
  ERROR: 'ERROR',
  RECEIVED: 'RECEIVED'
};

export type InstanceStatus = (typeof InstanceStatus)[keyof typeof InstanceStatus]


export const MessageStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  READ: 'READ',
  FAILED: 'FAILED'
};

export type MessageStatus = (typeof MessageStatus)[keyof typeof MessageStatus]

}

export type InstanceStatus = $Enums.InstanceStatus

export const InstanceStatus: typeof $Enums.InstanceStatus

export type MessageStatus = $Enums.MessageStatus

export const MessageStatus: typeof $Enums.MessageStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companiesUnites`: Exposes CRUD operations for the **CompaniesUnites** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompaniesUnites
    * const companiesUnites = await prisma.companiesUnites.findMany()
    * ```
    */
  get companiesUnites(): Prisma.CompaniesUnitesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instance`: Exposes CRUD operations for the **Instance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instances
    * const instances = await prisma.instance.findMany()
    * ```
    */
  get instance(): Prisma.InstanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mediaStats`: Exposes CRUD operations for the **MediaStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaStats
    * const mediaStats = await prisma.mediaStats.findMany()
    * ```
    */
  get mediaStats(): Prisma.MediaStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warmupStats`: Exposes CRUD operations for the **WarmupStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarmupStats
    * const warmupStats = await prisma.warmupStats.findMany()
    * ```
    */
  get warmupStats(): Prisma.WarmupStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignDispatch`: Exposes CRUD operations for the **CampaignDispatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignDispatches
    * const campaignDispatches = await prisma.campaignDispatch.findMany()
    * ```
    */
  get campaignDispatch(): Prisma.CampaignDispatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignMessage`: Exposes CRUD operations for the **CampaignMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignMessages
    * const campaignMessages = await prisma.campaignMessage.findMany()
    * ```
    */
  get campaignMessage(): Prisma.CampaignMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignLead`: Exposes CRUD operations for the **CampaignLead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignLeads
    * const campaignLeads = await prisma.campaignLead.findMany()
    * ```
    */
  get campaignLead(): Prisma.CampaignLeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignSchedule`: Exposes CRUD operations for the **CampaignSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignSchedules
    * const campaignSchedules = await prisma.campaignSchedule.findMany()
    * ```
    */
  get campaignSchedule(): Prisma.CampaignScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignStatistics`: Exposes CRUD operations for the **CampaignStatistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignStatistics
    * const campaignStatistics = await prisma.campaignStatistics.findMany()
    * ```
    */
  get campaignStatistics(): Prisma.CampaignStatisticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageLog`: Exposes CRUD operations for the **MessageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageLogs
    * const messageLogs = await prisma.messageLog.findMany()
    * ```
    */
  get messageLog(): Prisma.MessageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageAnalytics`: Exposes CRUD operations for the **MessageAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageAnalytics
    * const messageAnalytics = await prisma.messageAnalytics.findMany()
    * ```
    */
  get messageAnalytics(): Prisma.MessageAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageAttachment`: Exposes CRUD operations for the **MessageAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageAttachments
    * const messageAttachments = await prisma.messageAttachment.findMany()
    * ```
    */
  get messageAttachment(): Prisma.MessageAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignErrorLog`: Exposes CRUD operations for the **CampaignErrorLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignErrorLogs
    * const campaignErrorLogs = await prisma.campaignErrorLog.findMany()
    * ```
    */
  get campaignErrorLog(): Prisma.CampaignErrorLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactNote`: Exposes CRUD operations for the **ContactNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactNotes
    * const contactNotes = await prisma.contactNote.findMany()
    * ```
    */
  get contactNote(): Prisma.ContactNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageReaction`: Exposes CRUD operations for the **MessageReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageReactions
    * const messageReactions = await prisma.messageReaction.findMany()
    * ```
    */
  get messageReaction(): Prisma.MessageReactionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    User: 'User',
    CompaniesUnites: 'CompaniesUnites',
    Lead: 'Lead',
    Payment: 'Payment',
    Instance: 'Instance',
    MediaStats: 'MediaStats',
    WarmupStats: 'WarmupStats',
    Campaign: 'Campaign',
    CampaignDispatch: 'CampaignDispatch',
    CampaignMessage: 'CampaignMessage',
    CampaignLead: 'CampaignLead',
    CampaignSchedule: 'CampaignSchedule',
    CampaignStatistics: 'CampaignStatistics',
    MessageLog: 'MessageLog',
    MessageAnalytics: 'MessageAnalytics',
    Contact: 'Contact',
    Conversation: 'Conversation',
    Message: 'Message',
    MessageAttachment: 'MessageAttachment',
    CampaignErrorLog: 'CampaignErrorLog',
    ContactNote: 'ContactNote',
    MessageReaction: 'MessageReaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "company" | "user" | "companiesUnites" | "lead" | "payment" | "instance" | "mediaStats" | "warmupStats" | "campaign" | "campaignDispatch" | "campaignMessage" | "campaignLead" | "campaignSchedule" | "campaignStatistics" | "messageLog" | "messageAnalytics" | "contact" | "conversation" | "message" | "messageAttachment" | "campaignErrorLog" | "contactNote" | "messageReaction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      CompaniesUnites: {
        payload: Prisma.$CompaniesUnitesPayload<ExtArgs>
        fields: Prisma.CompaniesUnitesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompaniesUnitesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompaniesUnitesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>
          }
          findFirst: {
            args: Prisma.CompaniesUnitesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompaniesUnitesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>
          }
          findMany: {
            args: Prisma.CompaniesUnitesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>[]
          }
          create: {
            args: Prisma.CompaniesUnitesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>
          }
          createMany: {
            args: Prisma.CompaniesUnitesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompaniesUnitesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>[]
          }
          delete: {
            args: Prisma.CompaniesUnitesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>
          }
          update: {
            args: Prisma.CompaniesUnitesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>
          }
          deleteMany: {
            args: Prisma.CompaniesUnitesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompaniesUnitesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompaniesUnitesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>[]
          }
          upsert: {
            args: Prisma.CompaniesUnitesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompaniesUnitesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesUnitesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompaniesUnites>
          }
          groupBy: {
            args: Prisma.CompaniesUnitesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesUnitesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompaniesUnitesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesUnitesCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Instance: {
        payload: Prisma.$InstancePayload<ExtArgs>
        fields: Prisma.InstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          findFirst: {
            args: Prisma.InstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          findMany: {
            args: Prisma.InstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>[]
          }
          create: {
            args: Prisma.InstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          createMany: {
            args: Prisma.InstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>[]
          }
          delete: {
            args: Prisma.InstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          update: {
            args: Prisma.InstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          deleteMany: {
            args: Prisma.InstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>[]
          }
          upsert: {
            args: Prisma.InstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          aggregate: {
            args: Prisma.InstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstance>
          }
          groupBy: {
            args: Prisma.InstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstanceCountArgs<ExtArgs>
            result: $Utils.Optional<InstanceCountAggregateOutputType> | number
          }
        }
      }
      MediaStats: {
        payload: Prisma.$MediaStatsPayload<ExtArgs>
        fields: Prisma.MediaStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>
          }
          findFirst: {
            args: Prisma.MediaStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>
          }
          findMany: {
            args: Prisma.MediaStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>[]
          }
          create: {
            args: Prisma.MediaStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>
          }
          createMany: {
            args: Prisma.MediaStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>[]
          }
          delete: {
            args: Prisma.MediaStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>
          }
          update: {
            args: Prisma.MediaStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>
          }
          deleteMany: {
            args: Prisma.MediaStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>[]
          }
          upsert: {
            args: Prisma.MediaStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaStatsPayload>
          }
          aggregate: {
            args: Prisma.MediaStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaStats>
          }
          groupBy: {
            args: Prisma.MediaStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaStatsCountArgs<ExtArgs>
            result: $Utils.Optional<MediaStatsCountAggregateOutputType> | number
          }
        }
      }
      WarmupStats: {
        payload: Prisma.$WarmupStatsPayload<ExtArgs>
        fields: Prisma.WarmupStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarmupStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarmupStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>
          }
          findFirst: {
            args: Prisma.WarmupStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarmupStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>
          }
          findMany: {
            args: Prisma.WarmupStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>[]
          }
          create: {
            args: Prisma.WarmupStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>
          }
          createMany: {
            args: Prisma.WarmupStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarmupStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>[]
          }
          delete: {
            args: Prisma.WarmupStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>
          }
          update: {
            args: Prisma.WarmupStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>
          }
          deleteMany: {
            args: Prisma.WarmupStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarmupStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarmupStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>[]
          }
          upsert: {
            args: Prisma.WarmupStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarmupStatsPayload>
          }
          aggregate: {
            args: Prisma.WarmupStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarmupStats>
          }
          groupBy: {
            args: Prisma.WarmupStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarmupStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarmupStatsCountArgs<ExtArgs>
            result: $Utils.Optional<WarmupStatsCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignDispatch: {
        payload: Prisma.$CampaignDispatchPayload<ExtArgs>
        fields: Prisma.CampaignDispatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignDispatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignDispatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignDispatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignDispatchPayload>
          }
          findFirst: {
            args: Prisma.CampaignDispatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignDispatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignDispatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignDispatchPayload>
          }
          findMany: {
            args: Prisma.CampaignDispatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignDispatchPayload>[]
          }
          create: {
            args: Prisma.CampaignDispatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignDispatchPayload>
          }
          createMany: {
            args: Prisma.CampaignDispatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignDispatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignDispatchPayload>[]
          }
          delete: {
            args: Prisma.CampaignDispatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignDispatchPayload>
          }
          update: {
            args: Prisma.CampaignDispatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignDispatchPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDispatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignDispatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignDispatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignDispatchPayload>[]
          }
          upsert: {
            args: Prisma.CampaignDispatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignDispatchPayload>
          }
          aggregate: {
            args: Prisma.CampaignDispatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignDispatch>
          }
          groupBy: {
            args: Prisma.CampaignDispatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignDispatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignDispatchCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignDispatchCountAggregateOutputType> | number
          }
        }
      }
      CampaignMessage: {
        payload: Prisma.$CampaignMessagePayload<ExtArgs>
        fields: Prisma.CampaignMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          findFirst: {
            args: Prisma.CampaignMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          findMany: {
            args: Prisma.CampaignMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>[]
          }
          create: {
            args: Prisma.CampaignMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          createMany: {
            args: Prisma.CampaignMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>[]
          }
          delete: {
            args: Prisma.CampaignMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          update: {
            args: Prisma.CampaignMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          deleteMany: {
            args: Prisma.CampaignMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>[]
          }
          upsert: {
            args: Prisma.CampaignMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMessagePayload>
          }
          aggregate: {
            args: Prisma.CampaignMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignMessage>
          }
          groupBy: {
            args: Prisma.CampaignMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignMessageCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignMessageCountAggregateOutputType> | number
          }
        }
      }
      CampaignLead: {
        payload: Prisma.$CampaignLeadPayload<ExtArgs>
        fields: Prisma.CampaignLeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignLeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignLeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          findFirst: {
            args: Prisma.CampaignLeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignLeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          findMany: {
            args: Prisma.CampaignLeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>[]
          }
          create: {
            args: Prisma.CampaignLeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          createMany: {
            args: Prisma.CampaignLeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignLeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>[]
          }
          delete: {
            args: Prisma.CampaignLeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          update: {
            args: Prisma.CampaignLeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          deleteMany: {
            args: Prisma.CampaignLeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignLeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignLeadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>[]
          }
          upsert: {
            args: Prisma.CampaignLeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLeadPayload>
          }
          aggregate: {
            args: Prisma.CampaignLeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignLead>
          }
          groupBy: {
            args: Prisma.CampaignLeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignLeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignLeadCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignLeadCountAggregateOutputType> | number
          }
        }
      }
      CampaignSchedule: {
        payload: Prisma.$CampaignSchedulePayload<ExtArgs>
        fields: Prisma.CampaignScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSchedulePayload>
          }
          findFirst: {
            args: Prisma.CampaignScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSchedulePayload>
          }
          findMany: {
            args: Prisma.CampaignScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSchedulePayload>[]
          }
          create: {
            args: Prisma.CampaignScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSchedulePayload>
          }
          createMany: {
            args: Prisma.CampaignScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSchedulePayload>[]
          }
          delete: {
            args: Prisma.CampaignScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSchedulePayload>
          }
          update: {
            args: Prisma.CampaignScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSchedulePayload>
          }
          deleteMany: {
            args: Prisma.CampaignScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSchedulePayload>[]
          }
          upsert: {
            args: Prisma.CampaignScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSchedulePayload>
          }
          aggregate: {
            args: Prisma.CampaignScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignSchedule>
          }
          groupBy: {
            args: Prisma.CampaignScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignScheduleCountAggregateOutputType> | number
          }
        }
      }
      CampaignStatistics: {
        payload: Prisma.$CampaignStatisticsPayload<ExtArgs>
        fields: Prisma.CampaignStatisticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignStatisticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignStatisticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>
          }
          findFirst: {
            args: Prisma.CampaignStatisticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignStatisticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>
          }
          findMany: {
            args: Prisma.CampaignStatisticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>[]
          }
          create: {
            args: Prisma.CampaignStatisticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>
          }
          createMany: {
            args: Prisma.CampaignStatisticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignStatisticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>[]
          }
          delete: {
            args: Prisma.CampaignStatisticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>
          }
          update: {
            args: Prisma.CampaignStatisticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>
          }
          deleteMany: {
            args: Prisma.CampaignStatisticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignStatisticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignStatisticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>[]
          }
          upsert: {
            args: Prisma.CampaignStatisticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignStatisticsPayload>
          }
          aggregate: {
            args: Prisma.CampaignStatisticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignStatistics>
          }
          groupBy: {
            args: Prisma.CampaignStatisticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignStatisticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignStatisticsCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignStatisticsCountAggregateOutputType> | number
          }
        }
      }
      MessageLog: {
        payload: Prisma.$MessageLogPayload<ExtArgs>
        fields: Prisma.MessageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>
          }
          findFirst: {
            args: Prisma.MessageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>
          }
          findMany: {
            args: Prisma.MessageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>[]
          }
          create: {
            args: Prisma.MessageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>
          }
          createMany: {
            args: Prisma.MessageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>[]
          }
          delete: {
            args: Prisma.MessageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>
          }
          update: {
            args: Prisma.MessageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>
          }
          deleteMany: {
            args: Prisma.MessageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>[]
          }
          upsert: {
            args: Prisma.MessageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageLogPayload>
          }
          aggregate: {
            args: Prisma.MessageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageLog>
          }
          groupBy: {
            args: Prisma.MessageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageLogCountArgs<ExtArgs>
            result: $Utils.Optional<MessageLogCountAggregateOutputType> | number
          }
        }
      }
      MessageAnalytics: {
        payload: Prisma.$MessageAnalyticsPayload<ExtArgs>
        fields: Prisma.MessageAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.MessageAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAnalyticsPayload>
          }
          findMany: {
            args: Prisma.MessageAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAnalyticsPayload>[]
          }
          create: {
            args: Prisma.MessageAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAnalyticsPayload>
          }
          createMany: {
            args: Prisma.MessageAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.MessageAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAnalyticsPayload>
          }
          update: {
            args: Prisma.MessageAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.MessageAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.MessageAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.MessageAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageAnalytics>
          }
          groupBy: {
            args: Prisma.MessageAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<MessageAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageAttachment: {
        payload: Prisma.$MessageAttachmentPayload<ExtArgs>
        fields: Prisma.MessageAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          findFirst: {
            args: Prisma.MessageAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          findMany: {
            args: Prisma.MessageAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          create: {
            args: Prisma.MessageAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          createMany: {
            args: Prisma.MessageAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          delete: {
            args: Prisma.MessageAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          update: {
            args: Prisma.MessageAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.MessageAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.MessageAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageAttachmentPayload>
          }
          aggregate: {
            args: Prisma.MessageAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageAttachment>
          }
          groupBy: {
            args: Prisma.MessageAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<MessageAttachmentCountAggregateOutputType> | number
          }
        }
      }
      CampaignErrorLog: {
        payload: Prisma.$CampaignErrorLogPayload<ExtArgs>
        fields: Prisma.CampaignErrorLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignErrorLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignErrorLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignErrorLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignErrorLogPayload>
          }
          findFirst: {
            args: Prisma.CampaignErrorLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignErrorLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignErrorLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignErrorLogPayload>
          }
          findMany: {
            args: Prisma.CampaignErrorLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignErrorLogPayload>[]
          }
          create: {
            args: Prisma.CampaignErrorLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignErrorLogPayload>
          }
          createMany: {
            args: Prisma.CampaignErrorLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignErrorLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignErrorLogPayload>[]
          }
          delete: {
            args: Prisma.CampaignErrorLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignErrorLogPayload>
          }
          update: {
            args: Prisma.CampaignErrorLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignErrorLogPayload>
          }
          deleteMany: {
            args: Prisma.CampaignErrorLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignErrorLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignErrorLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignErrorLogPayload>[]
          }
          upsert: {
            args: Prisma.CampaignErrorLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignErrorLogPayload>
          }
          aggregate: {
            args: Prisma.CampaignErrorLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignErrorLog>
          }
          groupBy: {
            args: Prisma.CampaignErrorLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignErrorLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignErrorLogCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignErrorLogCountAggregateOutputType> | number
          }
        }
      }
      ContactNote: {
        payload: Prisma.$ContactNotePayload<ExtArgs>
        fields: Prisma.ContactNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>
          }
          findFirst: {
            args: Prisma.ContactNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>
          }
          findMany: {
            args: Prisma.ContactNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>[]
          }
          create: {
            args: Prisma.ContactNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>
          }
          createMany: {
            args: Prisma.ContactNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>[]
          }
          delete: {
            args: Prisma.ContactNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>
          }
          update: {
            args: Prisma.ContactNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>
          }
          deleteMany: {
            args: Prisma.ContactNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>[]
          }
          upsert: {
            args: Prisma.ContactNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactNotePayload>
          }
          aggregate: {
            args: Prisma.ContactNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactNote>
          }
          groupBy: {
            args: Prisma.ContactNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactNoteCountArgs<ExtArgs>
            result: $Utils.Optional<ContactNoteCountAggregateOutputType> | number
          }
        }
      }
      MessageReaction: {
        payload: Prisma.$MessageReactionPayload<ExtArgs>
        fields: Prisma.MessageReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>
          }
          findFirst: {
            args: Prisma.MessageReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>
          }
          findMany: {
            args: Prisma.MessageReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>[]
          }
          create: {
            args: Prisma.MessageReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>
          }
          createMany: {
            args: Prisma.MessageReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>[]
          }
          delete: {
            args: Prisma.MessageReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>
          }
          update: {
            args: Prisma.MessageReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>
          }
          deleteMany: {
            args: Prisma.MessageReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageReactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>[]
          }
          upsert: {
            args: Prisma.MessageReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReactionPayload>
          }
          aggregate: {
            args: Prisma.MessageReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageReaction>
          }
          groupBy: {
            args: Prisma.MessageReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageReactionCountArgs<ExtArgs>
            result: $Utils.Optional<MessageReactionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    company?: CompanyOmit
    user?: UserOmit
    companiesUnites?: CompaniesUnitesOmit
    lead?: LeadOmit
    payment?: PaymentOmit
    instance?: InstanceOmit
    mediaStats?: MediaStatsOmit
    warmupStats?: WarmupStatsOmit
    campaign?: CampaignOmit
    campaignDispatch?: CampaignDispatchOmit
    campaignMessage?: CampaignMessageOmit
    campaignLead?: CampaignLeadOmit
    campaignSchedule?: CampaignScheduleOmit
    campaignStatistics?: CampaignStatisticsOmit
    messageLog?: MessageLogOmit
    messageAnalytics?: MessageAnalyticsOmit
    contact?: ContactOmit
    conversation?: ConversationOmit
    message?: MessageOmit
    messageAttachment?: MessageAttachmentOmit
    campaignErrorLog?: CampaignErrorLogOmit
    contactNote?: ContactNoteOmit
    messageReaction?: MessageReactionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    WhatleadUser: number
    whatleadparceiroconfigs: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WhatleadUser?: boolean | CompanyCountOutputTypeCountWhatleadUserArgs
    whatleadparceiroconfigs?: boolean | CompanyCountOutputTypeCountWhatleadparceiroconfigsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountWhatleadUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountWhatleadparceiroconfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesUnitesWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    instances: number
    payments: number
    warmupStats: number
    Campaign: number
    CampaignLead: number
    affiliates: number
    Message: number
    Conversation: number
    contacts: number
    contactNotes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instances?: boolean | UserCountOutputTypeCountInstancesArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    warmupStats?: boolean | UserCountOutputTypeCountWarmupStatsArgs
    Campaign?: boolean | UserCountOutputTypeCountCampaignArgs
    CampaignLead?: boolean | UserCountOutputTypeCountCampaignLeadArgs
    affiliates?: boolean | UserCountOutputTypeCountAffiliatesArgs
    Message?: boolean | UserCountOutputTypeCountMessageArgs
    Conversation?: boolean | UserCountOutputTypeCountConversationArgs
    contacts?: boolean | UserCountOutputTypeCountContactsArgs
    contactNotes?: boolean | UserCountOutputTypeCountContactNotesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWarmupStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarmupStatsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignLeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLeadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAffiliatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactNoteWhereInput
  }


  /**
   * Count Type CompaniesUnitesCountOutputType
   */

  export type CompaniesUnitesCountOutputType = {
    leads: number
  }

  export type CompaniesUnitesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | CompaniesUnitesCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * CompaniesUnitesCountOutputType without action
   */
  export type CompaniesUnitesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnitesCountOutputType
     */
    select?: CompaniesUnitesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesUnitesCountOutputType without action
   */
  export type CompaniesUnitesCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    MessageLog: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageLog?: boolean | LeadCountOutputTypeCountMessageLogArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountMessageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLogWhereInput
  }


  /**
   * Count Type InstanceCountOutputType
   */

  export type InstanceCountOutputType = {
    campaigns: number
    campaignSchedules: number
    campaignDispatches: number
    warmupStats: number
    mediaStats: number
  }

  export type InstanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | InstanceCountOutputTypeCountCampaignsArgs
    campaignSchedules?: boolean | InstanceCountOutputTypeCountCampaignSchedulesArgs
    campaignDispatches?: boolean | InstanceCountOutputTypeCountCampaignDispatchesArgs
    warmupStats?: boolean | InstanceCountOutputTypeCountWarmupStatsArgs
    mediaStats?: boolean | InstanceCountOutputTypeCountMediaStatsArgs
  }

  // Custom InputTypes
  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceCountOutputType
     */
    select?: InstanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountCampaignSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignScheduleWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountCampaignDispatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignDispatchWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountWarmupStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarmupStatsWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountMediaStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaStatsWhereInput
  }


  /**
   * Count Type MediaStatsCountOutputType
   */

  export type MediaStatsCountOutputType = {
    warmupStatsReceived: number
    warmupStatsSent: number
  }

  export type MediaStatsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warmupStatsReceived?: boolean | MediaStatsCountOutputTypeCountWarmupStatsReceivedArgs
    warmupStatsSent?: boolean | MediaStatsCountOutputTypeCountWarmupStatsSentArgs
  }

  // Custom InputTypes
  /**
   * MediaStatsCountOutputType without action
   */
  export type MediaStatsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStatsCountOutputType
     */
    select?: MediaStatsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaStatsCountOutputType without action
   */
  export type MediaStatsCountOutputTypeCountWarmupStatsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarmupStatsWhereInput
  }

  /**
   * MediaStatsCountOutputType without action
   */
  export type MediaStatsCountOutputTypeCountWarmupStatsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarmupStatsWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    MessageLog: number
    leads: number
    messages: number
    dispatches: number
    CampaignErrorLog: number
    CampaignSchedule: number
    MessageAnalytics: number
    contacts: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageLog?: boolean | CampaignCountOutputTypeCountMessageLogArgs
    leads?: boolean | CampaignCountOutputTypeCountLeadsArgs
    messages?: boolean | CampaignCountOutputTypeCountMessagesArgs
    dispatches?: boolean | CampaignCountOutputTypeCountDispatchesArgs
    CampaignErrorLog?: boolean | CampaignCountOutputTypeCountCampaignErrorLogArgs
    CampaignSchedule?: boolean | CampaignCountOutputTypeCountCampaignScheduleArgs
    MessageAnalytics?: boolean | CampaignCountOutputTypeCountMessageAnalyticsArgs
    contacts?: boolean | CampaignCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMessageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLogWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLeadWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMessageWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountDispatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignDispatchWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCampaignErrorLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignErrorLogWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCampaignScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignScheduleWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMessageAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAnalyticsWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * Count Type CampaignLeadCountOutputType
   */

  export type CampaignLeadCountOutputType = {
    messageLogs: number
  }

  export type CampaignLeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messageLogs?: boolean | CampaignLeadCountOutputTypeCountMessageLogsArgs
  }

  // Custom InputTypes
  /**
   * CampaignLeadCountOutputType without action
   */
  export type CampaignLeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLeadCountOutputType
     */
    select?: CampaignLeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignLeadCountOutputType without action
   */
  export type CampaignLeadCountOutputTypeCountMessageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLogWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    campaigns: number
    conversations: number
    contactNotes: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | ContactCountOutputTypeCountCampaignsArgs
    conversations?: boolean | ContactCountOutputTypeCountConversationsArgs
    contactNotes?: boolean | ContactCountOutputTypeCountContactNotesArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountContactNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactNoteWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
    MessageReaction: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
    MessageReaction?: boolean | ConversationCountOutputTypeCountMessageReactionArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessageReactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReactionWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    attachments: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | MessageCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    active: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    WhatleadUser?: boolean | Company$WhatleadUserArgs<ExtArgs>
    whatleadparceiroconfigs?: boolean | Company$whatleadparceiroconfigsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WhatleadUser?: boolean | Company$WhatleadUserArgs<ExtArgs>
    whatleadparceiroconfigs?: boolean | Company$whatleadparceiroconfigsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      WhatleadUser: Prisma.$UserPayload<ExtArgs>[]
      whatleadparceiroconfigs: Prisma.$CompaniesUnitesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      active: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    WhatleadUser<T extends Company$WhatleadUserArgs<ExtArgs> = {}>(args?: Subset<T, Company$WhatleadUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatleadparceiroconfigs<T extends Company$whatleadparceiroconfigsArgs<ExtArgs> = {}>(args?: Subset<T, Company$whatleadparceiroconfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly active: FieldRef<"Company", 'Boolean'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.WhatleadUser
   */
  export type Company$WhatleadUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company.whatleadparceiroconfigs
   */
  export type Company$whatleadparceiroconfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    where?: CompaniesUnitesWhereInput
    orderBy?: CompaniesUnitesOrderByWithRelationInput | CompaniesUnitesOrderByWithRelationInput[]
    cursor?: CompaniesUnitesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesUnitesScalarFieldEnum | CompaniesUnitesScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    maxInstances: number | null
    messagesPerDay: number | null
  }

  export type UserSumAggregateOutputType = {
    maxInstances: number | null
    messagesPerDay: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    profile: string | null
    phone: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripeSubscriptionStatus: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    whatleadCompanyId: string | null
    plan: string | null
    status: boolean | null
    maxInstances: number | null
    messagesPerDay: number | null
    support: string | null
    trialEndDate: Date | null
    referredBy: string | null
    role: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    profile: string | null
    phone: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripeSubscriptionStatus: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    whatleadCompanyId: string | null
    plan: string | null
    status: boolean | null
    maxInstances: number | null
    messagesPerDay: number | null
    support: string | null
    trialEndDate: Date | null
    referredBy: string | null
    role: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    profile: number
    phone: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    stripeSubscriptionStatus: number
    active: number
    createdAt: number
    updatedAt: number
    whatleadCompanyId: number
    plan: number
    status: number
    maxInstances: number
    messagesPerDay: number
    features: number
    support: number
    trialEndDate: number
    referredBy: number
    role: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    maxInstances?: true
    messagesPerDay?: true
  }

  export type UserSumAggregateInputType = {
    maxInstances?: true
    messagesPerDay?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    profile?: true
    phone?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripeSubscriptionStatus?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    whatleadCompanyId?: true
    plan?: true
    status?: true
    maxInstances?: true
    messagesPerDay?: true
    support?: true
    trialEndDate?: true
    referredBy?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    profile?: true
    phone?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripeSubscriptionStatus?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    whatleadCompanyId?: true
    plan?: true
    status?: true
    maxInstances?: true
    messagesPerDay?: true
    support?: true
    trialEndDate?: true
    referredBy?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    profile?: true
    phone?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripeSubscriptionStatus?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    whatleadCompanyId?: true
    plan?: true
    status?: true
    maxInstances?: true
    messagesPerDay?: true
    features?: true
    support?: true
    trialEndDate?: true
    referredBy?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripeSubscriptionStatus: string | null
    active: boolean | null
    createdAt: Date
    updatedAt: Date
    whatleadCompanyId: string
    plan: string
    status: boolean
    maxInstances: number
    messagesPerDay: number
    features: string[]
    support: string
    trialEndDate: Date | null
    referredBy: string | null
    role: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    profile?: boolean
    phone?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripeSubscriptionStatus?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatleadCompanyId?: boolean
    plan?: boolean
    status?: boolean
    maxInstances?: boolean
    messagesPerDay?: boolean
    features?: boolean
    support?: boolean
    trialEndDate?: boolean
    referredBy?: boolean
    role?: boolean
    instances?: boolean | User$instancesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    warmupStats?: boolean | User$warmupStatsArgs<ExtArgs>
    Campaign?: boolean | User$CampaignArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    CampaignLead?: boolean | User$CampaignLeadArgs<ExtArgs>
    affiliate?: boolean | User$affiliateArgs<ExtArgs>
    affiliates?: boolean | User$affiliatesArgs<ExtArgs>
    Message?: boolean | User$MessageArgs<ExtArgs>
    Conversation?: boolean | User$ConversationArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    contactNotes?: boolean | User$contactNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    profile?: boolean
    phone?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripeSubscriptionStatus?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatleadCompanyId?: boolean
    plan?: boolean
    status?: boolean
    maxInstances?: boolean
    messagesPerDay?: boolean
    features?: boolean
    support?: boolean
    trialEndDate?: boolean
    referredBy?: boolean
    role?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    affiliate?: boolean | User$affiliateArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    profile?: boolean
    phone?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripeSubscriptionStatus?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatleadCompanyId?: boolean
    plan?: boolean
    status?: boolean
    maxInstances?: boolean
    messagesPerDay?: boolean
    features?: boolean
    support?: boolean
    trialEndDate?: boolean
    referredBy?: boolean
    role?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    affiliate?: boolean | User$affiliateArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    profile?: boolean
    phone?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripeSubscriptionStatus?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatleadCompanyId?: boolean
    plan?: boolean
    status?: boolean
    maxInstances?: boolean
    messagesPerDay?: boolean
    features?: boolean
    support?: boolean
    trialEndDate?: boolean
    referredBy?: boolean
    role?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "profile" | "phone" | "stripeCustomerId" | "stripeSubscriptionId" | "stripeSubscriptionStatus" | "active" | "createdAt" | "updatedAt" | "whatleadCompanyId" | "plan" | "status" | "maxInstances" | "messagesPerDay" | "features" | "support" | "trialEndDate" | "referredBy" | "role", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instances?: boolean | User$instancesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    warmupStats?: boolean | User$warmupStatsArgs<ExtArgs>
    Campaign?: boolean | User$CampaignArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    CampaignLead?: boolean | User$CampaignLeadArgs<ExtArgs>
    affiliate?: boolean | User$affiliateArgs<ExtArgs>
    affiliates?: boolean | User$affiliatesArgs<ExtArgs>
    Message?: boolean | User$MessageArgs<ExtArgs>
    Conversation?: boolean | User$ConversationArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    contactNotes?: boolean | User$contactNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    affiliate?: boolean | User$affiliateArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    affiliate?: boolean | User$affiliateArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      instances: Prisma.$InstancePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      warmupStats: Prisma.$WarmupStatsPayload<ExtArgs>[]
      Campaign: Prisma.$CampaignPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
      CampaignLead: Prisma.$CampaignLeadPayload<ExtArgs>[]
      affiliate: Prisma.$UserPayload<ExtArgs> | null
      affiliates: Prisma.$UserPayload<ExtArgs>[]
      Message: Prisma.$MessagePayload<ExtArgs>[]
      Conversation: Prisma.$ConversationPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      contactNotes: Prisma.$ContactNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      profile: string
      phone: string
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      stripeSubscriptionStatus: string | null
      active: boolean | null
      createdAt: Date
      updatedAt: Date
      whatleadCompanyId: string
      plan: string
      status: boolean
      maxInstances: number
      messagesPerDay: number
      features: string[]
      support: string
      trialEndDate: Date | null
      referredBy: string | null
      role: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instances<T extends User$instancesArgs<ExtArgs> = {}>(args?: Subset<T, User$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warmupStats<T extends User$warmupStatsArgs<ExtArgs> = {}>(args?: Subset<T, User$warmupStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Campaign<T extends User$CampaignArgs<ExtArgs> = {}>(args?: Subset<T, User$CampaignArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CampaignLead<T extends User$CampaignLeadArgs<ExtArgs> = {}>(args?: Subset<T, User$CampaignLeadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    affiliate<T extends User$affiliateArgs<ExtArgs> = {}>(args?: Subset<T, User$affiliateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    affiliates<T extends User$affiliatesArgs<ExtArgs> = {}>(args?: Subset<T, User$affiliatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Message<T extends User$MessageArgs<ExtArgs> = {}>(args?: Subset<T, User$MessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Conversation<T extends User$ConversationArgs<ExtArgs> = {}>(args?: Subset<T, User$ConversationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends User$contactsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contactNotes<T extends User$contactNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$contactNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly profile: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly stripeCustomerId: FieldRef<"User", 'String'>
    readonly stripeSubscriptionId: FieldRef<"User", 'String'>
    readonly stripeSubscriptionStatus: FieldRef<"User", 'String'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly whatleadCompanyId: FieldRef<"User", 'String'>
    readonly plan: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'Boolean'>
    readonly maxInstances: FieldRef<"User", 'Int'>
    readonly messagesPerDay: FieldRef<"User", 'Int'>
    readonly features: FieldRef<"User", 'String[]'>
    readonly support: FieldRef<"User", 'String'>
    readonly trialEndDate: FieldRef<"User", 'DateTime'>
    readonly referredBy: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.instances
   */
  export type User$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    where?: InstanceWhereInput
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    cursor?: InstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.warmupStats
   */
  export type User$warmupStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    where?: WarmupStatsWhereInput
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    cursor?: WarmupStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * User.Campaign
   */
  export type User$CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * User.CampaignLead
   */
  export type User$CampaignLeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    where?: CampaignLeadWhereInput
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    cursor?: CampaignLeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }

  /**
   * User.affiliate
   */
  export type User$affiliateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.affiliates
   */
  export type User$affiliatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.Message
   */
  export type User$MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.Conversation
   */
  export type User$ConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.contacts
   */
  export type User$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * User.contactNotes
   */
  export type User$contactNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    where?: ContactNoteWhereInput
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    cursor?: ContactNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactNoteScalarFieldEnum | ContactNoteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model CompaniesUnites
   */

  export type AggregateCompaniesUnites = {
    _count: CompaniesUnitesCountAggregateOutputType | null
    _min: CompaniesUnitesMinAggregateOutputType | null
    _max: CompaniesUnitesMaxAggregateOutputType | null
  }

  export type CompaniesUnitesMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    name: string | null
    productdefault: string | null
    campaignstatus: string | null
    enablecuration: boolean | null
    enabletosendustolead: boolean | null
    enabled: boolean | null
    isconversationia: boolean | null
    campaignnumberbusiness: string | null
    whatsappprovider: string | null
    enabletosendprovider: boolean | null
    enabletosecondcallprovider: boolean | null
    integrationname: string | null
    updatedAt: Date | null
    whitelabel_config: string | null
    whatleadCompanyId: string | null
  }

  export type CompaniesUnitesMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    name: string | null
    productdefault: string | null
    campaignstatus: string | null
    enablecuration: boolean | null
    enabletosendustolead: boolean | null
    enabled: boolean | null
    isconversationia: boolean | null
    campaignnumberbusiness: string | null
    whatsappprovider: string | null
    enabletosendprovider: boolean | null
    enabletosecondcallprovider: boolean | null
    integrationname: string | null
    updatedAt: Date | null
    whitelabel_config: string | null
    whatleadCompanyId: string | null
  }

  export type CompaniesUnitesCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    productdefault: number
    campaignstatus: number
    enablecuration: number
    enabletosendustolead: number
    enabled: number
    isconversationia: number
    campaignnumberbusiness: number
    whatsappprovider: number
    enabletosendprovider: number
    enabletosecondcallprovider: number
    integrationconfiguration: number
    integrationname: number
    templatelistvars: number
    metaconfiguration: number
    messageperruns: number
    notifyconfiguration: number
    updatedAt: number
    whitelabel_config: number
    whatleadCompanyId: number
    _all: number
  }


  export type CompaniesUnitesMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    productdefault?: true
    campaignstatus?: true
    enablecuration?: true
    enabletosendustolead?: true
    enabled?: true
    isconversationia?: true
    campaignnumberbusiness?: true
    whatsappprovider?: true
    enabletosendprovider?: true
    enabletosecondcallprovider?: true
    integrationname?: true
    updatedAt?: true
    whitelabel_config?: true
    whatleadCompanyId?: true
  }

  export type CompaniesUnitesMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    productdefault?: true
    campaignstatus?: true
    enablecuration?: true
    enabletosendustolead?: true
    enabled?: true
    isconversationia?: true
    campaignnumberbusiness?: true
    whatsappprovider?: true
    enabletosendprovider?: true
    enabletosecondcallprovider?: true
    integrationname?: true
    updatedAt?: true
    whitelabel_config?: true
    whatleadCompanyId?: true
  }

  export type CompaniesUnitesCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    productdefault?: true
    campaignstatus?: true
    enablecuration?: true
    enabletosendustolead?: true
    enabled?: true
    isconversationia?: true
    campaignnumberbusiness?: true
    whatsappprovider?: true
    enabletosendprovider?: true
    enabletosecondcallprovider?: true
    integrationconfiguration?: true
    integrationname?: true
    templatelistvars?: true
    metaconfiguration?: true
    messageperruns?: true
    notifyconfiguration?: true
    updatedAt?: true
    whitelabel_config?: true
    whatleadCompanyId?: true
    _all?: true
  }

  export type CompaniesUnitesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesUnites to aggregate.
     */
    where?: CompaniesUnitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUnites to fetch.
     */
    orderBy?: CompaniesUnitesOrderByWithRelationInput | CompaniesUnitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompaniesUnitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUnites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUnites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompaniesUnites
    **/
    _count?: true | CompaniesUnitesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesUnitesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesUnitesMaxAggregateInputType
  }

  export type GetCompaniesUnitesAggregateType<T extends CompaniesUnitesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompaniesUnites]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompaniesUnites[P]>
      : GetScalarType<T[P], AggregateCompaniesUnites[P]>
  }




  export type CompaniesUnitesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompaniesUnitesWhereInput
    orderBy?: CompaniesUnitesOrderByWithAggregationInput | CompaniesUnitesOrderByWithAggregationInput[]
    by: CompaniesUnitesScalarFieldEnum[] | CompaniesUnitesScalarFieldEnum
    having?: CompaniesUnitesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesUnitesCountAggregateInputType | true
    _min?: CompaniesUnitesMinAggregateInputType
    _max?: CompaniesUnitesMaxAggregateInputType
  }

  export type CompaniesUnitesGroupByOutputType = {
    id: string
    createdAt: Date | null
    name: string | null
    productdefault: string | null
    campaignstatus: string | null
    enablecuration: boolean | null
    enabletosendustolead: boolean | null
    enabled: boolean | null
    isconversationia: boolean | null
    campaignnumberbusiness: string | null
    whatsappprovider: string | null
    enabletosendprovider: boolean | null
    enabletosecondcallprovider: boolean | null
    integrationconfiguration: JsonValue | null
    integrationname: string | null
    templatelistvars: JsonValue[]
    metaconfiguration: JsonValue | null
    messageperruns: JsonValue[]
    notifyconfiguration: JsonValue | null
    updatedAt: Date | null
    whitelabel_config: string
    whatleadCompanyId: string | null
    _count: CompaniesUnitesCountAggregateOutputType | null
    _min: CompaniesUnitesMinAggregateOutputType | null
    _max: CompaniesUnitesMaxAggregateOutputType | null
  }

  type GetCompaniesUnitesGroupByPayload<T extends CompaniesUnitesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesUnitesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesUnitesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesUnitesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesUnitesGroupByOutputType[P]>
        }
      >
    >


  export type CompaniesUnitesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    productdefault?: boolean
    campaignstatus?: boolean
    enablecuration?: boolean
    enabletosendustolead?: boolean
    enabled?: boolean
    isconversationia?: boolean
    campaignnumberbusiness?: boolean
    whatsappprovider?: boolean
    enabletosendprovider?: boolean
    enabletosecondcallprovider?: boolean
    integrationconfiguration?: boolean
    integrationname?: boolean
    templatelistvars?: boolean
    metaconfiguration?: boolean
    messageperruns?: boolean
    notifyconfiguration?: boolean
    updatedAt?: boolean
    whitelabel_config?: boolean
    whatleadCompanyId?: boolean
    leads?: boolean | CompaniesUnites$leadsArgs<ExtArgs>
    company?: boolean | CompaniesUnites$companyArgs<ExtArgs>
    _count?: boolean | CompaniesUnitesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companiesUnites"]>

  export type CompaniesUnitesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    productdefault?: boolean
    campaignstatus?: boolean
    enablecuration?: boolean
    enabletosendustolead?: boolean
    enabled?: boolean
    isconversationia?: boolean
    campaignnumberbusiness?: boolean
    whatsappprovider?: boolean
    enabletosendprovider?: boolean
    enabletosecondcallprovider?: boolean
    integrationconfiguration?: boolean
    integrationname?: boolean
    templatelistvars?: boolean
    metaconfiguration?: boolean
    messageperruns?: boolean
    notifyconfiguration?: boolean
    updatedAt?: boolean
    whitelabel_config?: boolean
    whatleadCompanyId?: boolean
    company?: boolean | CompaniesUnites$companyArgs<ExtArgs>
  }, ExtArgs["result"]["companiesUnites"]>

  export type CompaniesUnitesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    productdefault?: boolean
    campaignstatus?: boolean
    enablecuration?: boolean
    enabletosendustolead?: boolean
    enabled?: boolean
    isconversationia?: boolean
    campaignnumberbusiness?: boolean
    whatsappprovider?: boolean
    enabletosendprovider?: boolean
    enabletosecondcallprovider?: boolean
    integrationconfiguration?: boolean
    integrationname?: boolean
    templatelistvars?: boolean
    metaconfiguration?: boolean
    messageperruns?: boolean
    notifyconfiguration?: boolean
    updatedAt?: boolean
    whitelabel_config?: boolean
    whatleadCompanyId?: boolean
    company?: boolean | CompaniesUnites$companyArgs<ExtArgs>
  }, ExtArgs["result"]["companiesUnites"]>

  export type CompaniesUnitesSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    productdefault?: boolean
    campaignstatus?: boolean
    enablecuration?: boolean
    enabletosendustolead?: boolean
    enabled?: boolean
    isconversationia?: boolean
    campaignnumberbusiness?: boolean
    whatsappprovider?: boolean
    enabletosendprovider?: boolean
    enabletosecondcallprovider?: boolean
    integrationconfiguration?: boolean
    integrationname?: boolean
    templatelistvars?: boolean
    metaconfiguration?: boolean
    messageperruns?: boolean
    notifyconfiguration?: boolean
    updatedAt?: boolean
    whitelabel_config?: boolean
    whatleadCompanyId?: boolean
  }

  export type CompaniesUnitesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "productdefault" | "campaignstatus" | "enablecuration" | "enabletosendustolead" | "enabled" | "isconversationia" | "campaignnumberbusiness" | "whatsappprovider" | "enabletosendprovider" | "enabletosecondcallprovider" | "integrationconfiguration" | "integrationname" | "templatelistvars" | "metaconfiguration" | "messageperruns" | "notifyconfiguration" | "updatedAt" | "whitelabel_config" | "whatleadCompanyId", ExtArgs["result"]["companiesUnites"]>
  export type CompaniesUnitesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | CompaniesUnites$leadsArgs<ExtArgs>
    company?: boolean | CompaniesUnites$companyArgs<ExtArgs>
    _count?: boolean | CompaniesUnitesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompaniesUnitesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompaniesUnites$companyArgs<ExtArgs>
  }
  export type CompaniesUnitesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompaniesUnites$companyArgs<ExtArgs>
  }

  export type $CompaniesUnitesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompaniesUnites"
    objects: {
      leads: Prisma.$LeadPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date | null
      name: string | null
      productdefault: string | null
      campaignstatus: string | null
      enablecuration: boolean | null
      enabletosendustolead: boolean | null
      enabled: boolean | null
      isconversationia: boolean | null
      campaignnumberbusiness: string | null
      whatsappprovider: string | null
      enabletosendprovider: boolean | null
      enabletosecondcallprovider: boolean | null
      integrationconfiguration: Prisma.JsonValue | null
      integrationname: string | null
      templatelistvars: Prisma.JsonValue[]
      metaconfiguration: Prisma.JsonValue | null
      messageperruns: Prisma.JsonValue[]
      notifyconfiguration: Prisma.JsonValue | null
      updatedAt: Date | null
      whitelabel_config: string
      whatleadCompanyId: string | null
    }, ExtArgs["result"]["companiesUnites"]>
    composites: {}
  }

  type CompaniesUnitesGetPayload<S extends boolean | null | undefined | CompaniesUnitesDefaultArgs> = $Result.GetResult<Prisma.$CompaniesUnitesPayload, S>

  type CompaniesUnitesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompaniesUnitesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompaniesUnitesCountAggregateInputType | true
    }

  export interface CompaniesUnitesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompaniesUnites'], meta: { name: 'CompaniesUnites' } }
    /**
     * Find zero or one CompaniesUnites that matches the filter.
     * @param {CompaniesUnitesFindUniqueArgs} args - Arguments to find a CompaniesUnites
     * @example
     * // Get one CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompaniesUnitesFindUniqueArgs>(args: SelectSubset<T, CompaniesUnitesFindUniqueArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompaniesUnites that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompaniesUnitesFindUniqueOrThrowArgs} args - Arguments to find a CompaniesUnites
     * @example
     * // Get one CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompaniesUnitesFindUniqueOrThrowArgs>(args: SelectSubset<T, CompaniesUnitesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompaniesUnites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesFindFirstArgs} args - Arguments to find a CompaniesUnites
     * @example
     * // Get one CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompaniesUnitesFindFirstArgs>(args?: SelectSubset<T, CompaniesUnitesFindFirstArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompaniesUnites that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesFindFirstOrThrowArgs} args - Arguments to find a CompaniesUnites
     * @example
     * // Get one CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompaniesUnitesFindFirstOrThrowArgs>(args?: SelectSubset<T, CompaniesUnitesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompaniesUnites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.findMany()
     * 
     * // Get first 10 CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesUnitesWithIdOnly = await prisma.companiesUnites.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompaniesUnitesFindManyArgs>(args?: SelectSubset<T, CompaniesUnitesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompaniesUnites.
     * @param {CompaniesUnitesCreateArgs} args - Arguments to create a CompaniesUnites.
     * @example
     * // Create one CompaniesUnites
     * const CompaniesUnites = await prisma.companiesUnites.create({
     *   data: {
     *     // ... data to create a CompaniesUnites
     *   }
     * })
     * 
     */
    create<T extends CompaniesUnitesCreateArgs>(args: SelectSubset<T, CompaniesUnitesCreateArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompaniesUnites.
     * @param {CompaniesUnitesCreateManyArgs} args - Arguments to create many CompaniesUnites.
     * @example
     * // Create many CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompaniesUnitesCreateManyArgs>(args?: SelectSubset<T, CompaniesUnitesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompaniesUnites and returns the data saved in the database.
     * @param {CompaniesUnitesCreateManyAndReturnArgs} args - Arguments to create many CompaniesUnites.
     * @example
     * // Create many CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompaniesUnites and only return the `id`
     * const companiesUnitesWithIdOnly = await prisma.companiesUnites.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompaniesUnitesCreateManyAndReturnArgs>(args?: SelectSubset<T, CompaniesUnitesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompaniesUnites.
     * @param {CompaniesUnitesDeleteArgs} args - Arguments to delete one CompaniesUnites.
     * @example
     * // Delete one CompaniesUnites
     * const CompaniesUnites = await prisma.companiesUnites.delete({
     *   where: {
     *     // ... filter to delete one CompaniesUnites
     *   }
     * })
     * 
     */
    delete<T extends CompaniesUnitesDeleteArgs>(args: SelectSubset<T, CompaniesUnitesDeleteArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompaniesUnites.
     * @param {CompaniesUnitesUpdateArgs} args - Arguments to update one CompaniesUnites.
     * @example
     * // Update one CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompaniesUnitesUpdateArgs>(args: SelectSubset<T, CompaniesUnitesUpdateArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompaniesUnites.
     * @param {CompaniesUnitesDeleteManyArgs} args - Arguments to filter CompaniesUnites to delete.
     * @example
     * // Delete a few CompaniesUnites
     * const { count } = await prisma.companiesUnites.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompaniesUnitesDeleteManyArgs>(args?: SelectSubset<T, CompaniesUnitesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompaniesUnites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompaniesUnitesUpdateManyArgs>(args: SelectSubset<T, CompaniesUnitesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompaniesUnites and returns the data updated in the database.
     * @param {CompaniesUnitesUpdateManyAndReturnArgs} args - Arguments to update many CompaniesUnites.
     * @example
     * // Update many CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompaniesUnites and only return the `id`
     * const companiesUnitesWithIdOnly = await prisma.companiesUnites.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompaniesUnitesUpdateManyAndReturnArgs>(args: SelectSubset<T, CompaniesUnitesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompaniesUnites.
     * @param {CompaniesUnitesUpsertArgs} args - Arguments to update or create a CompaniesUnites.
     * @example
     * // Update or create a CompaniesUnites
     * const companiesUnites = await prisma.companiesUnites.upsert({
     *   create: {
     *     // ... data to create a CompaniesUnites
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompaniesUnites we want to update
     *   }
     * })
     */
    upsert<T extends CompaniesUnitesUpsertArgs>(args: SelectSubset<T, CompaniesUnitesUpsertArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompaniesUnites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesCountArgs} args - Arguments to filter CompaniesUnites to count.
     * @example
     * // Count the number of CompaniesUnites
     * const count = await prisma.companiesUnites.count({
     *   where: {
     *     // ... the filter for the CompaniesUnites we want to count
     *   }
     * })
    **/
    count<T extends CompaniesUnitesCountArgs>(
      args?: Subset<T, CompaniesUnitesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesUnitesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompaniesUnites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesUnitesAggregateArgs>(args: Subset<T, CompaniesUnitesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesUnitesAggregateType<T>>

    /**
     * Group by CompaniesUnites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesUnitesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompaniesUnitesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompaniesUnitesGroupByArgs['orderBy'] }
        : { orderBy?: CompaniesUnitesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompaniesUnitesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesUnitesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompaniesUnites model
   */
  readonly fields: CompaniesUnitesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompaniesUnites.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompaniesUnitesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leads<T extends CompaniesUnites$leadsArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUnites$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompaniesUnites$companyArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUnites$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompaniesUnites model
   */
  interface CompaniesUnitesFieldRefs {
    readonly id: FieldRef<"CompaniesUnites", 'String'>
    readonly createdAt: FieldRef<"CompaniesUnites", 'DateTime'>
    readonly name: FieldRef<"CompaniesUnites", 'String'>
    readonly productdefault: FieldRef<"CompaniesUnites", 'String'>
    readonly campaignstatus: FieldRef<"CompaniesUnites", 'String'>
    readonly enablecuration: FieldRef<"CompaniesUnites", 'Boolean'>
    readonly enabletosendustolead: FieldRef<"CompaniesUnites", 'Boolean'>
    readonly enabled: FieldRef<"CompaniesUnites", 'Boolean'>
    readonly isconversationia: FieldRef<"CompaniesUnites", 'Boolean'>
    readonly campaignnumberbusiness: FieldRef<"CompaniesUnites", 'String'>
    readonly whatsappprovider: FieldRef<"CompaniesUnites", 'String'>
    readonly enabletosendprovider: FieldRef<"CompaniesUnites", 'Boolean'>
    readonly enabletosecondcallprovider: FieldRef<"CompaniesUnites", 'Boolean'>
    readonly integrationconfiguration: FieldRef<"CompaniesUnites", 'Json'>
    readonly integrationname: FieldRef<"CompaniesUnites", 'String'>
    readonly templatelistvars: FieldRef<"CompaniesUnites", 'Json[]'>
    readonly metaconfiguration: FieldRef<"CompaniesUnites", 'Json'>
    readonly messageperruns: FieldRef<"CompaniesUnites", 'Json[]'>
    readonly notifyconfiguration: FieldRef<"CompaniesUnites", 'Json'>
    readonly updatedAt: FieldRef<"CompaniesUnites", 'DateTime'>
    readonly whitelabel_config: FieldRef<"CompaniesUnites", 'String'>
    readonly whatleadCompanyId: FieldRef<"CompaniesUnites", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompaniesUnites findUnique
   */
  export type CompaniesUnitesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUnites to fetch.
     */
    where: CompaniesUnitesWhereUniqueInput
  }

  /**
   * CompaniesUnites findUniqueOrThrow
   */
  export type CompaniesUnitesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUnites to fetch.
     */
    where: CompaniesUnitesWhereUniqueInput
  }

  /**
   * CompaniesUnites findFirst
   */
  export type CompaniesUnitesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUnites to fetch.
     */
    where?: CompaniesUnitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUnites to fetch.
     */
    orderBy?: CompaniesUnitesOrderByWithRelationInput | CompaniesUnitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesUnites.
     */
    cursor?: CompaniesUnitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUnites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUnites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesUnites.
     */
    distinct?: CompaniesUnitesScalarFieldEnum | CompaniesUnitesScalarFieldEnum[]
  }

  /**
   * CompaniesUnites findFirstOrThrow
   */
  export type CompaniesUnitesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUnites to fetch.
     */
    where?: CompaniesUnitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUnites to fetch.
     */
    orderBy?: CompaniesUnitesOrderByWithRelationInput | CompaniesUnitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompaniesUnites.
     */
    cursor?: CompaniesUnitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUnites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUnites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompaniesUnites.
     */
    distinct?: CompaniesUnitesScalarFieldEnum | CompaniesUnitesScalarFieldEnum[]
  }

  /**
   * CompaniesUnites findMany
   */
  export type CompaniesUnitesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * Filter, which CompaniesUnites to fetch.
     */
    where?: CompaniesUnitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompaniesUnites to fetch.
     */
    orderBy?: CompaniesUnitesOrderByWithRelationInput | CompaniesUnitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompaniesUnites.
     */
    cursor?: CompaniesUnitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompaniesUnites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompaniesUnites.
     */
    skip?: number
    distinct?: CompaniesUnitesScalarFieldEnum | CompaniesUnitesScalarFieldEnum[]
  }

  /**
   * CompaniesUnites create
   */
  export type CompaniesUnitesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * The data needed to create a CompaniesUnites.
     */
    data: XOR<CompaniesUnitesCreateInput, CompaniesUnitesUncheckedCreateInput>
  }

  /**
   * CompaniesUnites createMany
   */
  export type CompaniesUnitesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompaniesUnites.
     */
    data: CompaniesUnitesCreateManyInput | CompaniesUnitesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompaniesUnites createManyAndReturn
   */
  export type CompaniesUnitesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * The data used to create many CompaniesUnites.
     */
    data: CompaniesUnitesCreateManyInput | CompaniesUnitesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompaniesUnites update
   */
  export type CompaniesUnitesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * The data needed to update a CompaniesUnites.
     */
    data: XOR<CompaniesUnitesUpdateInput, CompaniesUnitesUncheckedUpdateInput>
    /**
     * Choose, which CompaniesUnites to update.
     */
    where: CompaniesUnitesWhereUniqueInput
  }

  /**
   * CompaniesUnites updateMany
   */
  export type CompaniesUnitesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompaniesUnites.
     */
    data: XOR<CompaniesUnitesUpdateManyMutationInput, CompaniesUnitesUncheckedUpdateManyInput>
    /**
     * Filter which CompaniesUnites to update
     */
    where?: CompaniesUnitesWhereInput
    /**
     * Limit how many CompaniesUnites to update.
     */
    limit?: number
  }

  /**
   * CompaniesUnites updateManyAndReturn
   */
  export type CompaniesUnitesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * The data used to update CompaniesUnites.
     */
    data: XOR<CompaniesUnitesUpdateManyMutationInput, CompaniesUnitesUncheckedUpdateManyInput>
    /**
     * Filter which CompaniesUnites to update
     */
    where?: CompaniesUnitesWhereInput
    /**
     * Limit how many CompaniesUnites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompaniesUnites upsert
   */
  export type CompaniesUnitesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * The filter to search for the CompaniesUnites to update in case it exists.
     */
    where: CompaniesUnitesWhereUniqueInput
    /**
     * In case the CompaniesUnites found by the `where` argument doesn't exist, create a new CompaniesUnites with this data.
     */
    create: XOR<CompaniesUnitesCreateInput, CompaniesUnitesUncheckedCreateInput>
    /**
     * In case the CompaniesUnites was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompaniesUnitesUpdateInput, CompaniesUnitesUncheckedUpdateInput>
  }

  /**
   * CompaniesUnites delete
   */
  export type CompaniesUnitesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
    /**
     * Filter which CompaniesUnites to delete.
     */
    where: CompaniesUnitesWhereUniqueInput
  }

  /**
   * CompaniesUnites deleteMany
   */
  export type CompaniesUnitesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompaniesUnites to delete
     */
    where?: CompaniesUnitesWhereInput
    /**
     * Limit how many CompaniesUnites to delete.
     */
    limit?: number
  }

  /**
   * CompaniesUnites.leads
   */
  export type CompaniesUnites$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * CompaniesUnites.company
   */
  export type CompaniesUnites$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * CompaniesUnites without action
   */
  export type CompaniesUnitesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesUnites
     */
    select?: CompaniesUnitesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompaniesUnites
     */
    omit?: CompaniesUnitesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompaniesUnitesInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    stepsecondcalltemplate: number | null
    stepnointeraction: number | null
    nointeractionquantity: number | null
    productid: number | null
  }

  export type LeadSumAggregateOutputType = {
    stepsecondcalltemplate: number | null
    stepnointeraction: number | null
    nointeractionquantity: number | null
    productid: number | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    externalid: string | null
    sourceid: string | null
    name: string | null
    phone: string | null
    email: string | null
    lastmessagesent: Date | null
    stepsecondcalltemplate: number | null
    stepnointeraction: number | null
    nointeractionquantity: number | null
    accepttemplate: boolean | null
    acceptsecondtemplate: boolean | null
    status: string | null
    configid: string | null
    whitelabelconfig: string | null
    lastintent: string | null
    broker: string | null
    origin: string | null
    send: boolean | null
    sendAt: Date | null
    isBusinessAutoResponder: boolean | null
    startmessage: Date | null
    schedulingdata: string | null
    productchoosebyclient: string | null
    productid: number | null
    createdat: Date | null
    updatedat: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    externalid: string | null
    sourceid: string | null
    name: string | null
    phone: string | null
    email: string | null
    lastmessagesent: Date | null
    stepsecondcalltemplate: number | null
    stepnointeraction: number | null
    nointeractionquantity: number | null
    accepttemplate: boolean | null
    acceptsecondtemplate: boolean | null
    status: string | null
    configid: string | null
    whitelabelconfig: string | null
    lastintent: string | null
    broker: string | null
    origin: string | null
    send: boolean | null
    sendAt: Date | null
    isBusinessAutoResponder: boolean | null
    startmessage: Date | null
    schedulingdata: string | null
    productchoosebyclient: string | null
    productid: number | null
    createdat: Date | null
    updatedat: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    externalid: number
    sourceid: number
    name: number
    phone: number
    email: number
    lastmessagesent: number
    stepsecondcalltemplate: number
    stepnointeraction: number
    nointeractionquantity: number
    accepttemplate: number
    acceptsecondtemplate: number
    status: number
    dialog: number
    configid: number
    whitelabelconfig: number
    lastintent: number
    broker: number
    origin: number
    send: number
    sendAt: number
    isBusinessAutoResponder: number
    startmessage: number
    schedulingdata: number
    productchoosebyclient: number
    productid: number
    createdat: number
    updatedat: number
    curation: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    stepsecondcalltemplate?: true
    stepnointeraction?: true
    nointeractionquantity?: true
    productid?: true
  }

  export type LeadSumAggregateInputType = {
    stepsecondcalltemplate?: true
    stepnointeraction?: true
    nointeractionquantity?: true
    productid?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    externalid?: true
    sourceid?: true
    name?: true
    phone?: true
    email?: true
    lastmessagesent?: true
    stepsecondcalltemplate?: true
    stepnointeraction?: true
    nointeractionquantity?: true
    accepttemplate?: true
    acceptsecondtemplate?: true
    status?: true
    configid?: true
    whitelabelconfig?: true
    lastintent?: true
    broker?: true
    origin?: true
    send?: true
    sendAt?: true
    isBusinessAutoResponder?: true
    startmessage?: true
    schedulingdata?: true
    productchoosebyclient?: true
    productid?: true
    createdat?: true
    updatedat?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    externalid?: true
    sourceid?: true
    name?: true
    phone?: true
    email?: true
    lastmessagesent?: true
    stepsecondcalltemplate?: true
    stepnointeraction?: true
    nointeractionquantity?: true
    accepttemplate?: true
    acceptsecondtemplate?: true
    status?: true
    configid?: true
    whitelabelconfig?: true
    lastintent?: true
    broker?: true
    origin?: true
    send?: true
    sendAt?: true
    isBusinessAutoResponder?: true
    startmessage?: true
    schedulingdata?: true
    productchoosebyclient?: true
    productid?: true
    createdat?: true
    updatedat?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    externalid?: true
    sourceid?: true
    name?: true
    phone?: true
    email?: true
    lastmessagesent?: true
    stepsecondcalltemplate?: true
    stepnointeraction?: true
    nointeractionquantity?: true
    accepttemplate?: true
    acceptsecondtemplate?: true
    status?: true
    dialog?: true
    configid?: true
    whitelabelconfig?: true
    lastintent?: true
    broker?: true
    origin?: true
    send?: true
    sendAt?: true
    isBusinessAutoResponder?: true
    startmessage?: true
    schedulingdata?: true
    productchoosebyclient?: true
    productid?: true
    createdat?: true
    updatedat?: true
    curation?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    externalid: string | null
    sourceid: string | null
    name: string
    phone: string
    email: string | null
    lastmessagesent: Date | null
    stepsecondcalltemplate: number | null
    stepnointeraction: number | null
    nointeractionquantity: number | null
    accepttemplate: boolean | null
    acceptsecondtemplate: boolean | null
    status: string | null
    dialog: JsonValue[]
    configid: string
    whitelabelconfig: string
    lastintent: string | null
    broker: string | null
    origin: string | null
    send: boolean | null
    sendAt: Date | null
    isBusinessAutoResponder: boolean | null
    startmessage: Date | null
    schedulingdata: string | null
    productchoosebyclient: string | null
    productid: number | null
    createdat: Date
    updatedat: Date
    curation: JsonValue | null
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalid?: boolean
    sourceid?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    lastmessagesent?: boolean
    stepsecondcalltemplate?: boolean
    stepnointeraction?: boolean
    nointeractionquantity?: boolean
    accepttemplate?: boolean
    acceptsecondtemplate?: boolean
    status?: boolean
    dialog?: boolean
    configid?: boolean
    whitelabelconfig?: boolean
    lastintent?: boolean
    broker?: boolean
    origin?: boolean
    send?: boolean
    sendAt?: boolean
    isBusinessAutoResponder?: boolean
    startmessage?: boolean
    schedulingdata?: boolean
    productchoosebyclient?: boolean
    productid?: boolean
    createdat?: boolean
    updatedat?: boolean
    curation?: boolean
    MessageLog?: boolean | Lead$MessageLogArgs<ExtArgs>
    config?: boolean | CompaniesUnitesDefaultArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalid?: boolean
    sourceid?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    lastmessagesent?: boolean
    stepsecondcalltemplate?: boolean
    stepnointeraction?: boolean
    nointeractionquantity?: boolean
    accepttemplate?: boolean
    acceptsecondtemplate?: boolean
    status?: boolean
    dialog?: boolean
    configid?: boolean
    whitelabelconfig?: boolean
    lastintent?: boolean
    broker?: boolean
    origin?: boolean
    send?: boolean
    sendAt?: boolean
    isBusinessAutoResponder?: boolean
    startmessage?: boolean
    schedulingdata?: boolean
    productchoosebyclient?: boolean
    productid?: boolean
    createdat?: boolean
    updatedat?: boolean
    curation?: boolean
    config?: boolean | CompaniesUnitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    externalid?: boolean
    sourceid?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    lastmessagesent?: boolean
    stepsecondcalltemplate?: boolean
    stepnointeraction?: boolean
    nointeractionquantity?: boolean
    accepttemplate?: boolean
    acceptsecondtemplate?: boolean
    status?: boolean
    dialog?: boolean
    configid?: boolean
    whitelabelconfig?: boolean
    lastintent?: boolean
    broker?: boolean
    origin?: boolean
    send?: boolean
    sendAt?: boolean
    isBusinessAutoResponder?: boolean
    startmessage?: boolean
    schedulingdata?: boolean
    productchoosebyclient?: boolean
    productid?: boolean
    createdat?: boolean
    updatedat?: boolean
    curation?: boolean
    config?: boolean | CompaniesUnitesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    externalid?: boolean
    sourceid?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    lastmessagesent?: boolean
    stepsecondcalltemplate?: boolean
    stepnointeraction?: boolean
    nointeractionquantity?: boolean
    accepttemplate?: boolean
    acceptsecondtemplate?: boolean
    status?: boolean
    dialog?: boolean
    configid?: boolean
    whitelabelconfig?: boolean
    lastintent?: boolean
    broker?: boolean
    origin?: boolean
    send?: boolean
    sendAt?: boolean
    isBusinessAutoResponder?: boolean
    startmessage?: boolean
    schedulingdata?: boolean
    productchoosebyclient?: boolean
    productid?: boolean
    createdat?: boolean
    updatedat?: boolean
    curation?: boolean
  }

  export type LeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "externalid" | "sourceid" | "name" | "phone" | "email" | "lastmessagesent" | "stepsecondcalltemplate" | "stepnointeraction" | "nointeractionquantity" | "accepttemplate" | "acceptsecondtemplate" | "status" | "dialog" | "configid" | "whitelabelconfig" | "lastintent" | "broker" | "origin" | "send" | "sendAt" | "isBusinessAutoResponder" | "startmessage" | "schedulingdata" | "productchoosebyclient" | "productid" | "createdat" | "updatedat" | "curation", ExtArgs["result"]["lead"]>
  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageLog?: boolean | Lead$MessageLogArgs<ExtArgs>
    config?: boolean | CompaniesUnitesDefaultArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | CompaniesUnitesDefaultArgs<ExtArgs>
  }
  export type LeadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config?: boolean | CompaniesUnitesDefaultArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      MessageLog: Prisma.$MessageLogPayload<ExtArgs>[]
      config: Prisma.$CompaniesUnitesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      externalid: string | null
      sourceid: string | null
      name: string
      phone: string
      email: string | null
      lastmessagesent: Date | null
      stepsecondcalltemplate: number | null
      stepnointeraction: number | null
      nointeractionquantity: number | null
      accepttemplate: boolean | null
      acceptsecondtemplate: boolean | null
      status: string | null
      dialog: Prisma.JsonValue[]
      configid: string
      whitelabelconfig: string
      lastintent: string | null
      broker: string | null
      origin: string | null
      send: boolean | null
      sendAt: Date | null
      isBusinessAutoResponder: boolean | null
      startmessage: Date | null
      schedulingdata: string | null
      productchoosebyclient: string | null
      productid: number | null
      createdat: Date
      updatedat: Date
      curation: Prisma.JsonValue | null
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads and returns the data updated in the database.
     * @param {LeadUpdateManyAndReturnArgs} args - Arguments to update many Leads.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MessageLog<T extends Lead$MessageLogArgs<ExtArgs> = {}>(args?: Subset<T, Lead$MessageLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    config<T extends CompaniesUnitesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompaniesUnitesDefaultArgs<ExtArgs>>): Prisma__CompaniesUnitesClient<$Result.GetResult<Prisma.$CompaniesUnitesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly externalid: FieldRef<"Lead", 'String'>
    readonly sourceid: FieldRef<"Lead", 'String'>
    readonly name: FieldRef<"Lead", 'String'>
    readonly phone: FieldRef<"Lead", 'String'>
    readonly email: FieldRef<"Lead", 'String'>
    readonly lastmessagesent: FieldRef<"Lead", 'DateTime'>
    readonly stepsecondcalltemplate: FieldRef<"Lead", 'Int'>
    readonly stepnointeraction: FieldRef<"Lead", 'Int'>
    readonly nointeractionquantity: FieldRef<"Lead", 'Int'>
    readonly accepttemplate: FieldRef<"Lead", 'Boolean'>
    readonly acceptsecondtemplate: FieldRef<"Lead", 'Boolean'>
    readonly status: FieldRef<"Lead", 'String'>
    readonly dialog: FieldRef<"Lead", 'Json[]'>
    readonly configid: FieldRef<"Lead", 'String'>
    readonly whitelabelconfig: FieldRef<"Lead", 'String'>
    readonly lastintent: FieldRef<"Lead", 'String'>
    readonly broker: FieldRef<"Lead", 'String'>
    readonly origin: FieldRef<"Lead", 'String'>
    readonly send: FieldRef<"Lead", 'Boolean'>
    readonly sendAt: FieldRef<"Lead", 'DateTime'>
    readonly isBusinessAutoResponder: FieldRef<"Lead", 'Boolean'>
    readonly startmessage: FieldRef<"Lead", 'DateTime'>
    readonly schedulingdata: FieldRef<"Lead", 'String'>
    readonly productchoosebyclient: FieldRef<"Lead", 'String'>
    readonly productid: FieldRef<"Lead", 'Int'>
    readonly createdat: FieldRef<"Lead", 'DateTime'>
    readonly updatedat: FieldRef<"Lead", 'DateTime'>
    readonly curation: FieldRef<"Lead", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead updateManyAndReturn
   */
  export type LeadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to delete.
     */
    limit?: number
  }

  /**
   * Lead.MessageLog
   */
  export type Lead$MessageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    where?: MessageLogWhereInput
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    cursor?: MessageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageLogScalarFieldEnum | MessageLogScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    stripePaymentId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    dueDate: Date | null
    customerId: string | null
    disputeStatus: string | null
    disputeReason: string | null
    cancelReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    stripePaymentId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    dueDate: Date | null
    customerId: string | null
    disputeStatus: string | null
    disputeReason: string | null
    cancelReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    stripePaymentId: number
    amount: number
    currency: number
    status: number
    dueDate: number
    customerId: number
    metadata: number
    disputeStatus: number
    disputeReason: number
    cancelReason: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    stripePaymentId?: true
    amount?: true
    currency?: true
    status?: true
    dueDate?: true
    customerId?: true
    disputeStatus?: true
    disputeReason?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    stripePaymentId?: true
    amount?: true
    currency?: true
    status?: true
    dueDate?: true
    customerId?: true
    disputeStatus?: true
    disputeReason?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    stripePaymentId?: true
    amount?: true
    currency?: true
    status?: true
    dueDate?: true
    customerId?: true
    metadata?: true
    disputeStatus?: true
    disputeReason?: true
    cancelReason?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    dueDate: Date
    customerId: string | null
    metadata: JsonValue | null
    disputeStatus: string | null
    disputeReason: string | null
    cancelReason: string | null
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripePaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    dueDate?: boolean
    customerId?: boolean
    metadata?: boolean
    disputeStatus?: boolean
    disputeReason?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Payment$userArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripePaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    dueDate?: boolean
    customerId?: boolean
    metadata?: boolean
    disputeStatus?: boolean
    disputeReason?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Payment$userArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripePaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    dueDate?: boolean
    customerId?: boolean
    metadata?: boolean
    disputeStatus?: boolean
    disputeReason?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Payment$userArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    stripePaymentId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    dueDate?: boolean
    customerId?: boolean
    metadata?: boolean
    disputeStatus?: boolean
    disputeReason?: boolean
    cancelReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stripePaymentId" | "amount" | "currency" | "status" | "dueDate" | "customerId" | "metadata" | "disputeStatus" | "disputeReason" | "cancelReason" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Payment$userArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Payment$userArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Payment$userArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stripePaymentId: string
      amount: number
      currency: string
      status: string
      dueDate: Date
      customerId: string | null
      metadata: Prisma.JsonValue | null
      disputeStatus: string | null
      disputeReason: string | null
      cancelReason: string | null
      createdAt: Date
      updatedAt: Date
      userId: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Payment$userArgs<ExtArgs> = {}>(args?: Subset<T, Payment$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly stripePaymentId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Int'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly dueDate: FieldRef<"Payment", 'DateTime'>
    readonly customerId: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly disputeStatus: FieldRef<"Payment", 'String'>
    readonly disputeReason: FieldRef<"Payment", 'String'>
    readonly cancelReason: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly userId: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.user
   */
  export type Payment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Instance
   */

  export type AggregateInstance = {
    _count: InstanceCountAggregateOutputType | null
    _min: InstanceMinAggregateOutputType | null
    _max: InstanceMaxAggregateOutputType | null
  }

  export type InstanceMinAggregateOutputType = {
    id: string | null
    instanceName: string | null
    connectionStatus: $Enums.InstanceStatus | null
    number: string | null
    ownerJid: string | null
    profilePicUrl: string | null
    integration: string | null
    token: string | null
    clientName: string | null
    profileName: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    disconnectedAt: Date | null
    disconnectionReasonCode: string | null
  }

  export type InstanceMaxAggregateOutputType = {
    id: string | null
    instanceName: string | null
    connectionStatus: $Enums.InstanceStatus | null
    number: string | null
    ownerJid: string | null
    profilePicUrl: string | null
    integration: string | null
    token: string | null
    clientName: string | null
    profileName: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    disconnectedAt: Date | null
    disconnectionReasonCode: string | null
  }

  export type InstanceCountAggregateOutputType = {
    id: number
    instanceName: number
    connectionStatus: number
    number: number
    ownerJid: number
    profilePicUrl: number
    integration: number
    token: number
    clientName: number
    profileName: number
    userId: number
    createdAt: number
    updatedAt: number
    disconnectedAt: number
    disconnectionObject: number
    disconnectionReasonCode: number
    proxyConfig: number
    typebot: number
    _all: number
  }


  export type InstanceMinAggregateInputType = {
    id?: true
    instanceName?: true
    connectionStatus?: true
    number?: true
    ownerJid?: true
    profilePicUrl?: true
    integration?: true
    token?: true
    clientName?: true
    profileName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    disconnectedAt?: true
    disconnectionReasonCode?: true
  }

  export type InstanceMaxAggregateInputType = {
    id?: true
    instanceName?: true
    connectionStatus?: true
    number?: true
    ownerJid?: true
    profilePicUrl?: true
    integration?: true
    token?: true
    clientName?: true
    profileName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    disconnectedAt?: true
    disconnectionReasonCode?: true
  }

  export type InstanceCountAggregateInputType = {
    id?: true
    instanceName?: true
    connectionStatus?: true
    number?: true
    ownerJid?: true
    profilePicUrl?: true
    integration?: true
    token?: true
    clientName?: true
    profileName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    disconnectedAt?: true
    disconnectionObject?: true
    disconnectionReasonCode?: true
    proxyConfig?: true
    typebot?: true
    _all?: true
  }

  export type InstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instance to aggregate.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instances
    **/
    _count?: true | InstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstanceMaxAggregateInputType
  }

  export type GetInstanceAggregateType<T extends InstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstance[P]>
      : GetScalarType<T[P], AggregateInstance[P]>
  }




  export type InstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstanceWhereInput
    orderBy?: InstanceOrderByWithAggregationInput | InstanceOrderByWithAggregationInput[]
    by: InstanceScalarFieldEnum[] | InstanceScalarFieldEnum
    having?: InstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstanceCountAggregateInputType | true
    _min?: InstanceMinAggregateInputType
    _max?: InstanceMaxAggregateInputType
  }

  export type InstanceGroupByOutputType = {
    id: string
    instanceName: string
    connectionStatus: $Enums.InstanceStatus
    number: string | null
    ownerJid: string | null
    profilePicUrl: string | null
    integration: string
    token: string | null
    clientName: string | null
    profileName: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    disconnectedAt: Date | null
    disconnectionObject: JsonValue | null
    disconnectionReasonCode: string | null
    proxyConfig: JsonValue | null
    typebot: JsonValue | null
    _count: InstanceCountAggregateOutputType | null
    _min: InstanceMinAggregateOutputType | null
    _max: InstanceMaxAggregateOutputType | null
  }

  type GetInstanceGroupByPayload<T extends InstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstanceGroupByOutputType[P]>
            : GetScalarType<T[P], InstanceGroupByOutputType[P]>
        }
      >
    >


  export type InstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    connectionStatus?: boolean
    number?: boolean
    ownerJid?: boolean
    profilePicUrl?: boolean
    integration?: boolean
    token?: boolean
    clientName?: boolean
    profileName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disconnectedAt?: boolean
    disconnectionObject?: boolean
    disconnectionReasonCode?: boolean
    proxyConfig?: boolean
    typebot?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | Instance$campaignsArgs<ExtArgs>
    campaignSchedules?: boolean | Instance$campaignSchedulesArgs<ExtArgs>
    campaignDispatches?: boolean | Instance$campaignDispatchesArgs<ExtArgs>
    warmupStats?: boolean | Instance$warmupStatsArgs<ExtArgs>
    mediaStats?: boolean | Instance$mediaStatsArgs<ExtArgs>
    _count?: boolean | InstanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instance"]>

  export type InstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    connectionStatus?: boolean
    number?: boolean
    ownerJid?: boolean
    profilePicUrl?: boolean
    integration?: boolean
    token?: boolean
    clientName?: boolean
    profileName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disconnectedAt?: boolean
    disconnectionObject?: boolean
    disconnectionReasonCode?: boolean
    proxyConfig?: boolean
    typebot?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instance"]>

  export type InstanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    connectionStatus?: boolean
    number?: boolean
    ownerJid?: boolean
    profilePicUrl?: boolean
    integration?: boolean
    token?: boolean
    clientName?: boolean
    profileName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disconnectedAt?: boolean
    disconnectionObject?: boolean
    disconnectionReasonCode?: boolean
    proxyConfig?: boolean
    typebot?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instance"]>

  export type InstanceSelectScalar = {
    id?: boolean
    instanceName?: boolean
    connectionStatus?: boolean
    number?: boolean
    ownerJid?: boolean
    profilePicUrl?: boolean
    integration?: boolean
    token?: boolean
    clientName?: boolean
    profileName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disconnectedAt?: boolean
    disconnectionObject?: boolean
    disconnectionReasonCode?: boolean
    proxyConfig?: boolean
    typebot?: boolean
  }

  export type InstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instanceName" | "connectionStatus" | "number" | "ownerJid" | "profilePicUrl" | "integration" | "token" | "clientName" | "profileName" | "userId" | "createdAt" | "updatedAt" | "disconnectedAt" | "disconnectionObject" | "disconnectionReasonCode" | "proxyConfig" | "typebot", ExtArgs["result"]["instance"]>
  export type InstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | Instance$campaignsArgs<ExtArgs>
    campaignSchedules?: boolean | Instance$campaignSchedulesArgs<ExtArgs>
    campaignDispatches?: boolean | Instance$campaignDispatchesArgs<ExtArgs>
    warmupStats?: boolean | Instance$warmupStatsArgs<ExtArgs>
    mediaStats?: boolean | Instance$mediaStatsArgs<ExtArgs>
    _count?: boolean | InstanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InstanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      campaignSchedules: Prisma.$CampaignSchedulePayload<ExtArgs>[]
      campaignDispatches: Prisma.$CampaignDispatchPayload<ExtArgs>[]
      warmupStats: Prisma.$WarmupStatsPayload<ExtArgs>[]
      mediaStats: Prisma.$MediaStatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceName: string
      connectionStatus: $Enums.InstanceStatus
      number: string | null
      ownerJid: string | null
      profilePicUrl: string | null
      integration: string
      token: string | null
      clientName: string | null
      profileName: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
      disconnectedAt: Date | null
      disconnectionObject: Prisma.JsonValue | null
      disconnectionReasonCode: string | null
      proxyConfig: Prisma.JsonValue | null
      typebot: Prisma.JsonValue | null
    }, ExtArgs["result"]["instance"]>
    composites: {}
  }

  type InstanceGetPayload<S extends boolean | null | undefined | InstanceDefaultArgs> = $Result.GetResult<Prisma.$InstancePayload, S>

  type InstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstanceCountAggregateInputType | true
    }

  export interface InstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instance'], meta: { name: 'Instance' } }
    /**
     * Find zero or one Instance that matches the filter.
     * @param {InstanceFindUniqueArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstanceFindUniqueArgs>(args: SelectSubset<T, InstanceFindUniqueArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Instance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstanceFindUniqueOrThrowArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, InstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindFirstArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstanceFindFirstArgs>(args?: SelectSubset<T, InstanceFindFirstArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindFirstOrThrowArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, InstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Instances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instances
     * const instances = await prisma.instance.findMany()
     * 
     * // Get first 10 Instances
     * const instances = await prisma.instance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instanceWithIdOnly = await prisma.instance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstanceFindManyArgs>(args?: SelectSubset<T, InstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Instance.
     * @param {InstanceCreateArgs} args - Arguments to create a Instance.
     * @example
     * // Create one Instance
     * const Instance = await prisma.instance.create({
     *   data: {
     *     // ... data to create a Instance
     *   }
     * })
     * 
     */
    create<T extends InstanceCreateArgs>(args: SelectSubset<T, InstanceCreateArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Instances.
     * @param {InstanceCreateManyArgs} args - Arguments to create many Instances.
     * @example
     * // Create many Instances
     * const instance = await prisma.instance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstanceCreateManyArgs>(args?: SelectSubset<T, InstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Instances and returns the data saved in the database.
     * @param {InstanceCreateManyAndReturnArgs} args - Arguments to create many Instances.
     * @example
     * // Create many Instances
     * const instance = await prisma.instance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Instances and only return the `id`
     * const instanceWithIdOnly = await prisma.instance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, InstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Instance.
     * @param {InstanceDeleteArgs} args - Arguments to delete one Instance.
     * @example
     * // Delete one Instance
     * const Instance = await prisma.instance.delete({
     *   where: {
     *     // ... filter to delete one Instance
     *   }
     * })
     * 
     */
    delete<T extends InstanceDeleteArgs>(args: SelectSubset<T, InstanceDeleteArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Instance.
     * @param {InstanceUpdateArgs} args - Arguments to update one Instance.
     * @example
     * // Update one Instance
     * const instance = await prisma.instance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstanceUpdateArgs>(args: SelectSubset<T, InstanceUpdateArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Instances.
     * @param {InstanceDeleteManyArgs} args - Arguments to filter Instances to delete.
     * @example
     * // Delete a few Instances
     * const { count } = await prisma.instance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstanceDeleteManyArgs>(args?: SelectSubset<T, InstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instances
     * const instance = await prisma.instance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstanceUpdateManyArgs>(args: SelectSubset<T, InstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instances and returns the data updated in the database.
     * @param {InstanceUpdateManyAndReturnArgs} args - Arguments to update many Instances.
     * @example
     * // Update many Instances
     * const instance = await prisma.instance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Instances and only return the `id`
     * const instanceWithIdOnly = await prisma.instance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstanceUpdateManyAndReturnArgs>(args: SelectSubset<T, InstanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Instance.
     * @param {InstanceUpsertArgs} args - Arguments to update or create a Instance.
     * @example
     * // Update or create a Instance
     * const instance = await prisma.instance.upsert({
     *   create: {
     *     // ... data to create a Instance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instance we want to update
     *   }
     * })
     */
    upsert<T extends InstanceUpsertArgs>(args: SelectSubset<T, InstanceUpsertArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceCountArgs} args - Arguments to filter Instances to count.
     * @example
     * // Count the number of Instances
     * const count = await prisma.instance.count({
     *   where: {
     *     // ... the filter for the Instances we want to count
     *   }
     * })
    **/
    count<T extends InstanceCountArgs>(
      args?: Subset<T, InstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstanceAggregateArgs>(args: Subset<T, InstanceAggregateArgs>): Prisma.PrismaPromise<GetInstanceAggregateType<T>>

    /**
     * Group by Instance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstanceGroupByArgs['orderBy'] }
        : { orderBy?: InstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instance model
   */
  readonly fields: InstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaigns<T extends Instance$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    campaignSchedules<T extends Instance$campaignSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Instance$campaignSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    campaignDispatches<T extends Instance$campaignDispatchesArgs<ExtArgs> = {}>(args?: Subset<T, Instance$campaignDispatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warmupStats<T extends Instance$warmupStatsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$warmupStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mediaStats<T extends Instance$mediaStatsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$mediaStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instance model
   */
  interface InstanceFieldRefs {
    readonly id: FieldRef<"Instance", 'String'>
    readonly instanceName: FieldRef<"Instance", 'String'>
    readonly connectionStatus: FieldRef<"Instance", 'InstanceStatus'>
    readonly number: FieldRef<"Instance", 'String'>
    readonly ownerJid: FieldRef<"Instance", 'String'>
    readonly profilePicUrl: FieldRef<"Instance", 'String'>
    readonly integration: FieldRef<"Instance", 'String'>
    readonly token: FieldRef<"Instance", 'String'>
    readonly clientName: FieldRef<"Instance", 'String'>
    readonly profileName: FieldRef<"Instance", 'String'>
    readonly userId: FieldRef<"Instance", 'String'>
    readonly createdAt: FieldRef<"Instance", 'DateTime'>
    readonly updatedAt: FieldRef<"Instance", 'DateTime'>
    readonly disconnectedAt: FieldRef<"Instance", 'DateTime'>
    readonly disconnectionObject: FieldRef<"Instance", 'Json'>
    readonly disconnectionReasonCode: FieldRef<"Instance", 'String'>
    readonly proxyConfig: FieldRef<"Instance", 'Json'>
    readonly typebot: FieldRef<"Instance", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Instance findUnique
   */
  export type InstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance findUniqueOrThrow
   */
  export type InstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance findFirst
   */
  export type InstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instances.
     */
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance findFirstOrThrow
   */
  export type InstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instances.
     */
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance findMany
   */
  export type InstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instances to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance create
   */
  export type InstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Instance.
     */
    data: XOR<InstanceCreateInput, InstanceUncheckedCreateInput>
  }

  /**
   * Instance createMany
   */
  export type InstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instances.
     */
    data: InstanceCreateManyInput | InstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instance createManyAndReturn
   */
  export type InstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * The data used to create many Instances.
     */
    data: InstanceCreateManyInput | InstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Instance update
   */
  export type InstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Instance.
     */
    data: XOR<InstanceUpdateInput, InstanceUncheckedUpdateInput>
    /**
     * Choose, which Instance to update.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance updateMany
   */
  export type InstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instances.
     */
    data: XOR<InstanceUpdateManyMutationInput, InstanceUncheckedUpdateManyInput>
    /**
     * Filter which Instances to update
     */
    where?: InstanceWhereInput
    /**
     * Limit how many Instances to update.
     */
    limit?: number
  }

  /**
   * Instance updateManyAndReturn
   */
  export type InstanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * The data used to update Instances.
     */
    data: XOR<InstanceUpdateManyMutationInput, InstanceUncheckedUpdateManyInput>
    /**
     * Filter which Instances to update
     */
    where?: InstanceWhereInput
    /**
     * Limit how many Instances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Instance upsert
   */
  export type InstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Instance to update in case it exists.
     */
    where: InstanceWhereUniqueInput
    /**
     * In case the Instance found by the `where` argument doesn't exist, create a new Instance with this data.
     */
    create: XOR<InstanceCreateInput, InstanceUncheckedCreateInput>
    /**
     * In case the Instance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstanceUpdateInput, InstanceUncheckedUpdateInput>
  }

  /**
   * Instance delete
   */
  export type InstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter which Instance to delete.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance deleteMany
   */
  export type InstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instances to delete
     */
    where?: InstanceWhereInput
    /**
     * Limit how many Instances to delete.
     */
    limit?: number
  }

  /**
   * Instance.campaigns
   */
  export type Instance$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Instance.campaignSchedules
   */
  export type Instance$campaignSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleInclude<ExtArgs> | null
    where?: CampaignScheduleWhereInput
    orderBy?: CampaignScheduleOrderByWithRelationInput | CampaignScheduleOrderByWithRelationInput[]
    cursor?: CampaignScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScheduleScalarFieldEnum | CampaignScheduleScalarFieldEnum[]
  }

  /**
   * Instance.campaignDispatches
   */
  export type Instance$campaignDispatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchInclude<ExtArgs> | null
    where?: CampaignDispatchWhereInput
    orderBy?: CampaignDispatchOrderByWithRelationInput | CampaignDispatchOrderByWithRelationInput[]
    cursor?: CampaignDispatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignDispatchScalarFieldEnum | CampaignDispatchScalarFieldEnum[]
  }

  /**
   * Instance.warmupStats
   */
  export type Instance$warmupStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    where?: WarmupStatsWhereInput
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    cursor?: WarmupStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * Instance.mediaStats
   */
  export type Instance$mediaStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    where?: MediaStatsWhereInput
    orderBy?: MediaStatsOrderByWithRelationInput | MediaStatsOrderByWithRelationInput[]
    cursor?: MediaStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaStatsScalarFieldEnum | MediaStatsScalarFieldEnum[]
  }

  /**
   * Instance without action
   */
  export type InstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
  }


  /**
   * Model MediaStats
   */

  export type AggregateMediaStats = {
    _count: MediaStatsCountAggregateOutputType | null
    _avg: MediaStatsAvgAggregateOutputType | null
    _sum: MediaStatsSumAggregateOutputType | null
    _min: MediaStatsMinAggregateOutputType | null
    _max: MediaStatsMaxAggregateOutputType | null
  }

  export type MediaStatsAvgAggregateOutputType = {
    text: number | null
    image: number | null
    video: number | null
    audio: number | null
    sticker: number | null
    reaction: number | null
    totalDaily: number | null
    totalAllTime: number | null
    totalSent: number | null
    totalReceived: number | null
  }

  export type MediaStatsSumAggregateOutputType = {
    text: number | null
    image: number | null
    video: number | null
    audio: number | null
    sticker: number | null
    reaction: number | null
    totalDaily: number | null
    totalAllTime: number | null
    totalSent: number | null
    totalReceived: number | null
  }

  export type MediaStatsMinAggregateOutputType = {
    id: string | null
    instanceName: string | null
    date: Date | null
    text: number | null
    image: number | null
    video: number | null
    audio: number | null
    sticker: number | null
    reaction: number | null
    isReceived: boolean | null
    totalDaily: number | null
    totalAllTime: number | null
    totalSent: number | null
    totalReceived: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaStatsMaxAggregateOutputType = {
    id: string | null
    instanceName: string | null
    date: Date | null
    text: number | null
    image: number | null
    video: number | null
    audio: number | null
    sticker: number | null
    reaction: number | null
    isReceived: boolean | null
    totalDaily: number | null
    totalAllTime: number | null
    totalSent: number | null
    totalReceived: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaStatsCountAggregateOutputType = {
    id: number
    instanceName: number
    date: number
    text: number
    image: number
    video: number
    audio: number
    sticker: number
    reaction: number
    isReceived: number
    totalDaily: number
    totalAllTime: number
    totalSent: number
    totalReceived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaStatsAvgAggregateInputType = {
    text?: true
    image?: true
    video?: true
    audio?: true
    sticker?: true
    reaction?: true
    totalDaily?: true
    totalAllTime?: true
    totalSent?: true
    totalReceived?: true
  }

  export type MediaStatsSumAggregateInputType = {
    text?: true
    image?: true
    video?: true
    audio?: true
    sticker?: true
    reaction?: true
    totalDaily?: true
    totalAllTime?: true
    totalSent?: true
    totalReceived?: true
  }

  export type MediaStatsMinAggregateInputType = {
    id?: true
    instanceName?: true
    date?: true
    text?: true
    image?: true
    video?: true
    audio?: true
    sticker?: true
    reaction?: true
    isReceived?: true
    totalDaily?: true
    totalAllTime?: true
    totalSent?: true
    totalReceived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaStatsMaxAggregateInputType = {
    id?: true
    instanceName?: true
    date?: true
    text?: true
    image?: true
    video?: true
    audio?: true
    sticker?: true
    reaction?: true
    isReceived?: true
    totalDaily?: true
    totalAllTime?: true
    totalSent?: true
    totalReceived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaStatsCountAggregateInputType = {
    id?: true
    instanceName?: true
    date?: true
    text?: true
    image?: true
    video?: true
    audio?: true
    sticker?: true
    reaction?: true
    isReceived?: true
    totalDaily?: true
    totalAllTime?: true
    totalSent?: true
    totalReceived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaStats to aggregate.
     */
    where?: MediaStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaStats to fetch.
     */
    orderBy?: MediaStatsOrderByWithRelationInput | MediaStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaStats
    **/
    _count?: true | MediaStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaStatsMaxAggregateInputType
  }

  export type GetMediaStatsAggregateType<T extends MediaStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaStats[P]>
      : GetScalarType<T[P], AggregateMediaStats[P]>
  }




  export type MediaStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaStatsWhereInput
    orderBy?: MediaStatsOrderByWithAggregationInput | MediaStatsOrderByWithAggregationInput[]
    by: MediaStatsScalarFieldEnum[] | MediaStatsScalarFieldEnum
    having?: MediaStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaStatsCountAggregateInputType | true
    _avg?: MediaStatsAvgAggregateInputType
    _sum?: MediaStatsSumAggregateInputType
    _min?: MediaStatsMinAggregateInputType
    _max?: MediaStatsMaxAggregateInputType
  }

  export type MediaStatsGroupByOutputType = {
    id: string
    instanceName: string
    date: Date
    text: number
    image: number
    video: number
    audio: number
    sticker: number
    reaction: number
    isReceived: boolean
    totalDaily: number
    totalAllTime: number
    totalSent: number
    totalReceived: number
    createdAt: Date
    updatedAt: Date
    _count: MediaStatsCountAggregateOutputType | null
    _avg: MediaStatsAvgAggregateOutputType | null
    _sum: MediaStatsSumAggregateOutputType | null
    _min: MediaStatsMinAggregateOutputType | null
    _max: MediaStatsMaxAggregateOutputType | null
  }

  type GetMediaStatsGroupByPayload<T extends MediaStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaStatsGroupByOutputType[P]>
            : GetScalarType<T[P], MediaStatsGroupByOutputType[P]>
        }
      >
    >


  export type MediaStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    date?: boolean
    text?: boolean
    image?: boolean
    video?: boolean
    audio?: boolean
    sticker?: boolean
    reaction?: boolean
    isReceived?: boolean
    totalDaily?: boolean
    totalAllTime?: boolean
    totalSent?: boolean
    totalReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    warmupStatsReceived?: boolean | MediaStats$warmupStatsReceivedArgs<ExtArgs>
    warmupStatsSent?: boolean | MediaStats$warmupStatsSentArgs<ExtArgs>
    _count?: boolean | MediaStatsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaStats"]>

  export type MediaStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    date?: boolean
    text?: boolean
    image?: boolean
    video?: boolean
    audio?: boolean
    sticker?: boolean
    reaction?: boolean
    isReceived?: boolean
    totalDaily?: boolean
    totalAllTime?: boolean
    totalSent?: boolean
    totalReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaStats"]>

  export type MediaStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    date?: boolean
    text?: boolean
    image?: boolean
    video?: boolean
    audio?: boolean
    sticker?: boolean
    reaction?: boolean
    isReceived?: boolean
    totalDaily?: boolean
    totalAllTime?: boolean
    totalSent?: boolean
    totalReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaStats"]>

  export type MediaStatsSelectScalar = {
    id?: boolean
    instanceName?: boolean
    date?: boolean
    text?: boolean
    image?: boolean
    video?: boolean
    audio?: boolean
    sticker?: boolean
    reaction?: boolean
    isReceived?: boolean
    totalDaily?: boolean
    totalAllTime?: boolean
    totalSent?: boolean
    totalReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instanceName" | "date" | "text" | "image" | "video" | "audio" | "sticker" | "reaction" | "isReceived" | "totalDaily" | "totalAllTime" | "totalSent" | "totalReceived" | "createdAt" | "updatedAt", ExtArgs["result"]["mediaStats"]>
  export type MediaStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    warmupStatsReceived?: boolean | MediaStats$warmupStatsReceivedArgs<ExtArgs>
    warmupStatsSent?: boolean | MediaStats$warmupStatsSentArgs<ExtArgs>
    _count?: boolean | MediaStatsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }
  export type MediaStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $MediaStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaStats"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      warmupStatsReceived: Prisma.$WarmupStatsPayload<ExtArgs>[]
      warmupStatsSent: Prisma.$WarmupStatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceName: string
      date: Date
      text: number
      image: number
      video: number
      audio: number
      sticker: number
      reaction: number
      isReceived: boolean
      totalDaily: number
      totalAllTime: number
      totalSent: number
      totalReceived: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mediaStats"]>
    composites: {}
  }

  type MediaStatsGetPayload<S extends boolean | null | undefined | MediaStatsDefaultArgs> = $Result.GetResult<Prisma.$MediaStatsPayload, S>

  type MediaStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaStatsCountAggregateInputType | true
    }

  export interface MediaStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaStats'], meta: { name: 'MediaStats' } }
    /**
     * Find zero or one MediaStats that matches the filter.
     * @param {MediaStatsFindUniqueArgs} args - Arguments to find a MediaStats
     * @example
     * // Get one MediaStats
     * const mediaStats = await prisma.mediaStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaStatsFindUniqueArgs>(args: SelectSubset<T, MediaStatsFindUniqueArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MediaStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaStatsFindUniqueOrThrowArgs} args - Arguments to find a MediaStats
     * @example
     * // Get one MediaStats
     * const mediaStats = await prisma.mediaStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsFindFirstArgs} args - Arguments to find a MediaStats
     * @example
     * // Get one MediaStats
     * const mediaStats = await prisma.mediaStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaStatsFindFirstArgs>(args?: SelectSubset<T, MediaStatsFindFirstArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsFindFirstOrThrowArgs} args - Arguments to find a MediaStats
     * @example
     * // Get one MediaStats
     * const mediaStats = await prisma.mediaStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaStats
     * const mediaStats = await prisma.mediaStats.findMany()
     * 
     * // Get first 10 MediaStats
     * const mediaStats = await prisma.mediaStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaStatsWithIdOnly = await prisma.mediaStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaStatsFindManyArgs>(args?: SelectSubset<T, MediaStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MediaStats.
     * @param {MediaStatsCreateArgs} args - Arguments to create a MediaStats.
     * @example
     * // Create one MediaStats
     * const MediaStats = await prisma.mediaStats.create({
     *   data: {
     *     // ... data to create a MediaStats
     *   }
     * })
     * 
     */
    create<T extends MediaStatsCreateArgs>(args: SelectSubset<T, MediaStatsCreateArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MediaStats.
     * @param {MediaStatsCreateManyArgs} args - Arguments to create many MediaStats.
     * @example
     * // Create many MediaStats
     * const mediaStats = await prisma.mediaStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaStatsCreateManyArgs>(args?: SelectSubset<T, MediaStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaStats and returns the data saved in the database.
     * @param {MediaStatsCreateManyAndReturnArgs} args - Arguments to create many MediaStats.
     * @example
     * // Create many MediaStats
     * const mediaStats = await prisma.mediaStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaStats and only return the `id`
     * const mediaStatsWithIdOnly = await prisma.mediaStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MediaStats.
     * @param {MediaStatsDeleteArgs} args - Arguments to delete one MediaStats.
     * @example
     * // Delete one MediaStats
     * const MediaStats = await prisma.mediaStats.delete({
     *   where: {
     *     // ... filter to delete one MediaStats
     *   }
     * })
     * 
     */
    delete<T extends MediaStatsDeleteArgs>(args: SelectSubset<T, MediaStatsDeleteArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MediaStats.
     * @param {MediaStatsUpdateArgs} args - Arguments to update one MediaStats.
     * @example
     * // Update one MediaStats
     * const mediaStats = await prisma.mediaStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaStatsUpdateArgs>(args: SelectSubset<T, MediaStatsUpdateArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MediaStats.
     * @param {MediaStatsDeleteManyArgs} args - Arguments to filter MediaStats to delete.
     * @example
     * // Delete a few MediaStats
     * const { count } = await prisma.mediaStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaStatsDeleteManyArgs>(args?: SelectSubset<T, MediaStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaStats
     * const mediaStats = await prisma.mediaStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaStatsUpdateManyArgs>(args: SelectSubset<T, MediaStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaStats and returns the data updated in the database.
     * @param {MediaStatsUpdateManyAndReturnArgs} args - Arguments to update many MediaStats.
     * @example
     * // Update many MediaStats
     * const mediaStats = await prisma.mediaStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MediaStats and only return the `id`
     * const mediaStatsWithIdOnly = await prisma.mediaStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MediaStats.
     * @param {MediaStatsUpsertArgs} args - Arguments to update or create a MediaStats.
     * @example
     * // Update or create a MediaStats
     * const mediaStats = await prisma.mediaStats.upsert({
     *   create: {
     *     // ... data to create a MediaStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaStats we want to update
     *   }
     * })
     */
    upsert<T extends MediaStatsUpsertArgs>(args: SelectSubset<T, MediaStatsUpsertArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MediaStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsCountArgs} args - Arguments to filter MediaStats to count.
     * @example
     * // Count the number of MediaStats
     * const count = await prisma.mediaStats.count({
     *   where: {
     *     // ... the filter for the MediaStats we want to count
     *   }
     * })
    **/
    count<T extends MediaStatsCountArgs>(
      args?: Subset<T, MediaStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaStatsAggregateArgs>(args: Subset<T, MediaStatsAggregateArgs>): Prisma.PrismaPromise<GetMediaStatsAggregateType<T>>

    /**
     * Group by MediaStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaStatsGroupByArgs['orderBy'] }
        : { orderBy?: MediaStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaStats model
   */
  readonly fields: MediaStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warmupStatsReceived<T extends MediaStats$warmupStatsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, MediaStats$warmupStatsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warmupStatsSent<T extends MediaStats$warmupStatsSentArgs<ExtArgs> = {}>(args?: Subset<T, MediaStats$warmupStatsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaStats model
   */
  interface MediaStatsFieldRefs {
    readonly id: FieldRef<"MediaStats", 'String'>
    readonly instanceName: FieldRef<"MediaStats", 'String'>
    readonly date: FieldRef<"MediaStats", 'DateTime'>
    readonly text: FieldRef<"MediaStats", 'Int'>
    readonly image: FieldRef<"MediaStats", 'Int'>
    readonly video: FieldRef<"MediaStats", 'Int'>
    readonly audio: FieldRef<"MediaStats", 'Int'>
    readonly sticker: FieldRef<"MediaStats", 'Int'>
    readonly reaction: FieldRef<"MediaStats", 'Int'>
    readonly isReceived: FieldRef<"MediaStats", 'Boolean'>
    readonly totalDaily: FieldRef<"MediaStats", 'Int'>
    readonly totalAllTime: FieldRef<"MediaStats", 'Int'>
    readonly totalSent: FieldRef<"MediaStats", 'Int'>
    readonly totalReceived: FieldRef<"MediaStats", 'Int'>
    readonly createdAt: FieldRef<"MediaStats", 'DateTime'>
    readonly updatedAt: FieldRef<"MediaStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaStats findUnique
   */
  export type MediaStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * Filter, which MediaStats to fetch.
     */
    where: MediaStatsWhereUniqueInput
  }

  /**
   * MediaStats findUniqueOrThrow
   */
  export type MediaStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * Filter, which MediaStats to fetch.
     */
    where: MediaStatsWhereUniqueInput
  }

  /**
   * MediaStats findFirst
   */
  export type MediaStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * Filter, which MediaStats to fetch.
     */
    where?: MediaStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaStats to fetch.
     */
    orderBy?: MediaStatsOrderByWithRelationInput | MediaStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaStats.
     */
    cursor?: MediaStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaStats.
     */
    distinct?: MediaStatsScalarFieldEnum | MediaStatsScalarFieldEnum[]
  }

  /**
   * MediaStats findFirstOrThrow
   */
  export type MediaStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * Filter, which MediaStats to fetch.
     */
    where?: MediaStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaStats to fetch.
     */
    orderBy?: MediaStatsOrderByWithRelationInput | MediaStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaStats.
     */
    cursor?: MediaStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaStats.
     */
    distinct?: MediaStatsScalarFieldEnum | MediaStatsScalarFieldEnum[]
  }

  /**
   * MediaStats findMany
   */
  export type MediaStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * Filter, which MediaStats to fetch.
     */
    where?: MediaStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaStats to fetch.
     */
    orderBy?: MediaStatsOrderByWithRelationInput | MediaStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaStats.
     */
    cursor?: MediaStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaStats.
     */
    skip?: number
    distinct?: MediaStatsScalarFieldEnum | MediaStatsScalarFieldEnum[]
  }

  /**
   * MediaStats create
   */
  export type MediaStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaStats.
     */
    data: XOR<MediaStatsCreateInput, MediaStatsUncheckedCreateInput>
  }

  /**
   * MediaStats createMany
   */
  export type MediaStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaStats.
     */
    data: MediaStatsCreateManyInput | MediaStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaStats createManyAndReturn
   */
  export type MediaStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * The data used to create many MediaStats.
     */
    data: MediaStatsCreateManyInput | MediaStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaStats update
   */
  export type MediaStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaStats.
     */
    data: XOR<MediaStatsUpdateInput, MediaStatsUncheckedUpdateInput>
    /**
     * Choose, which MediaStats to update.
     */
    where: MediaStatsWhereUniqueInput
  }

  /**
   * MediaStats updateMany
   */
  export type MediaStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaStats.
     */
    data: XOR<MediaStatsUpdateManyMutationInput, MediaStatsUncheckedUpdateManyInput>
    /**
     * Filter which MediaStats to update
     */
    where?: MediaStatsWhereInput
    /**
     * Limit how many MediaStats to update.
     */
    limit?: number
  }

  /**
   * MediaStats updateManyAndReturn
   */
  export type MediaStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * The data used to update MediaStats.
     */
    data: XOR<MediaStatsUpdateManyMutationInput, MediaStatsUncheckedUpdateManyInput>
    /**
     * Filter which MediaStats to update
     */
    where?: MediaStatsWhereInput
    /**
     * Limit how many MediaStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaStats upsert
   */
  export type MediaStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaStats to update in case it exists.
     */
    where: MediaStatsWhereUniqueInput
    /**
     * In case the MediaStats found by the `where` argument doesn't exist, create a new MediaStats with this data.
     */
    create: XOR<MediaStatsCreateInput, MediaStatsUncheckedCreateInput>
    /**
     * In case the MediaStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaStatsUpdateInput, MediaStatsUncheckedUpdateInput>
  }

  /**
   * MediaStats delete
   */
  export type MediaStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    /**
     * Filter which MediaStats to delete.
     */
    where: MediaStatsWhereUniqueInput
  }

  /**
   * MediaStats deleteMany
   */
  export type MediaStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaStats to delete
     */
    where?: MediaStatsWhereInput
    /**
     * Limit how many MediaStats to delete.
     */
    limit?: number
  }

  /**
   * MediaStats.warmupStatsReceived
   */
  export type MediaStats$warmupStatsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    where?: WarmupStatsWhereInput
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    cursor?: WarmupStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * MediaStats.warmupStatsSent
   */
  export type MediaStats$warmupStatsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    where?: WarmupStatsWhereInput
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    cursor?: WarmupStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * MediaStats without action
   */
  export type MediaStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
  }


  /**
   * Model WarmupStats
   */

  export type AggregateWarmupStats = {
    _count: WarmupStatsCountAggregateOutputType | null
    _avg: WarmupStatsAvgAggregateOutputType | null
    _sum: WarmupStatsSumAggregateOutputType | null
    _min: WarmupStatsMinAggregateOutputType | null
    _max: WarmupStatsMaxAggregateOutputType | null
  }

  export type WarmupStatsAvgAggregateOutputType = {
    messagesSent: number | null
    messagesReceived: number | null
    warmupTime: number | null
    progress: number | null
  }

  export type WarmupStatsSumAggregateOutputType = {
    messagesSent: number | null
    messagesReceived: number | null
    warmupTime: number | null
    progress: number | null
  }

  export type WarmupStatsMinAggregateOutputType = {
    id: string | null
    instanceName: string | null
    status: string | null
    messagesSent: number | null
    messagesReceived: number | null
    warmupTime: number | null
    lastActive: Date | null
    startTime: Date | null
    pauseTime: Date | null
    progress: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mediaStatsId: string | null
    mediaReceivedId: string | null
  }

  export type WarmupStatsMaxAggregateOutputType = {
    id: string | null
    instanceName: string | null
    status: string | null
    messagesSent: number | null
    messagesReceived: number | null
    warmupTime: number | null
    lastActive: Date | null
    startTime: Date | null
    pauseTime: Date | null
    progress: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mediaStatsId: string | null
    mediaReceivedId: string | null
  }

  export type WarmupStatsCountAggregateOutputType = {
    id: number
    instanceName: number
    status: number
    messagesSent: number
    messagesReceived: number
    warmupTime: number
    lastActive: number
    startTime: number
    pauseTime: number
    progress: number
    userId: number
    createdAt: number
    updatedAt: number
    mediaStatsId: number
    mediaReceivedId: number
    _all: number
  }


  export type WarmupStatsAvgAggregateInputType = {
    messagesSent?: true
    messagesReceived?: true
    warmupTime?: true
    progress?: true
  }

  export type WarmupStatsSumAggregateInputType = {
    messagesSent?: true
    messagesReceived?: true
    warmupTime?: true
    progress?: true
  }

  export type WarmupStatsMinAggregateInputType = {
    id?: true
    instanceName?: true
    status?: true
    messagesSent?: true
    messagesReceived?: true
    warmupTime?: true
    lastActive?: true
    startTime?: true
    pauseTime?: true
    progress?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    mediaStatsId?: true
    mediaReceivedId?: true
  }

  export type WarmupStatsMaxAggregateInputType = {
    id?: true
    instanceName?: true
    status?: true
    messagesSent?: true
    messagesReceived?: true
    warmupTime?: true
    lastActive?: true
    startTime?: true
    pauseTime?: true
    progress?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    mediaStatsId?: true
    mediaReceivedId?: true
  }

  export type WarmupStatsCountAggregateInputType = {
    id?: true
    instanceName?: true
    status?: true
    messagesSent?: true
    messagesReceived?: true
    warmupTime?: true
    lastActive?: true
    startTime?: true
    pauseTime?: true
    progress?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    mediaStatsId?: true
    mediaReceivedId?: true
    _all?: true
  }

  export type WarmupStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarmupStats to aggregate.
     */
    where?: WarmupStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarmupStats to fetch.
     */
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarmupStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarmupStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarmupStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarmupStats
    **/
    _count?: true | WarmupStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarmupStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarmupStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarmupStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarmupStatsMaxAggregateInputType
  }

  export type GetWarmupStatsAggregateType<T extends WarmupStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateWarmupStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarmupStats[P]>
      : GetScalarType<T[P], AggregateWarmupStats[P]>
  }




  export type WarmupStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarmupStatsWhereInput
    orderBy?: WarmupStatsOrderByWithAggregationInput | WarmupStatsOrderByWithAggregationInput[]
    by: WarmupStatsScalarFieldEnum[] | WarmupStatsScalarFieldEnum
    having?: WarmupStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarmupStatsCountAggregateInputType | true
    _avg?: WarmupStatsAvgAggregateInputType
    _sum?: WarmupStatsSumAggregateInputType
    _min?: WarmupStatsMinAggregateInputType
    _max?: WarmupStatsMaxAggregateInputType
  }

  export type WarmupStatsGroupByOutputType = {
    id: string
    instanceName: string
    status: string
    messagesSent: number
    messagesReceived: number
    warmupTime: number
    lastActive: Date
    startTime: Date | null
    pauseTime: Date | null
    progress: number
    userId: string
    createdAt: Date
    updatedAt: Date
    mediaStatsId: string | null
    mediaReceivedId: string | null
    _count: WarmupStatsCountAggregateOutputType | null
    _avg: WarmupStatsAvgAggregateOutputType | null
    _sum: WarmupStatsSumAggregateOutputType | null
    _min: WarmupStatsMinAggregateOutputType | null
    _max: WarmupStatsMaxAggregateOutputType | null
  }

  type GetWarmupStatsGroupByPayload<T extends WarmupStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarmupStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarmupStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarmupStatsGroupByOutputType[P]>
            : GetScalarType<T[P], WarmupStatsGroupByOutputType[P]>
        }
      >
    >


  export type WarmupStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    status?: boolean
    messagesSent?: boolean
    messagesReceived?: boolean
    warmupTime?: boolean
    lastActive?: boolean
    startTime?: boolean
    pauseTime?: boolean
    progress?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaStatsId?: boolean
    mediaReceivedId?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    mediaReceived?: boolean | WarmupStats$mediaReceivedArgs<ExtArgs>
    mediaStats?: boolean | WarmupStats$mediaStatsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warmupStats"]>

  export type WarmupStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    status?: boolean
    messagesSent?: boolean
    messagesReceived?: boolean
    warmupTime?: boolean
    lastActive?: boolean
    startTime?: boolean
    pauseTime?: boolean
    progress?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaStatsId?: boolean
    mediaReceivedId?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    mediaReceived?: boolean | WarmupStats$mediaReceivedArgs<ExtArgs>
    mediaStats?: boolean | WarmupStats$mediaStatsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warmupStats"]>

  export type WarmupStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    status?: boolean
    messagesSent?: boolean
    messagesReceived?: boolean
    warmupTime?: boolean
    lastActive?: boolean
    startTime?: boolean
    pauseTime?: boolean
    progress?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaStatsId?: boolean
    mediaReceivedId?: boolean
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    mediaReceived?: boolean | WarmupStats$mediaReceivedArgs<ExtArgs>
    mediaStats?: boolean | WarmupStats$mediaStatsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warmupStats"]>

  export type WarmupStatsSelectScalar = {
    id?: boolean
    instanceName?: boolean
    status?: boolean
    messagesSent?: boolean
    messagesReceived?: boolean
    warmupTime?: boolean
    lastActive?: boolean
    startTime?: boolean
    pauseTime?: boolean
    progress?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaStatsId?: boolean
    mediaReceivedId?: boolean
  }

  export type WarmupStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instanceName" | "status" | "messagesSent" | "messagesReceived" | "warmupTime" | "lastActive" | "startTime" | "pauseTime" | "progress" | "userId" | "createdAt" | "updatedAt" | "mediaStatsId" | "mediaReceivedId", ExtArgs["result"]["warmupStats"]>
  export type WarmupStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    mediaReceived?: boolean | WarmupStats$mediaReceivedArgs<ExtArgs>
    mediaStats?: boolean | WarmupStats$mediaStatsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WarmupStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    mediaReceived?: boolean | WarmupStats$mediaReceivedArgs<ExtArgs>
    mediaStats?: boolean | WarmupStats$mediaStatsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WarmupStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
    mediaReceived?: boolean | WarmupStats$mediaReceivedArgs<ExtArgs>
    mediaStats?: boolean | WarmupStats$mediaStatsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WarmupStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarmupStats"
    objects: {
      instance: Prisma.$InstancePayload<ExtArgs>
      mediaReceived: Prisma.$MediaStatsPayload<ExtArgs> | null
      mediaStats: Prisma.$MediaStatsPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceName: string
      status: string
      messagesSent: number
      messagesReceived: number
      warmupTime: number
      lastActive: Date
      startTime: Date | null
      pauseTime: Date | null
      progress: number
      userId: string
      createdAt: Date
      updatedAt: Date
      mediaStatsId: string | null
      mediaReceivedId: string | null
    }, ExtArgs["result"]["warmupStats"]>
    composites: {}
  }

  type WarmupStatsGetPayload<S extends boolean | null | undefined | WarmupStatsDefaultArgs> = $Result.GetResult<Prisma.$WarmupStatsPayload, S>

  type WarmupStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarmupStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarmupStatsCountAggregateInputType | true
    }

  export interface WarmupStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarmupStats'], meta: { name: 'WarmupStats' } }
    /**
     * Find zero or one WarmupStats that matches the filter.
     * @param {WarmupStatsFindUniqueArgs} args - Arguments to find a WarmupStats
     * @example
     * // Get one WarmupStats
     * const warmupStats = await prisma.warmupStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarmupStatsFindUniqueArgs>(args: SelectSubset<T, WarmupStatsFindUniqueArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WarmupStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarmupStatsFindUniqueOrThrowArgs} args - Arguments to find a WarmupStats
     * @example
     * // Get one WarmupStats
     * const warmupStats = await prisma.warmupStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarmupStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, WarmupStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarmupStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsFindFirstArgs} args - Arguments to find a WarmupStats
     * @example
     * // Get one WarmupStats
     * const warmupStats = await prisma.warmupStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarmupStatsFindFirstArgs>(args?: SelectSubset<T, WarmupStatsFindFirstArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WarmupStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsFindFirstOrThrowArgs} args - Arguments to find a WarmupStats
     * @example
     * // Get one WarmupStats
     * const warmupStats = await prisma.warmupStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarmupStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, WarmupStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WarmupStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarmupStats
     * const warmupStats = await prisma.warmupStats.findMany()
     * 
     * // Get first 10 WarmupStats
     * const warmupStats = await prisma.warmupStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warmupStatsWithIdOnly = await prisma.warmupStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarmupStatsFindManyArgs>(args?: SelectSubset<T, WarmupStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WarmupStats.
     * @param {WarmupStatsCreateArgs} args - Arguments to create a WarmupStats.
     * @example
     * // Create one WarmupStats
     * const WarmupStats = await prisma.warmupStats.create({
     *   data: {
     *     // ... data to create a WarmupStats
     *   }
     * })
     * 
     */
    create<T extends WarmupStatsCreateArgs>(args: SelectSubset<T, WarmupStatsCreateArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WarmupStats.
     * @param {WarmupStatsCreateManyArgs} args - Arguments to create many WarmupStats.
     * @example
     * // Create many WarmupStats
     * const warmupStats = await prisma.warmupStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarmupStatsCreateManyArgs>(args?: SelectSubset<T, WarmupStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WarmupStats and returns the data saved in the database.
     * @param {WarmupStatsCreateManyAndReturnArgs} args - Arguments to create many WarmupStats.
     * @example
     * // Create many WarmupStats
     * const warmupStats = await prisma.warmupStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WarmupStats and only return the `id`
     * const warmupStatsWithIdOnly = await prisma.warmupStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarmupStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, WarmupStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WarmupStats.
     * @param {WarmupStatsDeleteArgs} args - Arguments to delete one WarmupStats.
     * @example
     * // Delete one WarmupStats
     * const WarmupStats = await prisma.warmupStats.delete({
     *   where: {
     *     // ... filter to delete one WarmupStats
     *   }
     * })
     * 
     */
    delete<T extends WarmupStatsDeleteArgs>(args: SelectSubset<T, WarmupStatsDeleteArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WarmupStats.
     * @param {WarmupStatsUpdateArgs} args - Arguments to update one WarmupStats.
     * @example
     * // Update one WarmupStats
     * const warmupStats = await prisma.warmupStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarmupStatsUpdateArgs>(args: SelectSubset<T, WarmupStatsUpdateArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WarmupStats.
     * @param {WarmupStatsDeleteManyArgs} args - Arguments to filter WarmupStats to delete.
     * @example
     * // Delete a few WarmupStats
     * const { count } = await prisma.warmupStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarmupStatsDeleteManyArgs>(args?: SelectSubset<T, WarmupStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarmupStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarmupStats
     * const warmupStats = await prisma.warmupStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarmupStatsUpdateManyArgs>(args: SelectSubset<T, WarmupStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarmupStats and returns the data updated in the database.
     * @param {WarmupStatsUpdateManyAndReturnArgs} args - Arguments to update many WarmupStats.
     * @example
     * // Update many WarmupStats
     * const warmupStats = await prisma.warmupStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WarmupStats and only return the `id`
     * const warmupStatsWithIdOnly = await prisma.warmupStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarmupStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, WarmupStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WarmupStats.
     * @param {WarmupStatsUpsertArgs} args - Arguments to update or create a WarmupStats.
     * @example
     * // Update or create a WarmupStats
     * const warmupStats = await prisma.warmupStats.upsert({
     *   create: {
     *     // ... data to create a WarmupStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarmupStats we want to update
     *   }
     * })
     */
    upsert<T extends WarmupStatsUpsertArgs>(args: SelectSubset<T, WarmupStatsUpsertArgs<ExtArgs>>): Prisma__WarmupStatsClient<$Result.GetResult<Prisma.$WarmupStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WarmupStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsCountArgs} args - Arguments to filter WarmupStats to count.
     * @example
     * // Count the number of WarmupStats
     * const count = await prisma.warmupStats.count({
     *   where: {
     *     // ... the filter for the WarmupStats we want to count
     *   }
     * })
    **/
    count<T extends WarmupStatsCountArgs>(
      args?: Subset<T, WarmupStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarmupStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarmupStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarmupStatsAggregateArgs>(args: Subset<T, WarmupStatsAggregateArgs>): Prisma.PrismaPromise<GetWarmupStatsAggregateType<T>>

    /**
     * Group by WarmupStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarmupStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarmupStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarmupStatsGroupByArgs['orderBy'] }
        : { orderBy?: WarmupStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarmupStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarmupStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarmupStats model
   */
  readonly fields: WarmupStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarmupStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarmupStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mediaReceived<T extends WarmupStats$mediaReceivedArgs<ExtArgs> = {}>(args?: Subset<T, WarmupStats$mediaReceivedArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mediaStats<T extends WarmupStats$mediaStatsArgs<ExtArgs> = {}>(args?: Subset<T, WarmupStats$mediaStatsArgs<ExtArgs>>): Prisma__MediaStatsClient<$Result.GetResult<Prisma.$MediaStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WarmupStats model
   */
  interface WarmupStatsFieldRefs {
    readonly id: FieldRef<"WarmupStats", 'String'>
    readonly instanceName: FieldRef<"WarmupStats", 'String'>
    readonly status: FieldRef<"WarmupStats", 'String'>
    readonly messagesSent: FieldRef<"WarmupStats", 'Int'>
    readonly messagesReceived: FieldRef<"WarmupStats", 'Int'>
    readonly warmupTime: FieldRef<"WarmupStats", 'Int'>
    readonly lastActive: FieldRef<"WarmupStats", 'DateTime'>
    readonly startTime: FieldRef<"WarmupStats", 'DateTime'>
    readonly pauseTime: FieldRef<"WarmupStats", 'DateTime'>
    readonly progress: FieldRef<"WarmupStats", 'Int'>
    readonly userId: FieldRef<"WarmupStats", 'String'>
    readonly createdAt: FieldRef<"WarmupStats", 'DateTime'>
    readonly updatedAt: FieldRef<"WarmupStats", 'DateTime'>
    readonly mediaStatsId: FieldRef<"WarmupStats", 'String'>
    readonly mediaReceivedId: FieldRef<"WarmupStats", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WarmupStats findUnique
   */
  export type WarmupStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * Filter, which WarmupStats to fetch.
     */
    where: WarmupStatsWhereUniqueInput
  }

  /**
   * WarmupStats findUniqueOrThrow
   */
  export type WarmupStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * Filter, which WarmupStats to fetch.
     */
    where: WarmupStatsWhereUniqueInput
  }

  /**
   * WarmupStats findFirst
   */
  export type WarmupStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * Filter, which WarmupStats to fetch.
     */
    where?: WarmupStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarmupStats to fetch.
     */
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarmupStats.
     */
    cursor?: WarmupStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarmupStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarmupStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarmupStats.
     */
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * WarmupStats findFirstOrThrow
   */
  export type WarmupStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * Filter, which WarmupStats to fetch.
     */
    where?: WarmupStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarmupStats to fetch.
     */
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarmupStats.
     */
    cursor?: WarmupStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarmupStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarmupStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarmupStats.
     */
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * WarmupStats findMany
   */
  export type WarmupStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * Filter, which WarmupStats to fetch.
     */
    where?: WarmupStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarmupStats to fetch.
     */
    orderBy?: WarmupStatsOrderByWithRelationInput | WarmupStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarmupStats.
     */
    cursor?: WarmupStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarmupStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarmupStats.
     */
    skip?: number
    distinct?: WarmupStatsScalarFieldEnum | WarmupStatsScalarFieldEnum[]
  }

  /**
   * WarmupStats create
   */
  export type WarmupStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a WarmupStats.
     */
    data: XOR<WarmupStatsCreateInput, WarmupStatsUncheckedCreateInput>
  }

  /**
   * WarmupStats createMany
   */
  export type WarmupStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarmupStats.
     */
    data: WarmupStatsCreateManyInput | WarmupStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WarmupStats createManyAndReturn
   */
  export type WarmupStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * The data used to create many WarmupStats.
     */
    data: WarmupStatsCreateManyInput | WarmupStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarmupStats update
   */
  export type WarmupStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a WarmupStats.
     */
    data: XOR<WarmupStatsUpdateInput, WarmupStatsUncheckedUpdateInput>
    /**
     * Choose, which WarmupStats to update.
     */
    where: WarmupStatsWhereUniqueInput
  }

  /**
   * WarmupStats updateMany
   */
  export type WarmupStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarmupStats.
     */
    data: XOR<WarmupStatsUpdateManyMutationInput, WarmupStatsUncheckedUpdateManyInput>
    /**
     * Filter which WarmupStats to update
     */
    where?: WarmupStatsWhereInput
    /**
     * Limit how many WarmupStats to update.
     */
    limit?: number
  }

  /**
   * WarmupStats updateManyAndReturn
   */
  export type WarmupStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * The data used to update WarmupStats.
     */
    data: XOR<WarmupStatsUpdateManyMutationInput, WarmupStatsUncheckedUpdateManyInput>
    /**
     * Filter which WarmupStats to update
     */
    where?: WarmupStatsWhereInput
    /**
     * Limit how many WarmupStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WarmupStats upsert
   */
  export type WarmupStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the WarmupStats to update in case it exists.
     */
    where: WarmupStatsWhereUniqueInput
    /**
     * In case the WarmupStats found by the `where` argument doesn't exist, create a new WarmupStats with this data.
     */
    create: XOR<WarmupStatsCreateInput, WarmupStatsUncheckedCreateInput>
    /**
     * In case the WarmupStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarmupStatsUpdateInput, WarmupStatsUncheckedUpdateInput>
  }

  /**
   * WarmupStats delete
   */
  export type WarmupStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
    /**
     * Filter which WarmupStats to delete.
     */
    where: WarmupStatsWhereUniqueInput
  }

  /**
   * WarmupStats deleteMany
   */
  export type WarmupStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarmupStats to delete
     */
    where?: WarmupStatsWhereInput
    /**
     * Limit how many WarmupStats to delete.
     */
    limit?: number
  }

  /**
   * WarmupStats.mediaReceived
   */
  export type WarmupStats$mediaReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    where?: MediaStatsWhereInput
  }

  /**
   * WarmupStats.mediaStats
   */
  export type WarmupStats$mediaStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaStats
     */
    select?: MediaStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaStats
     */
    omit?: MediaStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaStatsInclude<ExtArgs> | null
    where?: MediaStatsWhereInput
  }

  /**
   * WarmupStats without action
   */
  export type WarmupStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarmupStats
     */
    select?: WarmupStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WarmupStats
     */
    omit?: WarmupStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarmupStatsInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    progress: number | null
    minDelay: number | null
    maxDelay: number | null
  }

  export type CampaignSumAggregateOutputType = {
    progress: number | null
    minDelay: number | null
    maxDelay: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    type: string | null
    message: string | null
    mediaUrl: string | null
    mediaType: string | null
    mediaCaption: string | null
    scheduledDate: Date | null
    scheduledStatus: string | null
    startedAt: Date | null
    completedAt: Date | null
    pausedAt: Date | null
    progress: number | null
    minDelay: number | null
    maxDelay: number | null
    userId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    type: string | null
    message: string | null
    mediaUrl: string | null
    mediaType: string | null
    mediaCaption: string | null
    scheduledDate: Date | null
    scheduledStatus: string | null
    startedAt: Date | null
    completedAt: Date | null
    pausedAt: Date | null
    progress: number | null
    minDelay: number | null
    maxDelay: number | null
    userId: string | null
    instanceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    type: number
    message: number
    mediaUrl: number
    mediaType: number
    mediaCaption: number
    scheduledDate: number
    scheduledStatus: number
    startedAt: number
    completedAt: number
    pausedAt: number
    progress: number
    minDelay: number
    maxDelay: number
    userId: number
    instanceId: number
    createdAt: number
    updatedAt: number
    isAiResponder: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    progress?: true
    minDelay?: true
    maxDelay?: true
  }

  export type CampaignSumAggregateInputType = {
    progress?: true
    minDelay?: true
    maxDelay?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    type?: true
    message?: true
    mediaUrl?: true
    mediaType?: true
    mediaCaption?: true
    scheduledDate?: true
    scheduledStatus?: true
    startedAt?: true
    completedAt?: true
    pausedAt?: true
    progress?: true
    minDelay?: true
    maxDelay?: true
    userId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    type?: true
    message?: true
    mediaUrl?: true
    mediaType?: true
    mediaCaption?: true
    scheduledDate?: true
    scheduledStatus?: true
    startedAt?: true
    completedAt?: true
    pausedAt?: true
    progress?: true
    minDelay?: true
    maxDelay?: true
    userId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    type?: true
    message?: true
    mediaUrl?: true
    mediaType?: true
    mediaCaption?: true
    scheduledDate?: true
    scheduledStatus?: true
    startedAt?: true
    completedAt?: true
    pausedAt?: true
    progress?: true
    minDelay?: true
    maxDelay?: true
    userId?: true
    instanceId?: true
    createdAt?: true
    updatedAt?: true
    isAiResponder?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: string
    type: string
    message: string | null
    mediaUrl: string | null
    mediaType: string | null
    mediaCaption: string | null
    scheduledDate: Date | null
    scheduledStatus: string | null
    startedAt: Date | null
    completedAt: Date | null
    pausedAt: Date | null
    progress: number
    minDelay: number
    maxDelay: number
    userId: string
    instanceId: string | null
    createdAt: Date
    updatedAt: Date
    isAiResponder: JsonValue | null
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    type?: boolean
    message?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    mediaCaption?: boolean
    scheduledDate?: boolean
    scheduledStatus?: boolean
    startedAt?: boolean
    completedAt?: boolean
    pausedAt?: boolean
    progress?: boolean
    minDelay?: boolean
    maxDelay?: boolean
    userId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAiResponder?: boolean
    MessageLog?: boolean | Campaign$MessageLogArgs<ExtArgs>
    leads?: boolean | Campaign$leadsArgs<ExtArgs>
    messages?: boolean | Campaign$messagesArgs<ExtArgs>
    statistics?: boolean | Campaign$statisticsArgs<ExtArgs>
    dispatches?: boolean | Campaign$dispatchesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    instance?: boolean | Campaign$instanceArgs<ExtArgs>
    CampaignErrorLog?: boolean | Campaign$CampaignErrorLogArgs<ExtArgs>
    CampaignSchedule?: boolean | Campaign$CampaignScheduleArgs<ExtArgs>
    MessageAnalytics?: boolean | Campaign$MessageAnalyticsArgs<ExtArgs>
    contacts?: boolean | Campaign$contactsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    type?: boolean
    message?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    mediaCaption?: boolean
    scheduledDate?: boolean
    scheduledStatus?: boolean
    startedAt?: boolean
    completedAt?: boolean
    pausedAt?: boolean
    progress?: boolean
    minDelay?: boolean
    maxDelay?: boolean
    userId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAiResponder?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    instance?: boolean | Campaign$instanceArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    type?: boolean
    message?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    mediaCaption?: boolean
    scheduledDate?: boolean
    scheduledStatus?: boolean
    startedAt?: boolean
    completedAt?: boolean
    pausedAt?: boolean
    progress?: boolean
    minDelay?: boolean
    maxDelay?: boolean
    userId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAiResponder?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    instance?: boolean | Campaign$instanceArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    type?: boolean
    message?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    mediaCaption?: boolean
    scheduledDate?: boolean
    scheduledStatus?: boolean
    startedAt?: boolean
    completedAt?: boolean
    pausedAt?: boolean
    progress?: boolean
    minDelay?: boolean
    maxDelay?: boolean
    userId?: boolean
    instanceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isAiResponder?: boolean
  }

  export type CampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "type" | "message" | "mediaUrl" | "mediaType" | "mediaCaption" | "scheduledDate" | "scheduledStatus" | "startedAt" | "completedAt" | "pausedAt" | "progress" | "minDelay" | "maxDelay" | "userId" | "instanceId" | "createdAt" | "updatedAt" | "isAiResponder", ExtArgs["result"]["campaign"]>
  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageLog?: boolean | Campaign$MessageLogArgs<ExtArgs>
    leads?: boolean | Campaign$leadsArgs<ExtArgs>
    messages?: boolean | Campaign$messagesArgs<ExtArgs>
    statistics?: boolean | Campaign$statisticsArgs<ExtArgs>
    dispatches?: boolean | Campaign$dispatchesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    instance?: boolean | Campaign$instanceArgs<ExtArgs>
    CampaignErrorLog?: boolean | Campaign$CampaignErrorLogArgs<ExtArgs>
    CampaignSchedule?: boolean | Campaign$CampaignScheduleArgs<ExtArgs>
    MessageAnalytics?: boolean | Campaign$MessageAnalyticsArgs<ExtArgs>
    contacts?: boolean | Campaign$contactsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    instance?: boolean | Campaign$instanceArgs<ExtArgs>
  }
  export type CampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    instance?: boolean | Campaign$instanceArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      MessageLog: Prisma.$MessageLogPayload<ExtArgs>[]
      leads: Prisma.$CampaignLeadPayload<ExtArgs>[]
      messages: Prisma.$CampaignMessagePayload<ExtArgs>[]
      statistics: Prisma.$CampaignStatisticsPayload<ExtArgs> | null
      dispatches: Prisma.$CampaignDispatchPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      instance: Prisma.$InstancePayload<ExtArgs> | null
      CampaignErrorLog: Prisma.$CampaignErrorLogPayload<ExtArgs>[]
      CampaignSchedule: Prisma.$CampaignSchedulePayload<ExtArgs>[]
      MessageAnalytics: Prisma.$MessageAnalyticsPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: string
      type: string
      message: string | null
      mediaUrl: string | null
      mediaType: string | null
      mediaCaption: string | null
      scheduledDate: Date | null
      scheduledStatus: string | null
      startedAt: Date | null
      completedAt: Date | null
      pausedAt: Date | null
      progress: number
      minDelay: number
      maxDelay: number
      userId: string
      instanceId: string | null
      createdAt: Date
      updatedAt: Date
      isAiResponder: Prisma.JsonValue | null
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns and returns the data updated in the database.
     * @param {CampaignUpdateManyAndReturnArgs} args - Arguments to update many Campaigns.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    MessageLog<T extends Campaign$MessageLogArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$MessageLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leads<T extends Campaign$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Campaign$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statistics<T extends Campaign$statisticsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$statisticsArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dispatches<T extends Campaign$dispatchesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$dispatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    instance<T extends Campaign$instanceArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$instanceArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CampaignErrorLog<T extends Campaign$CampaignErrorLogArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$CampaignErrorLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignErrorLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CampaignSchedule<T extends Campaign$CampaignScheduleArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$CampaignScheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MessageAnalytics<T extends Campaign$MessageAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$MessageAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends Campaign$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly status: FieldRef<"Campaign", 'String'>
    readonly type: FieldRef<"Campaign", 'String'>
    readonly message: FieldRef<"Campaign", 'String'>
    readonly mediaUrl: FieldRef<"Campaign", 'String'>
    readonly mediaType: FieldRef<"Campaign", 'String'>
    readonly mediaCaption: FieldRef<"Campaign", 'String'>
    readonly scheduledDate: FieldRef<"Campaign", 'DateTime'>
    readonly scheduledStatus: FieldRef<"Campaign", 'String'>
    readonly startedAt: FieldRef<"Campaign", 'DateTime'>
    readonly completedAt: FieldRef<"Campaign", 'DateTime'>
    readonly pausedAt: FieldRef<"Campaign", 'DateTime'>
    readonly progress: FieldRef<"Campaign", 'Int'>
    readonly minDelay: FieldRef<"Campaign", 'Int'>
    readonly maxDelay: FieldRef<"Campaign", 'Int'>
    readonly userId: FieldRef<"Campaign", 'String'>
    readonly instanceId: FieldRef<"Campaign", 'String'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
    readonly isAiResponder: FieldRef<"Campaign", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign updateManyAndReturn
   */
  export type CampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to delete.
     */
    limit?: number
  }

  /**
   * Campaign.MessageLog
   */
  export type Campaign$MessageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    where?: MessageLogWhereInput
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    cursor?: MessageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageLogScalarFieldEnum | MessageLogScalarFieldEnum[]
  }

  /**
   * Campaign.leads
   */
  export type Campaign$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    where?: CampaignLeadWhereInput
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    cursor?: CampaignLeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }

  /**
   * Campaign.messages
   */
  export type Campaign$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    where?: CampaignMessageWhereInput
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    cursor?: CampaignMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * Campaign.statistics
   */
  export type Campaign$statisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    where?: CampaignStatisticsWhereInput
  }

  /**
   * Campaign.dispatches
   */
  export type Campaign$dispatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchInclude<ExtArgs> | null
    where?: CampaignDispatchWhereInput
    orderBy?: CampaignDispatchOrderByWithRelationInput | CampaignDispatchOrderByWithRelationInput[]
    cursor?: CampaignDispatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignDispatchScalarFieldEnum | CampaignDispatchScalarFieldEnum[]
  }

  /**
   * Campaign.instance
   */
  export type Campaign$instanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    where?: InstanceWhereInput
  }

  /**
   * Campaign.CampaignErrorLog
   */
  export type Campaign$CampaignErrorLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogInclude<ExtArgs> | null
    where?: CampaignErrorLogWhereInput
    orderBy?: CampaignErrorLogOrderByWithRelationInput | CampaignErrorLogOrderByWithRelationInput[]
    cursor?: CampaignErrorLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignErrorLogScalarFieldEnum | CampaignErrorLogScalarFieldEnum[]
  }

  /**
   * Campaign.CampaignSchedule
   */
  export type Campaign$CampaignScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleInclude<ExtArgs> | null
    where?: CampaignScheduleWhereInput
    orderBy?: CampaignScheduleOrderByWithRelationInput | CampaignScheduleOrderByWithRelationInput[]
    cursor?: CampaignScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScheduleScalarFieldEnum | CampaignScheduleScalarFieldEnum[]
  }

  /**
   * Campaign.MessageAnalytics
   */
  export type Campaign$MessageAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsInclude<ExtArgs> | null
    where?: MessageAnalyticsWhereInput
    orderBy?: MessageAnalyticsOrderByWithRelationInput | MessageAnalyticsOrderByWithRelationInput[]
    cursor?: MessageAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageAnalyticsScalarFieldEnum | MessageAnalyticsScalarFieldEnum[]
  }

  /**
   * Campaign.contacts
   */
  export type Campaign$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignDispatch
   */

  export type AggregateCampaignDispatch = {
    _count: CampaignDispatchCountAggregateOutputType | null
    _min: CampaignDispatchMinAggregateOutputType | null
    _max: CampaignDispatchMaxAggregateOutputType | null
  }

  export type CampaignDispatchMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    instanceName: string | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignDispatchMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    instanceName: string | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignDispatchCountAggregateOutputType = {
    id: number
    campaignId: number
    instanceName: number
    status: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignDispatchMinAggregateInputType = {
    id?: true
    campaignId?: true
    instanceName?: true
    status?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignDispatchMaxAggregateInputType = {
    id?: true
    campaignId?: true
    instanceName?: true
    status?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignDispatchCountAggregateInputType = {
    id?: true
    campaignId?: true
    instanceName?: true
    status?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignDispatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignDispatch to aggregate.
     */
    where?: CampaignDispatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignDispatches to fetch.
     */
    orderBy?: CampaignDispatchOrderByWithRelationInput | CampaignDispatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignDispatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignDispatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignDispatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignDispatches
    **/
    _count?: true | CampaignDispatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignDispatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignDispatchMaxAggregateInputType
  }

  export type GetCampaignDispatchAggregateType<T extends CampaignDispatchAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignDispatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignDispatch[P]>
      : GetScalarType<T[P], AggregateCampaignDispatch[P]>
  }




  export type CampaignDispatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignDispatchWhereInput
    orderBy?: CampaignDispatchOrderByWithAggregationInput | CampaignDispatchOrderByWithAggregationInput[]
    by: CampaignDispatchScalarFieldEnum[] | CampaignDispatchScalarFieldEnum
    having?: CampaignDispatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignDispatchCountAggregateInputType | true
    _min?: CampaignDispatchMinAggregateInputType
    _max?: CampaignDispatchMaxAggregateInputType
  }

  export type CampaignDispatchGroupByOutputType = {
    id: string
    campaignId: string
    instanceName: string
    status: string
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignDispatchCountAggregateOutputType | null
    _min: CampaignDispatchMinAggregateOutputType | null
    _max: CampaignDispatchMaxAggregateOutputType | null
  }

  type GetCampaignDispatchGroupByPayload<T extends CampaignDispatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignDispatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignDispatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignDispatchGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignDispatchGroupByOutputType[P]>
        }
      >
    >


  export type CampaignDispatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    instanceName?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignDispatch"]>

  export type CampaignDispatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    instanceName?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignDispatch"]>

  export type CampaignDispatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    instanceName?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignDispatch"]>

  export type CampaignDispatchSelectScalar = {
    id?: boolean
    campaignId?: boolean
    instanceName?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignDispatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "instanceName" | "status" | "startedAt" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["campaignDispatch"]>
  export type CampaignDispatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }
  export type CampaignDispatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }
  export type CampaignDispatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $CampaignDispatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignDispatch"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      instanceName: string
      status: string
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignDispatch"]>
    composites: {}
  }

  type CampaignDispatchGetPayload<S extends boolean | null | undefined | CampaignDispatchDefaultArgs> = $Result.GetResult<Prisma.$CampaignDispatchPayload, S>

  type CampaignDispatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignDispatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignDispatchCountAggregateInputType | true
    }

  export interface CampaignDispatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignDispatch'], meta: { name: 'CampaignDispatch' } }
    /**
     * Find zero or one CampaignDispatch that matches the filter.
     * @param {CampaignDispatchFindUniqueArgs} args - Arguments to find a CampaignDispatch
     * @example
     * // Get one CampaignDispatch
     * const campaignDispatch = await prisma.campaignDispatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignDispatchFindUniqueArgs>(args: SelectSubset<T, CampaignDispatchFindUniqueArgs<ExtArgs>>): Prisma__CampaignDispatchClient<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignDispatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignDispatchFindUniqueOrThrowArgs} args - Arguments to find a CampaignDispatch
     * @example
     * // Get one CampaignDispatch
     * const campaignDispatch = await prisma.campaignDispatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignDispatchFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignDispatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignDispatchClient<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignDispatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignDispatchFindFirstArgs} args - Arguments to find a CampaignDispatch
     * @example
     * // Get one CampaignDispatch
     * const campaignDispatch = await prisma.campaignDispatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignDispatchFindFirstArgs>(args?: SelectSubset<T, CampaignDispatchFindFirstArgs<ExtArgs>>): Prisma__CampaignDispatchClient<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignDispatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignDispatchFindFirstOrThrowArgs} args - Arguments to find a CampaignDispatch
     * @example
     * // Get one CampaignDispatch
     * const campaignDispatch = await prisma.campaignDispatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignDispatchFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignDispatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignDispatchClient<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignDispatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignDispatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignDispatches
     * const campaignDispatches = await prisma.campaignDispatch.findMany()
     * 
     * // Get first 10 CampaignDispatches
     * const campaignDispatches = await prisma.campaignDispatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignDispatchWithIdOnly = await prisma.campaignDispatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignDispatchFindManyArgs>(args?: SelectSubset<T, CampaignDispatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignDispatch.
     * @param {CampaignDispatchCreateArgs} args - Arguments to create a CampaignDispatch.
     * @example
     * // Create one CampaignDispatch
     * const CampaignDispatch = await prisma.campaignDispatch.create({
     *   data: {
     *     // ... data to create a CampaignDispatch
     *   }
     * })
     * 
     */
    create<T extends CampaignDispatchCreateArgs>(args: SelectSubset<T, CampaignDispatchCreateArgs<ExtArgs>>): Prisma__CampaignDispatchClient<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignDispatches.
     * @param {CampaignDispatchCreateManyArgs} args - Arguments to create many CampaignDispatches.
     * @example
     * // Create many CampaignDispatches
     * const campaignDispatch = await prisma.campaignDispatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignDispatchCreateManyArgs>(args?: SelectSubset<T, CampaignDispatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignDispatches and returns the data saved in the database.
     * @param {CampaignDispatchCreateManyAndReturnArgs} args - Arguments to create many CampaignDispatches.
     * @example
     * // Create many CampaignDispatches
     * const campaignDispatch = await prisma.campaignDispatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignDispatches and only return the `id`
     * const campaignDispatchWithIdOnly = await prisma.campaignDispatch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignDispatchCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignDispatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignDispatch.
     * @param {CampaignDispatchDeleteArgs} args - Arguments to delete one CampaignDispatch.
     * @example
     * // Delete one CampaignDispatch
     * const CampaignDispatch = await prisma.campaignDispatch.delete({
     *   where: {
     *     // ... filter to delete one CampaignDispatch
     *   }
     * })
     * 
     */
    delete<T extends CampaignDispatchDeleteArgs>(args: SelectSubset<T, CampaignDispatchDeleteArgs<ExtArgs>>): Prisma__CampaignDispatchClient<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignDispatch.
     * @param {CampaignDispatchUpdateArgs} args - Arguments to update one CampaignDispatch.
     * @example
     * // Update one CampaignDispatch
     * const campaignDispatch = await prisma.campaignDispatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignDispatchUpdateArgs>(args: SelectSubset<T, CampaignDispatchUpdateArgs<ExtArgs>>): Prisma__CampaignDispatchClient<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignDispatches.
     * @param {CampaignDispatchDeleteManyArgs} args - Arguments to filter CampaignDispatches to delete.
     * @example
     * // Delete a few CampaignDispatches
     * const { count } = await prisma.campaignDispatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDispatchDeleteManyArgs>(args?: SelectSubset<T, CampaignDispatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignDispatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignDispatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignDispatches
     * const campaignDispatch = await prisma.campaignDispatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignDispatchUpdateManyArgs>(args: SelectSubset<T, CampaignDispatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignDispatches and returns the data updated in the database.
     * @param {CampaignDispatchUpdateManyAndReturnArgs} args - Arguments to update many CampaignDispatches.
     * @example
     * // Update many CampaignDispatches
     * const campaignDispatch = await prisma.campaignDispatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignDispatches and only return the `id`
     * const campaignDispatchWithIdOnly = await prisma.campaignDispatch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignDispatchUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignDispatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignDispatch.
     * @param {CampaignDispatchUpsertArgs} args - Arguments to update or create a CampaignDispatch.
     * @example
     * // Update or create a CampaignDispatch
     * const campaignDispatch = await prisma.campaignDispatch.upsert({
     *   create: {
     *     // ... data to create a CampaignDispatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignDispatch we want to update
     *   }
     * })
     */
    upsert<T extends CampaignDispatchUpsertArgs>(args: SelectSubset<T, CampaignDispatchUpsertArgs<ExtArgs>>): Prisma__CampaignDispatchClient<$Result.GetResult<Prisma.$CampaignDispatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignDispatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignDispatchCountArgs} args - Arguments to filter CampaignDispatches to count.
     * @example
     * // Count the number of CampaignDispatches
     * const count = await prisma.campaignDispatch.count({
     *   where: {
     *     // ... the filter for the CampaignDispatches we want to count
     *   }
     * })
    **/
    count<T extends CampaignDispatchCountArgs>(
      args?: Subset<T, CampaignDispatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignDispatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignDispatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignDispatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignDispatchAggregateArgs>(args: Subset<T, CampaignDispatchAggregateArgs>): Prisma.PrismaPromise<GetCampaignDispatchAggregateType<T>>

    /**
     * Group by CampaignDispatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignDispatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignDispatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignDispatchGroupByArgs['orderBy'] }
        : { orderBy?: CampaignDispatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignDispatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignDispatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignDispatch model
   */
  readonly fields: CampaignDispatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignDispatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignDispatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignDispatch model
   */
  interface CampaignDispatchFieldRefs {
    readonly id: FieldRef<"CampaignDispatch", 'String'>
    readonly campaignId: FieldRef<"CampaignDispatch", 'String'>
    readonly instanceName: FieldRef<"CampaignDispatch", 'String'>
    readonly status: FieldRef<"CampaignDispatch", 'String'>
    readonly startedAt: FieldRef<"CampaignDispatch", 'DateTime'>
    readonly completedAt: FieldRef<"CampaignDispatch", 'DateTime'>
    readonly createdAt: FieldRef<"CampaignDispatch", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignDispatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignDispatch findUnique
   */
  export type CampaignDispatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchInclude<ExtArgs> | null
    /**
     * Filter, which CampaignDispatch to fetch.
     */
    where: CampaignDispatchWhereUniqueInput
  }

  /**
   * CampaignDispatch findUniqueOrThrow
   */
  export type CampaignDispatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchInclude<ExtArgs> | null
    /**
     * Filter, which CampaignDispatch to fetch.
     */
    where: CampaignDispatchWhereUniqueInput
  }

  /**
   * CampaignDispatch findFirst
   */
  export type CampaignDispatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchInclude<ExtArgs> | null
    /**
     * Filter, which CampaignDispatch to fetch.
     */
    where?: CampaignDispatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignDispatches to fetch.
     */
    orderBy?: CampaignDispatchOrderByWithRelationInput | CampaignDispatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignDispatches.
     */
    cursor?: CampaignDispatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignDispatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignDispatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignDispatches.
     */
    distinct?: CampaignDispatchScalarFieldEnum | CampaignDispatchScalarFieldEnum[]
  }

  /**
   * CampaignDispatch findFirstOrThrow
   */
  export type CampaignDispatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchInclude<ExtArgs> | null
    /**
     * Filter, which CampaignDispatch to fetch.
     */
    where?: CampaignDispatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignDispatches to fetch.
     */
    orderBy?: CampaignDispatchOrderByWithRelationInput | CampaignDispatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignDispatches.
     */
    cursor?: CampaignDispatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignDispatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignDispatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignDispatches.
     */
    distinct?: CampaignDispatchScalarFieldEnum | CampaignDispatchScalarFieldEnum[]
  }

  /**
   * CampaignDispatch findMany
   */
  export type CampaignDispatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchInclude<ExtArgs> | null
    /**
     * Filter, which CampaignDispatches to fetch.
     */
    where?: CampaignDispatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignDispatches to fetch.
     */
    orderBy?: CampaignDispatchOrderByWithRelationInput | CampaignDispatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignDispatches.
     */
    cursor?: CampaignDispatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignDispatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignDispatches.
     */
    skip?: number
    distinct?: CampaignDispatchScalarFieldEnum | CampaignDispatchScalarFieldEnum[]
  }

  /**
   * CampaignDispatch create
   */
  export type CampaignDispatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignDispatch.
     */
    data: XOR<CampaignDispatchCreateInput, CampaignDispatchUncheckedCreateInput>
  }

  /**
   * CampaignDispatch createMany
   */
  export type CampaignDispatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignDispatches.
     */
    data: CampaignDispatchCreateManyInput | CampaignDispatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignDispatch createManyAndReturn
   */
  export type CampaignDispatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignDispatches.
     */
    data: CampaignDispatchCreateManyInput | CampaignDispatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignDispatch update
   */
  export type CampaignDispatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignDispatch.
     */
    data: XOR<CampaignDispatchUpdateInput, CampaignDispatchUncheckedUpdateInput>
    /**
     * Choose, which CampaignDispatch to update.
     */
    where: CampaignDispatchWhereUniqueInput
  }

  /**
   * CampaignDispatch updateMany
   */
  export type CampaignDispatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignDispatches.
     */
    data: XOR<CampaignDispatchUpdateManyMutationInput, CampaignDispatchUncheckedUpdateManyInput>
    /**
     * Filter which CampaignDispatches to update
     */
    where?: CampaignDispatchWhereInput
    /**
     * Limit how many CampaignDispatches to update.
     */
    limit?: number
  }

  /**
   * CampaignDispatch updateManyAndReturn
   */
  export type CampaignDispatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * The data used to update CampaignDispatches.
     */
    data: XOR<CampaignDispatchUpdateManyMutationInput, CampaignDispatchUncheckedUpdateManyInput>
    /**
     * Filter which CampaignDispatches to update
     */
    where?: CampaignDispatchWhereInput
    /**
     * Limit how many CampaignDispatches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignDispatch upsert
   */
  export type CampaignDispatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignDispatch to update in case it exists.
     */
    where: CampaignDispatchWhereUniqueInput
    /**
     * In case the CampaignDispatch found by the `where` argument doesn't exist, create a new CampaignDispatch with this data.
     */
    create: XOR<CampaignDispatchCreateInput, CampaignDispatchUncheckedCreateInput>
    /**
     * In case the CampaignDispatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignDispatchUpdateInput, CampaignDispatchUncheckedUpdateInput>
  }

  /**
   * CampaignDispatch delete
   */
  export type CampaignDispatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchInclude<ExtArgs> | null
    /**
     * Filter which CampaignDispatch to delete.
     */
    where: CampaignDispatchWhereUniqueInput
  }

  /**
   * CampaignDispatch deleteMany
   */
  export type CampaignDispatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignDispatches to delete
     */
    where?: CampaignDispatchWhereInput
    /**
     * Limit how many CampaignDispatches to delete.
     */
    limit?: number
  }

  /**
   * CampaignDispatch without action
   */
  export type CampaignDispatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignDispatch
     */
    select?: CampaignDispatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignDispatch
     */
    omit?: CampaignDispatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignDispatchInclude<ExtArgs> | null
  }


  /**
   * Model CampaignMessage
   */

  export type AggregateCampaignMessage = {
    _count: CampaignMessageCountAggregateOutputType | null
    _avg: CampaignMessageAvgAggregateOutputType | null
    _sum: CampaignMessageSumAggregateOutputType | null
    _min: CampaignMessageMinAggregateOutputType | null
    _max: CampaignMessageMaxAggregateOutputType | null
  }

  export type CampaignMessageAvgAggregateOutputType = {
    order: number | null
  }

  export type CampaignMessageSumAggregateOutputType = {
    order: number | null
  }

  export type CampaignMessageMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    type: string | null
    content: string | null
    order: number | null
    caption: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMessageMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    type: string | null
    content: string | null
    order: number | null
    caption: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMessageCountAggregateOutputType = {
    id: number
    campaignId: number
    type: number
    content: number
    order: number
    caption: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignMessageAvgAggregateInputType = {
    order?: true
  }

  export type CampaignMessageSumAggregateInputType = {
    order?: true
  }

  export type CampaignMessageMinAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    content?: true
    order?: true
    caption?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMessageMaxAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    content?: true
    order?: true
    caption?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMessageCountAggregateInputType = {
    id?: true
    campaignId?: true
    type?: true
    content?: true
    order?: true
    caption?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMessage to aggregate.
     */
    where?: CampaignMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMessages to fetch.
     */
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignMessages
    **/
    _count?: true | CampaignMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMessageMaxAggregateInputType
  }

  export type GetCampaignMessageAggregateType<T extends CampaignMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignMessage[P]>
      : GetScalarType<T[P], AggregateCampaignMessage[P]>
  }




  export type CampaignMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMessageWhereInput
    orderBy?: CampaignMessageOrderByWithAggregationInput | CampaignMessageOrderByWithAggregationInput[]
    by: CampaignMessageScalarFieldEnum[] | CampaignMessageScalarFieldEnum
    having?: CampaignMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignMessageCountAggregateInputType | true
    _avg?: CampaignMessageAvgAggregateInputType
    _sum?: CampaignMessageSumAggregateInputType
    _min?: CampaignMessageMinAggregateInputType
    _max?: CampaignMessageMaxAggregateInputType
  }

  export type CampaignMessageGroupByOutputType = {
    id: string
    campaignId: string
    type: string
    content: string
    order: number
    caption: string | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignMessageCountAggregateOutputType | null
    _avg: CampaignMessageAvgAggregateOutputType | null
    _sum: CampaignMessageSumAggregateOutputType | null
    _min: CampaignMessageMinAggregateOutputType | null
    _max: CampaignMessageMaxAggregateOutputType | null
  }

  type GetCampaignMessageGroupByPayload<T extends CampaignMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignMessageGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignMessageGroupByOutputType[P]>
        }
      >
    >


  export type CampaignMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    caption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMessage"]>

  export type CampaignMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    caption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMessage"]>

  export type CampaignMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    caption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMessage"]>

  export type CampaignMessageSelectScalar = {
    id?: boolean
    campaignId?: boolean
    type?: boolean
    content?: boolean
    order?: boolean
    caption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "type" | "content" | "order" | "caption" | "createdAt" | "updatedAt", ExtArgs["result"]["campaignMessage"]>
  export type CampaignMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignMessage"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      type: string
      content: string
      order: number
      caption: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignMessage"]>
    composites: {}
  }

  type CampaignMessageGetPayload<S extends boolean | null | undefined | CampaignMessageDefaultArgs> = $Result.GetResult<Prisma.$CampaignMessagePayload, S>

  type CampaignMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignMessageCountAggregateInputType | true
    }

  export interface CampaignMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignMessage'], meta: { name: 'CampaignMessage' } }
    /**
     * Find zero or one CampaignMessage that matches the filter.
     * @param {CampaignMessageFindUniqueArgs} args - Arguments to find a CampaignMessage
     * @example
     * // Get one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignMessageFindUniqueArgs>(args: SelectSubset<T, CampaignMessageFindUniqueArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignMessageFindUniqueOrThrowArgs} args - Arguments to find a CampaignMessage
     * @example
     * // Get one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageFindFirstArgs} args - Arguments to find a CampaignMessage
     * @example
     * // Get one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignMessageFindFirstArgs>(args?: SelectSubset<T, CampaignMessageFindFirstArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageFindFirstOrThrowArgs} args - Arguments to find a CampaignMessage
     * @example
     * // Get one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignMessages
     * const campaignMessages = await prisma.campaignMessage.findMany()
     * 
     * // Get first 10 CampaignMessages
     * const campaignMessages = await prisma.campaignMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignMessageWithIdOnly = await prisma.campaignMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignMessageFindManyArgs>(args?: SelectSubset<T, CampaignMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignMessage.
     * @param {CampaignMessageCreateArgs} args - Arguments to create a CampaignMessage.
     * @example
     * // Create one CampaignMessage
     * const CampaignMessage = await prisma.campaignMessage.create({
     *   data: {
     *     // ... data to create a CampaignMessage
     *   }
     * })
     * 
     */
    create<T extends CampaignMessageCreateArgs>(args: SelectSubset<T, CampaignMessageCreateArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignMessages.
     * @param {CampaignMessageCreateManyArgs} args - Arguments to create many CampaignMessages.
     * @example
     * // Create many CampaignMessages
     * const campaignMessage = await prisma.campaignMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignMessageCreateManyArgs>(args?: SelectSubset<T, CampaignMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignMessages and returns the data saved in the database.
     * @param {CampaignMessageCreateManyAndReturnArgs} args - Arguments to create many CampaignMessages.
     * @example
     * // Create many CampaignMessages
     * const campaignMessage = await prisma.campaignMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignMessages and only return the `id`
     * const campaignMessageWithIdOnly = await prisma.campaignMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignMessage.
     * @param {CampaignMessageDeleteArgs} args - Arguments to delete one CampaignMessage.
     * @example
     * // Delete one CampaignMessage
     * const CampaignMessage = await prisma.campaignMessage.delete({
     *   where: {
     *     // ... filter to delete one CampaignMessage
     *   }
     * })
     * 
     */
    delete<T extends CampaignMessageDeleteArgs>(args: SelectSubset<T, CampaignMessageDeleteArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignMessage.
     * @param {CampaignMessageUpdateArgs} args - Arguments to update one CampaignMessage.
     * @example
     * // Update one CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignMessageUpdateArgs>(args: SelectSubset<T, CampaignMessageUpdateArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignMessages.
     * @param {CampaignMessageDeleteManyArgs} args - Arguments to filter CampaignMessages to delete.
     * @example
     * // Delete a few CampaignMessages
     * const { count } = await prisma.campaignMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignMessageDeleteManyArgs>(args?: SelectSubset<T, CampaignMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignMessages
     * const campaignMessage = await prisma.campaignMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignMessageUpdateManyArgs>(args: SelectSubset<T, CampaignMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignMessages and returns the data updated in the database.
     * @param {CampaignMessageUpdateManyAndReturnArgs} args - Arguments to update many CampaignMessages.
     * @example
     * // Update many CampaignMessages
     * const campaignMessage = await prisma.campaignMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignMessages and only return the `id`
     * const campaignMessageWithIdOnly = await prisma.campaignMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignMessage.
     * @param {CampaignMessageUpsertArgs} args - Arguments to update or create a CampaignMessage.
     * @example
     * // Update or create a CampaignMessage
     * const campaignMessage = await prisma.campaignMessage.upsert({
     *   create: {
     *     // ... data to create a CampaignMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignMessage we want to update
     *   }
     * })
     */
    upsert<T extends CampaignMessageUpsertArgs>(args: SelectSubset<T, CampaignMessageUpsertArgs<ExtArgs>>): Prisma__CampaignMessageClient<$Result.GetResult<Prisma.$CampaignMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageCountArgs} args - Arguments to filter CampaignMessages to count.
     * @example
     * // Count the number of CampaignMessages
     * const count = await prisma.campaignMessage.count({
     *   where: {
     *     // ... the filter for the CampaignMessages we want to count
     *   }
     * })
    **/
    count<T extends CampaignMessageCountArgs>(
      args?: Subset<T, CampaignMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignMessageAggregateArgs>(args: Subset<T, CampaignMessageAggregateArgs>): Prisma.PrismaPromise<GetCampaignMessageAggregateType<T>>

    /**
     * Group by CampaignMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignMessageGroupByArgs['orderBy'] }
        : { orderBy?: CampaignMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignMessage model
   */
  readonly fields: CampaignMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignMessage model
   */
  interface CampaignMessageFieldRefs {
    readonly id: FieldRef<"CampaignMessage", 'String'>
    readonly campaignId: FieldRef<"CampaignMessage", 'String'>
    readonly type: FieldRef<"CampaignMessage", 'String'>
    readonly content: FieldRef<"CampaignMessage", 'String'>
    readonly order: FieldRef<"CampaignMessage", 'Int'>
    readonly caption: FieldRef<"CampaignMessage", 'String'>
    readonly createdAt: FieldRef<"CampaignMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignMessage findUnique
   */
  export type CampaignMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessage to fetch.
     */
    where: CampaignMessageWhereUniqueInput
  }

  /**
   * CampaignMessage findUniqueOrThrow
   */
  export type CampaignMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessage to fetch.
     */
    where: CampaignMessageWhereUniqueInput
  }

  /**
   * CampaignMessage findFirst
   */
  export type CampaignMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessage to fetch.
     */
    where?: CampaignMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMessages to fetch.
     */
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMessages.
     */
    cursor?: CampaignMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMessages.
     */
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * CampaignMessage findFirstOrThrow
   */
  export type CampaignMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessage to fetch.
     */
    where?: CampaignMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMessages to fetch.
     */
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMessages.
     */
    cursor?: CampaignMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMessages.
     */
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * CampaignMessage findMany
   */
  export type CampaignMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMessages to fetch.
     */
    where?: CampaignMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMessages to fetch.
     */
    orderBy?: CampaignMessageOrderByWithRelationInput | CampaignMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignMessages.
     */
    cursor?: CampaignMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMessages.
     */
    skip?: number
    distinct?: CampaignMessageScalarFieldEnum | CampaignMessageScalarFieldEnum[]
  }

  /**
   * CampaignMessage create
   */
  export type CampaignMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignMessage.
     */
    data: XOR<CampaignMessageCreateInput, CampaignMessageUncheckedCreateInput>
  }

  /**
   * CampaignMessage createMany
   */
  export type CampaignMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignMessages.
     */
    data: CampaignMessageCreateManyInput | CampaignMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignMessage createManyAndReturn
   */
  export type CampaignMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignMessages.
     */
    data: CampaignMessageCreateManyInput | CampaignMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignMessage update
   */
  export type CampaignMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignMessage.
     */
    data: XOR<CampaignMessageUpdateInput, CampaignMessageUncheckedUpdateInput>
    /**
     * Choose, which CampaignMessage to update.
     */
    where: CampaignMessageWhereUniqueInput
  }

  /**
   * CampaignMessage updateMany
   */
  export type CampaignMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignMessages.
     */
    data: XOR<CampaignMessageUpdateManyMutationInput, CampaignMessageUncheckedUpdateManyInput>
    /**
     * Filter which CampaignMessages to update
     */
    where?: CampaignMessageWhereInput
    /**
     * Limit how many CampaignMessages to update.
     */
    limit?: number
  }

  /**
   * CampaignMessage updateManyAndReturn
   */
  export type CampaignMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * The data used to update CampaignMessages.
     */
    data: XOR<CampaignMessageUpdateManyMutationInput, CampaignMessageUncheckedUpdateManyInput>
    /**
     * Filter which CampaignMessages to update
     */
    where?: CampaignMessageWhereInput
    /**
     * Limit how many CampaignMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignMessage upsert
   */
  export type CampaignMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignMessage to update in case it exists.
     */
    where: CampaignMessageWhereUniqueInput
    /**
     * In case the CampaignMessage found by the `where` argument doesn't exist, create a new CampaignMessage with this data.
     */
    create: XOR<CampaignMessageCreateInput, CampaignMessageUncheckedCreateInput>
    /**
     * In case the CampaignMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignMessageUpdateInput, CampaignMessageUncheckedUpdateInput>
  }

  /**
   * CampaignMessage delete
   */
  export type CampaignMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
    /**
     * Filter which CampaignMessage to delete.
     */
    where: CampaignMessageWhereUniqueInput
  }

  /**
   * CampaignMessage deleteMany
   */
  export type CampaignMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMessages to delete
     */
    where?: CampaignMessageWhereInput
    /**
     * Limit how many CampaignMessages to delete.
     */
    limit?: number
  }

  /**
   * CampaignMessage without action
   */
  export type CampaignMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMessage
     */
    select?: CampaignMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMessage
     */
    omit?: CampaignMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMessageInclude<ExtArgs> | null
  }


  /**
   * Model CampaignLead
   */

  export type AggregateCampaignLead = {
    _count: CampaignLeadCountAggregateOutputType | null
    _min: CampaignLeadMinAggregateOutputType | null
    _max: CampaignLeadMaxAggregateOutputType | null
  }

  export type CampaignLeadMinAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    name: string | null
    phone: string | null
    status: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    messageId: string | null
    segment: string | null
    engagement: string | null
    syncedWithCRM: boolean | null
    syncedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignLeadMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    name: string | null
    phone: string | null
    status: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    messageId: string | null
    segment: string | null
    engagement: string | null
    syncedWithCRM: boolean | null
    syncedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignLeadCountAggregateOutputType = {
    id: number
    userId: number
    campaignId: number
    name: number
    phone: number
    status: number
    sentAt: number
    deliveredAt: number
    readAt: number
    failedAt: number
    failureReason: number
    messageId: number
    segment: number
    engagement: number
    syncedWithCRM: number
    syncedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignLeadMinAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    name?: true
    phone?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    failedAt?: true
    failureReason?: true
    messageId?: true
    segment?: true
    engagement?: true
    syncedWithCRM?: true
    syncedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignLeadMaxAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    name?: true
    phone?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    failedAt?: true
    failureReason?: true
    messageId?: true
    segment?: true
    engagement?: true
    syncedWithCRM?: true
    syncedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignLeadCountAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    name?: true
    phone?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    failedAt?: true
    failureReason?: true
    messageId?: true
    segment?: true
    engagement?: true
    syncedWithCRM?: true
    syncedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignLeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignLead to aggregate.
     */
    where?: CampaignLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLeads to fetch.
     */
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignLeads
    **/
    _count?: true | CampaignLeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignLeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignLeadMaxAggregateInputType
  }

  export type GetCampaignLeadAggregateType<T extends CampaignLeadAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignLead[P]>
      : GetScalarType<T[P], AggregateCampaignLead[P]>
  }




  export type CampaignLeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLeadWhereInput
    orderBy?: CampaignLeadOrderByWithAggregationInput | CampaignLeadOrderByWithAggregationInput[]
    by: CampaignLeadScalarFieldEnum[] | CampaignLeadScalarFieldEnum
    having?: CampaignLeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignLeadCountAggregateInputType | true
    _min?: CampaignLeadMinAggregateInputType
    _max?: CampaignLeadMaxAggregateInputType
  }

  export type CampaignLeadGroupByOutputType = {
    id: string
    userId: string
    campaignId: string
    name: string | null
    phone: string
    status: string
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    messageId: string | null
    segment: string | null
    engagement: string | null
    syncedWithCRM: boolean
    syncedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignLeadCountAggregateOutputType | null
    _min: CampaignLeadMinAggregateOutputType | null
    _max: CampaignLeadMaxAggregateOutputType | null
  }

  type GetCampaignLeadGroupByPayload<T extends CampaignLeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignLeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignLeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignLeadGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignLeadGroupByOutputType[P]>
        }
      >
    >


  export type CampaignLeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    messageId?: boolean
    segment?: boolean
    engagement?: boolean
    syncedWithCRM?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messageLogs?: boolean | CampaignLead$messageLogsArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    _count?: boolean | CampaignLeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignLead"]>

  export type CampaignLeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    messageId?: boolean
    segment?: boolean
    engagement?: boolean
    syncedWithCRM?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignLead"]>

  export type CampaignLeadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    messageId?: boolean
    segment?: boolean
    engagement?: boolean
    syncedWithCRM?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignLead"]>

  export type CampaignLeadSelectScalar = {
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    messageId?: boolean
    segment?: boolean
    engagement?: boolean
    syncedWithCRM?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignLeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "campaignId" | "name" | "phone" | "status" | "sentAt" | "deliveredAt" | "readAt" | "failedAt" | "failureReason" | "messageId" | "segment" | "engagement" | "syncedWithCRM" | "syncedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["campaignLead"]>
  export type CampaignLeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messageLogs?: boolean | CampaignLead$messageLogsArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    _count?: boolean | CampaignLeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignLeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignLeadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignLeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignLead"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messageLogs: Prisma.$MessageLogPayload<ExtArgs>[]
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      campaignId: string
      name: string | null
      phone: string
      status: string
      sentAt: Date | null
      deliveredAt: Date | null
      readAt: Date | null
      failedAt: Date | null
      failureReason: string | null
      messageId: string | null
      segment: string | null
      engagement: string | null
      syncedWithCRM: boolean
      syncedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignLead"]>
    composites: {}
  }

  type CampaignLeadGetPayload<S extends boolean | null | undefined | CampaignLeadDefaultArgs> = $Result.GetResult<Prisma.$CampaignLeadPayload, S>

  type CampaignLeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignLeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignLeadCountAggregateInputType | true
    }

  export interface CampaignLeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignLead'], meta: { name: 'CampaignLead' } }
    /**
     * Find zero or one CampaignLead that matches the filter.
     * @param {CampaignLeadFindUniqueArgs} args - Arguments to find a CampaignLead
     * @example
     * // Get one CampaignLead
     * const campaignLead = await prisma.campaignLead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignLeadFindUniqueArgs>(args: SelectSubset<T, CampaignLeadFindUniqueArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignLead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignLeadFindUniqueOrThrowArgs} args - Arguments to find a CampaignLead
     * @example
     * // Get one CampaignLead
     * const campaignLead = await prisma.campaignLead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignLeadFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignLeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignLead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadFindFirstArgs} args - Arguments to find a CampaignLead
     * @example
     * // Get one CampaignLead
     * const campaignLead = await prisma.campaignLead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignLeadFindFirstArgs>(args?: SelectSubset<T, CampaignLeadFindFirstArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignLead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadFindFirstOrThrowArgs} args - Arguments to find a CampaignLead
     * @example
     * // Get one CampaignLead
     * const campaignLead = await prisma.campaignLead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignLeadFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignLeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignLeads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignLeads
     * const campaignLeads = await prisma.campaignLead.findMany()
     * 
     * // Get first 10 CampaignLeads
     * const campaignLeads = await prisma.campaignLead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignLeadWithIdOnly = await prisma.campaignLead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignLeadFindManyArgs>(args?: SelectSubset<T, CampaignLeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignLead.
     * @param {CampaignLeadCreateArgs} args - Arguments to create a CampaignLead.
     * @example
     * // Create one CampaignLead
     * const CampaignLead = await prisma.campaignLead.create({
     *   data: {
     *     // ... data to create a CampaignLead
     *   }
     * })
     * 
     */
    create<T extends CampaignLeadCreateArgs>(args: SelectSubset<T, CampaignLeadCreateArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignLeads.
     * @param {CampaignLeadCreateManyArgs} args - Arguments to create many CampaignLeads.
     * @example
     * // Create many CampaignLeads
     * const campaignLead = await prisma.campaignLead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignLeadCreateManyArgs>(args?: SelectSubset<T, CampaignLeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignLeads and returns the data saved in the database.
     * @param {CampaignLeadCreateManyAndReturnArgs} args - Arguments to create many CampaignLeads.
     * @example
     * // Create many CampaignLeads
     * const campaignLead = await prisma.campaignLead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignLeads and only return the `id`
     * const campaignLeadWithIdOnly = await prisma.campaignLead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignLeadCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignLeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignLead.
     * @param {CampaignLeadDeleteArgs} args - Arguments to delete one CampaignLead.
     * @example
     * // Delete one CampaignLead
     * const CampaignLead = await prisma.campaignLead.delete({
     *   where: {
     *     // ... filter to delete one CampaignLead
     *   }
     * })
     * 
     */
    delete<T extends CampaignLeadDeleteArgs>(args: SelectSubset<T, CampaignLeadDeleteArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignLead.
     * @param {CampaignLeadUpdateArgs} args - Arguments to update one CampaignLead.
     * @example
     * // Update one CampaignLead
     * const campaignLead = await prisma.campaignLead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignLeadUpdateArgs>(args: SelectSubset<T, CampaignLeadUpdateArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignLeads.
     * @param {CampaignLeadDeleteManyArgs} args - Arguments to filter CampaignLeads to delete.
     * @example
     * // Delete a few CampaignLeads
     * const { count } = await prisma.campaignLead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignLeadDeleteManyArgs>(args?: SelectSubset<T, CampaignLeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignLeads
     * const campaignLead = await prisma.campaignLead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignLeadUpdateManyArgs>(args: SelectSubset<T, CampaignLeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignLeads and returns the data updated in the database.
     * @param {CampaignLeadUpdateManyAndReturnArgs} args - Arguments to update many CampaignLeads.
     * @example
     * // Update many CampaignLeads
     * const campaignLead = await prisma.campaignLead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignLeads and only return the `id`
     * const campaignLeadWithIdOnly = await prisma.campaignLead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignLeadUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignLeadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignLead.
     * @param {CampaignLeadUpsertArgs} args - Arguments to update or create a CampaignLead.
     * @example
     * // Update or create a CampaignLead
     * const campaignLead = await prisma.campaignLead.upsert({
     *   create: {
     *     // ... data to create a CampaignLead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignLead we want to update
     *   }
     * })
     */
    upsert<T extends CampaignLeadUpsertArgs>(args: SelectSubset<T, CampaignLeadUpsertArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadCountArgs} args - Arguments to filter CampaignLeads to count.
     * @example
     * // Count the number of CampaignLeads
     * const count = await prisma.campaignLead.count({
     *   where: {
     *     // ... the filter for the CampaignLeads we want to count
     *   }
     * })
    **/
    count<T extends CampaignLeadCountArgs>(
      args?: Subset<T, CampaignLeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignLeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignLeadAggregateArgs>(args: Subset<T, CampaignLeadAggregateArgs>): Prisma.PrismaPromise<GetCampaignLeadAggregateType<T>>

    /**
     * Group by CampaignLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignLeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignLeadGroupByArgs['orderBy'] }
        : { orderBy?: CampaignLeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignLeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignLead model
   */
  readonly fields: CampaignLeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignLead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignLeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messageLogs<T extends CampaignLead$messageLogsArgs<ExtArgs> = {}>(args?: Subset<T, CampaignLead$messageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignLead model
   */
  interface CampaignLeadFieldRefs {
    readonly id: FieldRef<"CampaignLead", 'String'>
    readonly userId: FieldRef<"CampaignLead", 'String'>
    readonly campaignId: FieldRef<"CampaignLead", 'String'>
    readonly name: FieldRef<"CampaignLead", 'String'>
    readonly phone: FieldRef<"CampaignLead", 'String'>
    readonly status: FieldRef<"CampaignLead", 'String'>
    readonly sentAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly deliveredAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly readAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly failedAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly failureReason: FieldRef<"CampaignLead", 'String'>
    readonly messageId: FieldRef<"CampaignLead", 'String'>
    readonly segment: FieldRef<"CampaignLead", 'String'>
    readonly engagement: FieldRef<"CampaignLead", 'String'>
    readonly syncedWithCRM: FieldRef<"CampaignLead", 'Boolean'>
    readonly syncedAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly createdAt: FieldRef<"CampaignLead", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignLead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignLead findUnique
   */
  export type CampaignLeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLead to fetch.
     */
    where: CampaignLeadWhereUniqueInput
  }

  /**
   * CampaignLead findUniqueOrThrow
   */
  export type CampaignLeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLead to fetch.
     */
    where: CampaignLeadWhereUniqueInput
  }

  /**
   * CampaignLead findFirst
   */
  export type CampaignLeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLead to fetch.
     */
    where?: CampaignLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLeads to fetch.
     */
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignLeads.
     */
    cursor?: CampaignLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignLeads.
     */
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }

  /**
   * CampaignLead findFirstOrThrow
   */
  export type CampaignLeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLead to fetch.
     */
    where?: CampaignLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLeads to fetch.
     */
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignLeads.
     */
    cursor?: CampaignLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignLeads.
     */
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }

  /**
   * CampaignLead findMany
   */
  export type CampaignLeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLeads to fetch.
     */
    where?: CampaignLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLeads to fetch.
     */
    orderBy?: CampaignLeadOrderByWithRelationInput | CampaignLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignLeads.
     */
    cursor?: CampaignLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLeads.
     */
    skip?: number
    distinct?: CampaignLeadScalarFieldEnum | CampaignLeadScalarFieldEnum[]
  }

  /**
   * CampaignLead create
   */
  export type CampaignLeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignLead.
     */
    data: XOR<CampaignLeadCreateInput, CampaignLeadUncheckedCreateInput>
  }

  /**
   * CampaignLead createMany
   */
  export type CampaignLeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignLeads.
     */
    data: CampaignLeadCreateManyInput | CampaignLeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignLead createManyAndReturn
   */
  export type CampaignLeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignLeads.
     */
    data: CampaignLeadCreateManyInput | CampaignLeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignLead update
   */
  export type CampaignLeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignLead.
     */
    data: XOR<CampaignLeadUpdateInput, CampaignLeadUncheckedUpdateInput>
    /**
     * Choose, which CampaignLead to update.
     */
    where: CampaignLeadWhereUniqueInput
  }

  /**
   * CampaignLead updateMany
   */
  export type CampaignLeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignLeads.
     */
    data: XOR<CampaignLeadUpdateManyMutationInput, CampaignLeadUncheckedUpdateManyInput>
    /**
     * Filter which CampaignLeads to update
     */
    where?: CampaignLeadWhereInput
    /**
     * Limit how many CampaignLeads to update.
     */
    limit?: number
  }

  /**
   * CampaignLead updateManyAndReturn
   */
  export type CampaignLeadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * The data used to update CampaignLeads.
     */
    data: XOR<CampaignLeadUpdateManyMutationInput, CampaignLeadUncheckedUpdateManyInput>
    /**
     * Filter which CampaignLeads to update
     */
    where?: CampaignLeadWhereInput
    /**
     * Limit how many CampaignLeads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignLead upsert
   */
  export type CampaignLeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignLead to update in case it exists.
     */
    where: CampaignLeadWhereUniqueInput
    /**
     * In case the CampaignLead found by the `where` argument doesn't exist, create a new CampaignLead with this data.
     */
    create: XOR<CampaignLeadCreateInput, CampaignLeadUncheckedCreateInput>
    /**
     * In case the CampaignLead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignLeadUpdateInput, CampaignLeadUncheckedUpdateInput>
  }

  /**
   * CampaignLead delete
   */
  export type CampaignLeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
    /**
     * Filter which CampaignLead to delete.
     */
    where: CampaignLeadWhereUniqueInput
  }

  /**
   * CampaignLead deleteMany
   */
  export type CampaignLeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignLeads to delete
     */
    where?: CampaignLeadWhereInput
    /**
     * Limit how many CampaignLeads to delete.
     */
    limit?: number
  }

  /**
   * CampaignLead.messageLogs
   */
  export type CampaignLead$messageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    where?: MessageLogWhereInput
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    cursor?: MessageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageLogScalarFieldEnum | MessageLogScalarFieldEnum[]
  }

  /**
   * CampaignLead without action
   */
  export type CampaignLeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLead
     */
    select?: CampaignLeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignLead
     */
    omit?: CampaignLeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLeadInclude<ExtArgs> | null
  }


  /**
   * Model CampaignSchedule
   */

  export type AggregateCampaignSchedule = {
    _count: CampaignScheduleCountAggregateOutputType | null
    _avg: CampaignScheduleAvgAggregateOutputType | null
    _sum: CampaignScheduleSumAggregateOutputType | null
    _min: CampaignScheduleMinAggregateOutputType | null
    _max: CampaignScheduleMaxAggregateOutputType | null
  }

  export type CampaignScheduleAvgAggregateOutputType = {
    minDelay: number | null
    maxDelay: number | null
  }

  export type CampaignScheduleSumAggregateOutputType = {
    minDelay: number | null
    maxDelay: number | null
  }

  export type CampaignScheduleMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    instanceName: string | null
    scheduledDate: Date | null
    status: string | null
    message: string | null
    mediaType: string | null
    mediaUrl: string | null
    mediaCaption: string | null
    minDelay: number | null
    maxDelay: number | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type CampaignScheduleMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    instanceName: string | null
    scheduledDate: Date | null
    status: string | null
    message: string | null
    mediaType: string | null
    mediaUrl: string | null
    mediaCaption: string | null
    minDelay: number | null
    maxDelay: number | null
    createdAt: Date | null
    updatedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type CampaignScheduleCountAggregateOutputType = {
    id: number
    campaignId: number
    instanceName: number
    scheduledDate: number
    status: number
    message: number
    mediaType: number
    mediaUrl: number
    mediaCaption: number
    minDelay: number
    maxDelay: number
    createdAt: number
    updatedAt: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type CampaignScheduleAvgAggregateInputType = {
    minDelay?: true
    maxDelay?: true
  }

  export type CampaignScheduleSumAggregateInputType = {
    minDelay?: true
    maxDelay?: true
  }

  export type CampaignScheduleMinAggregateInputType = {
    id?: true
    campaignId?: true
    instanceName?: true
    scheduledDate?: true
    status?: true
    message?: true
    mediaType?: true
    mediaUrl?: true
    mediaCaption?: true
    minDelay?: true
    maxDelay?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type CampaignScheduleMaxAggregateInputType = {
    id?: true
    campaignId?: true
    instanceName?: true
    scheduledDate?: true
    status?: true
    message?: true
    mediaType?: true
    mediaUrl?: true
    mediaCaption?: true
    minDelay?: true
    maxDelay?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type CampaignScheduleCountAggregateInputType = {
    id?: true
    campaignId?: true
    instanceName?: true
    scheduledDate?: true
    status?: true
    message?: true
    mediaType?: true
    mediaUrl?: true
    mediaCaption?: true
    minDelay?: true
    maxDelay?: true
    createdAt?: true
    updatedAt?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type CampaignScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignSchedule to aggregate.
     */
    where?: CampaignScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignSchedules to fetch.
     */
    orderBy?: CampaignScheduleOrderByWithRelationInput | CampaignScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignSchedules
    **/
    _count?: true | CampaignScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignScheduleMaxAggregateInputType
  }

  export type GetCampaignScheduleAggregateType<T extends CampaignScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignSchedule[P]>
      : GetScalarType<T[P], AggregateCampaignSchedule[P]>
  }




  export type CampaignScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignScheduleWhereInput
    orderBy?: CampaignScheduleOrderByWithAggregationInput | CampaignScheduleOrderByWithAggregationInput[]
    by: CampaignScheduleScalarFieldEnum[] | CampaignScheduleScalarFieldEnum
    having?: CampaignScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignScheduleCountAggregateInputType | true
    _avg?: CampaignScheduleAvgAggregateInputType
    _sum?: CampaignScheduleSumAggregateInputType
    _min?: CampaignScheduleMinAggregateInputType
    _max?: CampaignScheduleMaxAggregateInputType
  }

  export type CampaignScheduleGroupByOutputType = {
    id: string
    campaignId: string
    instanceName: string
    scheduledDate: Date
    status: string
    message: string | null
    mediaType: string | null
    mediaUrl: string | null
    mediaCaption: string | null
    minDelay: number
    maxDelay: number
    createdAt: Date
    updatedAt: Date
    startedAt: Date | null
    completedAt: Date | null
    _count: CampaignScheduleCountAggregateOutputType | null
    _avg: CampaignScheduleAvgAggregateOutputType | null
    _sum: CampaignScheduleSumAggregateOutputType | null
    _min: CampaignScheduleMinAggregateOutputType | null
    _max: CampaignScheduleMaxAggregateOutputType | null
  }

  type GetCampaignScheduleGroupByPayload<T extends CampaignScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignScheduleGroupByOutputType[P]>
        }
      >
    >


  export type CampaignScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    instanceName?: boolean
    scheduledDate?: boolean
    status?: boolean
    message?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    mediaCaption?: boolean
    minDelay?: boolean
    maxDelay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignSchedule"]>

  export type CampaignScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    instanceName?: boolean
    scheduledDate?: boolean
    status?: boolean
    message?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    mediaCaption?: boolean
    minDelay?: boolean
    maxDelay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignSchedule"]>

  export type CampaignScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    instanceName?: boolean
    scheduledDate?: boolean
    status?: boolean
    message?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    mediaCaption?: boolean
    minDelay?: boolean
    maxDelay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignSchedule"]>

  export type CampaignScheduleSelectScalar = {
    id?: boolean
    campaignId?: boolean
    instanceName?: boolean
    scheduledDate?: boolean
    status?: boolean
    message?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    mediaCaption?: boolean
    minDelay?: boolean
    maxDelay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type CampaignScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "instanceName" | "scheduledDate" | "status" | "message" | "mediaType" | "mediaUrl" | "mediaCaption" | "minDelay" | "maxDelay" | "createdAt" | "updatedAt" | "startedAt" | "completedAt", ExtArgs["result"]["campaignSchedule"]>
  export type CampaignScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }
  export type CampaignScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }
  export type CampaignScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $CampaignSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignSchedule"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      instanceName: string
      scheduledDate: Date
      status: string
      message: string | null
      mediaType: string | null
      mediaUrl: string | null
      mediaCaption: string | null
      minDelay: number
      maxDelay: number
      createdAt: Date
      updatedAt: Date
      startedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["campaignSchedule"]>
    composites: {}
  }

  type CampaignScheduleGetPayload<S extends boolean | null | undefined | CampaignScheduleDefaultArgs> = $Result.GetResult<Prisma.$CampaignSchedulePayload, S>

  type CampaignScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignScheduleCountAggregateInputType | true
    }

  export interface CampaignScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignSchedule'], meta: { name: 'CampaignSchedule' } }
    /**
     * Find zero or one CampaignSchedule that matches the filter.
     * @param {CampaignScheduleFindUniqueArgs} args - Arguments to find a CampaignSchedule
     * @example
     * // Get one CampaignSchedule
     * const campaignSchedule = await prisma.campaignSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignScheduleFindUniqueArgs>(args: SelectSubset<T, CampaignScheduleFindUniqueArgs<ExtArgs>>): Prisma__CampaignScheduleClient<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignScheduleFindUniqueOrThrowArgs} args - Arguments to find a CampaignSchedule
     * @example
     * // Get one CampaignSchedule
     * const campaignSchedule = await prisma.campaignSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignScheduleClient<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignScheduleFindFirstArgs} args - Arguments to find a CampaignSchedule
     * @example
     * // Get one CampaignSchedule
     * const campaignSchedule = await prisma.campaignSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignScheduleFindFirstArgs>(args?: SelectSubset<T, CampaignScheduleFindFirstArgs<ExtArgs>>): Prisma__CampaignScheduleClient<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignScheduleFindFirstOrThrowArgs} args - Arguments to find a CampaignSchedule
     * @example
     * // Get one CampaignSchedule
     * const campaignSchedule = await prisma.campaignSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignScheduleClient<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignSchedules
     * const campaignSchedules = await prisma.campaignSchedule.findMany()
     * 
     * // Get first 10 CampaignSchedules
     * const campaignSchedules = await prisma.campaignSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignScheduleWithIdOnly = await prisma.campaignSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignScheduleFindManyArgs>(args?: SelectSubset<T, CampaignScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignSchedule.
     * @param {CampaignScheduleCreateArgs} args - Arguments to create a CampaignSchedule.
     * @example
     * // Create one CampaignSchedule
     * const CampaignSchedule = await prisma.campaignSchedule.create({
     *   data: {
     *     // ... data to create a CampaignSchedule
     *   }
     * })
     * 
     */
    create<T extends CampaignScheduleCreateArgs>(args: SelectSubset<T, CampaignScheduleCreateArgs<ExtArgs>>): Prisma__CampaignScheduleClient<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignSchedules.
     * @param {CampaignScheduleCreateManyArgs} args - Arguments to create many CampaignSchedules.
     * @example
     * // Create many CampaignSchedules
     * const campaignSchedule = await prisma.campaignSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignScheduleCreateManyArgs>(args?: SelectSubset<T, CampaignScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignSchedules and returns the data saved in the database.
     * @param {CampaignScheduleCreateManyAndReturnArgs} args - Arguments to create many CampaignSchedules.
     * @example
     * // Create many CampaignSchedules
     * const campaignSchedule = await prisma.campaignSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignSchedules and only return the `id`
     * const campaignScheduleWithIdOnly = await prisma.campaignSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignSchedule.
     * @param {CampaignScheduleDeleteArgs} args - Arguments to delete one CampaignSchedule.
     * @example
     * // Delete one CampaignSchedule
     * const CampaignSchedule = await prisma.campaignSchedule.delete({
     *   where: {
     *     // ... filter to delete one CampaignSchedule
     *   }
     * })
     * 
     */
    delete<T extends CampaignScheduleDeleteArgs>(args: SelectSubset<T, CampaignScheduleDeleteArgs<ExtArgs>>): Prisma__CampaignScheduleClient<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignSchedule.
     * @param {CampaignScheduleUpdateArgs} args - Arguments to update one CampaignSchedule.
     * @example
     * // Update one CampaignSchedule
     * const campaignSchedule = await prisma.campaignSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignScheduleUpdateArgs>(args: SelectSubset<T, CampaignScheduleUpdateArgs<ExtArgs>>): Prisma__CampaignScheduleClient<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignSchedules.
     * @param {CampaignScheduleDeleteManyArgs} args - Arguments to filter CampaignSchedules to delete.
     * @example
     * // Delete a few CampaignSchedules
     * const { count } = await prisma.campaignSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignScheduleDeleteManyArgs>(args?: SelectSubset<T, CampaignScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignSchedules
     * const campaignSchedule = await prisma.campaignSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignScheduleUpdateManyArgs>(args: SelectSubset<T, CampaignScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignSchedules and returns the data updated in the database.
     * @param {CampaignScheduleUpdateManyAndReturnArgs} args - Arguments to update many CampaignSchedules.
     * @example
     * // Update many CampaignSchedules
     * const campaignSchedule = await prisma.campaignSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignSchedules and only return the `id`
     * const campaignScheduleWithIdOnly = await prisma.campaignSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignSchedule.
     * @param {CampaignScheduleUpsertArgs} args - Arguments to update or create a CampaignSchedule.
     * @example
     * // Update or create a CampaignSchedule
     * const campaignSchedule = await prisma.campaignSchedule.upsert({
     *   create: {
     *     // ... data to create a CampaignSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignSchedule we want to update
     *   }
     * })
     */
    upsert<T extends CampaignScheduleUpsertArgs>(args: SelectSubset<T, CampaignScheduleUpsertArgs<ExtArgs>>): Prisma__CampaignScheduleClient<$Result.GetResult<Prisma.$CampaignSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignScheduleCountArgs} args - Arguments to filter CampaignSchedules to count.
     * @example
     * // Count the number of CampaignSchedules
     * const count = await prisma.campaignSchedule.count({
     *   where: {
     *     // ... the filter for the CampaignSchedules we want to count
     *   }
     * })
    **/
    count<T extends CampaignScheduleCountArgs>(
      args?: Subset<T, CampaignScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignScheduleAggregateArgs>(args: Subset<T, CampaignScheduleAggregateArgs>): Prisma.PrismaPromise<GetCampaignScheduleAggregateType<T>>

    /**
     * Group by CampaignSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignScheduleGroupByArgs['orderBy'] }
        : { orderBy?: CampaignScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignSchedule model
   */
  readonly fields: CampaignScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignSchedule model
   */
  interface CampaignScheduleFieldRefs {
    readonly id: FieldRef<"CampaignSchedule", 'String'>
    readonly campaignId: FieldRef<"CampaignSchedule", 'String'>
    readonly instanceName: FieldRef<"CampaignSchedule", 'String'>
    readonly scheduledDate: FieldRef<"CampaignSchedule", 'DateTime'>
    readonly status: FieldRef<"CampaignSchedule", 'String'>
    readonly message: FieldRef<"CampaignSchedule", 'String'>
    readonly mediaType: FieldRef<"CampaignSchedule", 'String'>
    readonly mediaUrl: FieldRef<"CampaignSchedule", 'String'>
    readonly mediaCaption: FieldRef<"CampaignSchedule", 'String'>
    readonly minDelay: FieldRef<"CampaignSchedule", 'Int'>
    readonly maxDelay: FieldRef<"CampaignSchedule", 'Int'>
    readonly createdAt: FieldRef<"CampaignSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignSchedule", 'DateTime'>
    readonly startedAt: FieldRef<"CampaignSchedule", 'DateTime'>
    readonly completedAt: FieldRef<"CampaignSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignSchedule findUnique
   */
  export type CampaignScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSchedule to fetch.
     */
    where: CampaignScheduleWhereUniqueInput
  }

  /**
   * CampaignSchedule findUniqueOrThrow
   */
  export type CampaignScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSchedule to fetch.
     */
    where: CampaignScheduleWhereUniqueInput
  }

  /**
   * CampaignSchedule findFirst
   */
  export type CampaignScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSchedule to fetch.
     */
    where?: CampaignScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignSchedules to fetch.
     */
    orderBy?: CampaignScheduleOrderByWithRelationInput | CampaignScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignSchedules.
     */
    cursor?: CampaignScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignSchedules.
     */
    distinct?: CampaignScheduleScalarFieldEnum | CampaignScheduleScalarFieldEnum[]
  }

  /**
   * CampaignSchedule findFirstOrThrow
   */
  export type CampaignScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSchedule to fetch.
     */
    where?: CampaignScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignSchedules to fetch.
     */
    orderBy?: CampaignScheduleOrderByWithRelationInput | CampaignScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignSchedules.
     */
    cursor?: CampaignScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignSchedules.
     */
    distinct?: CampaignScheduleScalarFieldEnum | CampaignScheduleScalarFieldEnum[]
  }

  /**
   * CampaignSchedule findMany
   */
  export type CampaignScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSchedules to fetch.
     */
    where?: CampaignScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignSchedules to fetch.
     */
    orderBy?: CampaignScheduleOrderByWithRelationInput | CampaignScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignSchedules.
     */
    cursor?: CampaignScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignSchedules.
     */
    skip?: number
    distinct?: CampaignScheduleScalarFieldEnum | CampaignScheduleScalarFieldEnum[]
  }

  /**
   * CampaignSchedule create
   */
  export type CampaignScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignSchedule.
     */
    data: XOR<CampaignScheduleCreateInput, CampaignScheduleUncheckedCreateInput>
  }

  /**
   * CampaignSchedule createMany
   */
  export type CampaignScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignSchedules.
     */
    data: CampaignScheduleCreateManyInput | CampaignScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignSchedule createManyAndReturn
   */
  export type CampaignScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignSchedules.
     */
    data: CampaignScheduleCreateManyInput | CampaignScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignSchedule update
   */
  export type CampaignScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignSchedule.
     */
    data: XOR<CampaignScheduleUpdateInput, CampaignScheduleUncheckedUpdateInput>
    /**
     * Choose, which CampaignSchedule to update.
     */
    where: CampaignScheduleWhereUniqueInput
  }

  /**
   * CampaignSchedule updateMany
   */
  export type CampaignScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignSchedules.
     */
    data: XOR<CampaignScheduleUpdateManyMutationInput, CampaignScheduleUncheckedUpdateManyInput>
    /**
     * Filter which CampaignSchedules to update
     */
    where?: CampaignScheduleWhereInput
    /**
     * Limit how many CampaignSchedules to update.
     */
    limit?: number
  }

  /**
   * CampaignSchedule updateManyAndReturn
   */
  export type CampaignScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * The data used to update CampaignSchedules.
     */
    data: XOR<CampaignScheduleUpdateManyMutationInput, CampaignScheduleUncheckedUpdateManyInput>
    /**
     * Filter which CampaignSchedules to update
     */
    where?: CampaignScheduleWhereInput
    /**
     * Limit how many CampaignSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignSchedule upsert
   */
  export type CampaignScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignSchedule to update in case it exists.
     */
    where: CampaignScheduleWhereUniqueInput
    /**
     * In case the CampaignSchedule found by the `where` argument doesn't exist, create a new CampaignSchedule with this data.
     */
    create: XOR<CampaignScheduleCreateInput, CampaignScheduleUncheckedCreateInput>
    /**
     * In case the CampaignSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignScheduleUpdateInput, CampaignScheduleUncheckedUpdateInput>
  }

  /**
   * CampaignSchedule delete
   */
  export type CampaignScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleInclude<ExtArgs> | null
    /**
     * Filter which CampaignSchedule to delete.
     */
    where: CampaignScheduleWhereUniqueInput
  }

  /**
   * CampaignSchedule deleteMany
   */
  export type CampaignScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignSchedules to delete
     */
    where?: CampaignScheduleWhereInput
    /**
     * Limit how many CampaignSchedules to delete.
     */
    limit?: number
  }

  /**
   * CampaignSchedule without action
   */
  export type CampaignScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSchedule
     */
    select?: CampaignScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSchedule
     */
    omit?: CampaignScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignScheduleInclude<ExtArgs> | null
  }


  /**
   * Model CampaignStatistics
   */

  export type AggregateCampaignStatistics = {
    _count: CampaignStatisticsCountAggregateOutputType | null
    _avg: CampaignStatisticsAvgAggregateOutputType | null
    _sum: CampaignStatisticsSumAggregateOutputType | null
    _min: CampaignStatisticsMinAggregateOutputType | null
    _max: CampaignStatisticsMaxAggregateOutputType | null
  }

  export type CampaignStatisticsAvgAggregateOutputType = {
    totalLeads: number | null
    sentCount: number | null
    deliveredCount: number | null
    readCount: number | null
    failedCount: number | null
  }

  export type CampaignStatisticsSumAggregateOutputType = {
    totalLeads: number | null
    sentCount: number | null
    deliveredCount: number | null
    readCount: number | null
    failedCount: number | null
  }

  export type CampaignStatisticsMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    totalLeads: number | null
    sentCount: number | null
    deliveredCount: number | null
    readCount: number | null
    failedCount: number | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignStatisticsMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    totalLeads: number | null
    sentCount: number | null
    deliveredCount: number | null
    readCount: number | null
    failedCount: number | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignStatisticsCountAggregateOutputType = {
    id: number
    campaignId: number
    totalLeads: number
    sentCount: number
    deliveredCount: number
    readCount: number
    failedCount: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignStatisticsAvgAggregateInputType = {
    totalLeads?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    failedCount?: true
  }

  export type CampaignStatisticsSumAggregateInputType = {
    totalLeads?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    failedCount?: true
  }

  export type CampaignStatisticsMinAggregateInputType = {
    id?: true
    campaignId?: true
    totalLeads?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    failedCount?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignStatisticsMaxAggregateInputType = {
    id?: true
    campaignId?: true
    totalLeads?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    failedCount?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignStatisticsCountAggregateInputType = {
    id?: true
    campaignId?: true
    totalLeads?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    failedCount?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignStatisticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignStatistics to aggregate.
     */
    where?: CampaignStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignStatistics to fetch.
     */
    orderBy?: CampaignStatisticsOrderByWithRelationInput | CampaignStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignStatistics
    **/
    _count?: true | CampaignStatisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignStatisticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignStatisticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignStatisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignStatisticsMaxAggregateInputType
  }

  export type GetCampaignStatisticsAggregateType<T extends CampaignStatisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignStatistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignStatistics[P]>
      : GetScalarType<T[P], AggregateCampaignStatistics[P]>
  }




  export type CampaignStatisticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignStatisticsWhereInput
    orderBy?: CampaignStatisticsOrderByWithAggregationInput | CampaignStatisticsOrderByWithAggregationInput[]
    by: CampaignStatisticsScalarFieldEnum[] | CampaignStatisticsScalarFieldEnum
    having?: CampaignStatisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignStatisticsCountAggregateInputType | true
    _avg?: CampaignStatisticsAvgAggregateInputType
    _sum?: CampaignStatisticsSumAggregateInputType
    _min?: CampaignStatisticsMinAggregateInputType
    _max?: CampaignStatisticsMaxAggregateInputType
  }

  export type CampaignStatisticsGroupByOutputType = {
    id: string
    campaignId: string
    totalLeads: number
    sentCount: number
    deliveredCount: number
    readCount: number
    failedCount: number
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignStatisticsCountAggregateOutputType | null
    _avg: CampaignStatisticsAvgAggregateOutputType | null
    _sum: CampaignStatisticsSumAggregateOutputType | null
    _min: CampaignStatisticsMinAggregateOutputType | null
    _max: CampaignStatisticsMaxAggregateOutputType | null
  }

  type GetCampaignStatisticsGroupByPayload<T extends CampaignStatisticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignStatisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignStatisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignStatisticsGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignStatisticsGroupByOutputType[P]>
        }
      >
    >


  export type CampaignStatisticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    totalLeads?: boolean
    sentCount?: boolean
    deliveredCount?: boolean
    readCount?: boolean
    failedCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignStatistics"]>

  export type CampaignStatisticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    totalLeads?: boolean
    sentCount?: boolean
    deliveredCount?: boolean
    readCount?: boolean
    failedCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignStatistics"]>

  export type CampaignStatisticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    totalLeads?: boolean
    sentCount?: boolean
    deliveredCount?: boolean
    readCount?: boolean
    failedCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignStatistics"]>

  export type CampaignStatisticsSelectScalar = {
    id?: boolean
    campaignId?: boolean
    totalLeads?: boolean
    sentCount?: boolean
    deliveredCount?: boolean
    readCount?: boolean
    failedCount?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignStatisticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "totalLeads" | "sentCount" | "deliveredCount" | "readCount" | "failedCount" | "startedAt" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["campaignStatistics"]>
  export type CampaignStatisticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignStatisticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignStatisticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignStatisticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignStatistics"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      totalLeads: number
      sentCount: number
      deliveredCount: number
      readCount: number
      failedCount: number
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignStatistics"]>
    composites: {}
  }

  type CampaignStatisticsGetPayload<S extends boolean | null | undefined | CampaignStatisticsDefaultArgs> = $Result.GetResult<Prisma.$CampaignStatisticsPayload, S>

  type CampaignStatisticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignStatisticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignStatisticsCountAggregateInputType | true
    }

  export interface CampaignStatisticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignStatistics'], meta: { name: 'CampaignStatistics' } }
    /**
     * Find zero or one CampaignStatistics that matches the filter.
     * @param {CampaignStatisticsFindUniqueArgs} args - Arguments to find a CampaignStatistics
     * @example
     * // Get one CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignStatisticsFindUniqueArgs>(args: SelectSubset<T, CampaignStatisticsFindUniqueArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignStatistics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignStatisticsFindUniqueOrThrowArgs} args - Arguments to find a CampaignStatistics
     * @example
     * // Get one CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignStatisticsFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignStatisticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsFindFirstArgs} args - Arguments to find a CampaignStatistics
     * @example
     * // Get one CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignStatisticsFindFirstArgs>(args?: SelectSubset<T, CampaignStatisticsFindFirstArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignStatistics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsFindFirstOrThrowArgs} args - Arguments to find a CampaignStatistics
     * @example
     * // Get one CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignStatisticsFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignStatisticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.findMany()
     * 
     * // Get first 10 CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignStatisticsWithIdOnly = await prisma.campaignStatistics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignStatisticsFindManyArgs>(args?: SelectSubset<T, CampaignStatisticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignStatistics.
     * @param {CampaignStatisticsCreateArgs} args - Arguments to create a CampaignStatistics.
     * @example
     * // Create one CampaignStatistics
     * const CampaignStatistics = await prisma.campaignStatistics.create({
     *   data: {
     *     // ... data to create a CampaignStatistics
     *   }
     * })
     * 
     */
    create<T extends CampaignStatisticsCreateArgs>(args: SelectSubset<T, CampaignStatisticsCreateArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignStatistics.
     * @param {CampaignStatisticsCreateManyArgs} args - Arguments to create many CampaignStatistics.
     * @example
     * // Create many CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignStatisticsCreateManyArgs>(args?: SelectSubset<T, CampaignStatisticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignStatistics and returns the data saved in the database.
     * @param {CampaignStatisticsCreateManyAndReturnArgs} args - Arguments to create many CampaignStatistics.
     * @example
     * // Create many CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignStatistics and only return the `id`
     * const campaignStatisticsWithIdOnly = await prisma.campaignStatistics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignStatisticsCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignStatisticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignStatistics.
     * @param {CampaignStatisticsDeleteArgs} args - Arguments to delete one CampaignStatistics.
     * @example
     * // Delete one CampaignStatistics
     * const CampaignStatistics = await prisma.campaignStatistics.delete({
     *   where: {
     *     // ... filter to delete one CampaignStatistics
     *   }
     * })
     * 
     */
    delete<T extends CampaignStatisticsDeleteArgs>(args: SelectSubset<T, CampaignStatisticsDeleteArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignStatistics.
     * @param {CampaignStatisticsUpdateArgs} args - Arguments to update one CampaignStatistics.
     * @example
     * // Update one CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignStatisticsUpdateArgs>(args: SelectSubset<T, CampaignStatisticsUpdateArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignStatistics.
     * @param {CampaignStatisticsDeleteManyArgs} args - Arguments to filter CampaignStatistics to delete.
     * @example
     * // Delete a few CampaignStatistics
     * const { count } = await prisma.campaignStatistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignStatisticsDeleteManyArgs>(args?: SelectSubset<T, CampaignStatisticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignStatisticsUpdateManyArgs>(args: SelectSubset<T, CampaignStatisticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignStatistics and returns the data updated in the database.
     * @param {CampaignStatisticsUpdateManyAndReturnArgs} args - Arguments to update many CampaignStatistics.
     * @example
     * // Update many CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignStatistics and only return the `id`
     * const campaignStatisticsWithIdOnly = await prisma.campaignStatistics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignStatisticsUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignStatisticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignStatistics.
     * @param {CampaignStatisticsUpsertArgs} args - Arguments to update or create a CampaignStatistics.
     * @example
     * // Update or create a CampaignStatistics
     * const campaignStatistics = await prisma.campaignStatistics.upsert({
     *   create: {
     *     // ... data to create a CampaignStatistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignStatistics we want to update
     *   }
     * })
     */
    upsert<T extends CampaignStatisticsUpsertArgs>(args: SelectSubset<T, CampaignStatisticsUpsertArgs<ExtArgs>>): Prisma__CampaignStatisticsClient<$Result.GetResult<Prisma.$CampaignStatisticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsCountArgs} args - Arguments to filter CampaignStatistics to count.
     * @example
     * // Count the number of CampaignStatistics
     * const count = await prisma.campaignStatistics.count({
     *   where: {
     *     // ... the filter for the CampaignStatistics we want to count
     *   }
     * })
    **/
    count<T extends CampaignStatisticsCountArgs>(
      args?: Subset<T, CampaignStatisticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignStatisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignStatisticsAggregateArgs>(args: Subset<T, CampaignStatisticsAggregateArgs>): Prisma.PrismaPromise<GetCampaignStatisticsAggregateType<T>>

    /**
     * Group by CampaignStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignStatisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignStatisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignStatisticsGroupByArgs['orderBy'] }
        : { orderBy?: CampaignStatisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignStatisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignStatisticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignStatistics model
   */
  readonly fields: CampaignStatisticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignStatistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignStatisticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignStatistics model
   */
  interface CampaignStatisticsFieldRefs {
    readonly id: FieldRef<"CampaignStatistics", 'String'>
    readonly campaignId: FieldRef<"CampaignStatistics", 'String'>
    readonly totalLeads: FieldRef<"CampaignStatistics", 'Int'>
    readonly sentCount: FieldRef<"CampaignStatistics", 'Int'>
    readonly deliveredCount: FieldRef<"CampaignStatistics", 'Int'>
    readonly readCount: FieldRef<"CampaignStatistics", 'Int'>
    readonly failedCount: FieldRef<"CampaignStatistics", 'Int'>
    readonly startedAt: FieldRef<"CampaignStatistics", 'DateTime'>
    readonly completedAt: FieldRef<"CampaignStatistics", 'DateTime'>
    readonly createdAt: FieldRef<"CampaignStatistics", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignStatistics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignStatistics findUnique
   */
  export type CampaignStatisticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatistics to fetch.
     */
    where: CampaignStatisticsWhereUniqueInput
  }

  /**
   * CampaignStatistics findUniqueOrThrow
   */
  export type CampaignStatisticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatistics to fetch.
     */
    where: CampaignStatisticsWhereUniqueInput
  }

  /**
   * CampaignStatistics findFirst
   */
  export type CampaignStatisticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatistics to fetch.
     */
    where?: CampaignStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignStatistics to fetch.
     */
    orderBy?: CampaignStatisticsOrderByWithRelationInput | CampaignStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignStatistics.
     */
    cursor?: CampaignStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignStatistics.
     */
    distinct?: CampaignStatisticsScalarFieldEnum | CampaignStatisticsScalarFieldEnum[]
  }

  /**
   * CampaignStatistics findFirstOrThrow
   */
  export type CampaignStatisticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatistics to fetch.
     */
    where?: CampaignStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignStatistics to fetch.
     */
    orderBy?: CampaignStatisticsOrderByWithRelationInput | CampaignStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignStatistics.
     */
    cursor?: CampaignStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignStatistics.
     */
    distinct?: CampaignStatisticsScalarFieldEnum | CampaignStatisticsScalarFieldEnum[]
  }

  /**
   * CampaignStatistics findMany
   */
  export type CampaignStatisticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignStatistics to fetch.
     */
    where?: CampaignStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignStatistics to fetch.
     */
    orderBy?: CampaignStatisticsOrderByWithRelationInput | CampaignStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignStatistics.
     */
    cursor?: CampaignStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignStatistics.
     */
    skip?: number
    distinct?: CampaignStatisticsScalarFieldEnum | CampaignStatisticsScalarFieldEnum[]
  }

  /**
   * CampaignStatistics create
   */
  export type CampaignStatisticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignStatistics.
     */
    data: XOR<CampaignStatisticsCreateInput, CampaignStatisticsUncheckedCreateInput>
  }

  /**
   * CampaignStatistics createMany
   */
  export type CampaignStatisticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignStatistics.
     */
    data: CampaignStatisticsCreateManyInput | CampaignStatisticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignStatistics createManyAndReturn
   */
  export type CampaignStatisticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignStatistics.
     */
    data: CampaignStatisticsCreateManyInput | CampaignStatisticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignStatistics update
   */
  export type CampaignStatisticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignStatistics.
     */
    data: XOR<CampaignStatisticsUpdateInput, CampaignStatisticsUncheckedUpdateInput>
    /**
     * Choose, which CampaignStatistics to update.
     */
    where: CampaignStatisticsWhereUniqueInput
  }

  /**
   * CampaignStatistics updateMany
   */
  export type CampaignStatisticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignStatistics.
     */
    data: XOR<CampaignStatisticsUpdateManyMutationInput, CampaignStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which CampaignStatistics to update
     */
    where?: CampaignStatisticsWhereInput
    /**
     * Limit how many CampaignStatistics to update.
     */
    limit?: number
  }

  /**
   * CampaignStatistics updateManyAndReturn
   */
  export type CampaignStatisticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * The data used to update CampaignStatistics.
     */
    data: XOR<CampaignStatisticsUpdateManyMutationInput, CampaignStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which CampaignStatistics to update
     */
    where?: CampaignStatisticsWhereInput
    /**
     * Limit how many CampaignStatistics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignStatistics upsert
   */
  export type CampaignStatisticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignStatistics to update in case it exists.
     */
    where: CampaignStatisticsWhereUniqueInput
    /**
     * In case the CampaignStatistics found by the `where` argument doesn't exist, create a new CampaignStatistics with this data.
     */
    create: XOR<CampaignStatisticsCreateInput, CampaignStatisticsUncheckedCreateInput>
    /**
     * In case the CampaignStatistics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignStatisticsUpdateInput, CampaignStatisticsUncheckedUpdateInput>
  }

  /**
   * CampaignStatistics delete
   */
  export type CampaignStatisticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
    /**
     * Filter which CampaignStatistics to delete.
     */
    where: CampaignStatisticsWhereUniqueInput
  }

  /**
   * CampaignStatistics deleteMany
   */
  export type CampaignStatisticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignStatistics to delete
     */
    where?: CampaignStatisticsWhereInput
    /**
     * Limit how many CampaignStatistics to delete.
     */
    limit?: number
  }

  /**
   * CampaignStatistics without action
   */
  export type CampaignStatisticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignStatistics
     */
    select?: CampaignStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignStatistics
     */
    omit?: CampaignStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignStatisticsInclude<ExtArgs> | null
  }


  /**
   * Model MessageLog
   */

  export type AggregateMessageLog = {
    _count: MessageLogCountAggregateOutputType | null
    _min: MessageLogMinAggregateOutputType | null
    _max: MessageLogMaxAggregateOutputType | null
  }

  export type MessageLogMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    campaignLeadId: string | null
    leadId: string | null
    messageId: string | null
    messageDate: Date | null
    messageType: string | null
    content: string | null
    status: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageLogMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    campaignLeadId: string | null
    leadId: string | null
    messageId: string | null
    messageDate: Date | null
    messageType: string | null
    content: string | null
    status: string | null
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageLogCountAggregateOutputType = {
    id: number
    campaignId: number
    campaignLeadId: number
    leadId: number
    messageId: number
    messageDate: number
    messageType: number
    content: number
    status: number
    statusHistory: number
    sentAt: number
    deliveredAt: number
    readAt: number
    failedAt: number
    failureReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageLogMinAggregateInputType = {
    id?: true
    campaignId?: true
    campaignLeadId?: true
    leadId?: true
    messageId?: true
    messageDate?: true
    messageType?: true
    content?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    failedAt?: true
    failureReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageLogMaxAggregateInputType = {
    id?: true
    campaignId?: true
    campaignLeadId?: true
    leadId?: true
    messageId?: true
    messageDate?: true
    messageType?: true
    content?: true
    status?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    failedAt?: true
    failureReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageLogCountAggregateInputType = {
    id?: true
    campaignId?: true
    campaignLeadId?: true
    leadId?: true
    messageId?: true
    messageDate?: true
    messageType?: true
    content?: true
    status?: true
    statusHistory?: true
    sentAt?: true
    deliveredAt?: true
    readAt?: true
    failedAt?: true
    failureReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageLog to aggregate.
     */
    where?: MessageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLogs to fetch.
     */
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageLogs
    **/
    _count?: true | MessageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageLogMaxAggregateInputType
  }

  export type GetMessageLogAggregateType<T extends MessageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageLog[P]>
      : GetScalarType<T[P], AggregateMessageLog[P]>
  }




  export type MessageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageLogWhereInput
    orderBy?: MessageLogOrderByWithAggregationInput | MessageLogOrderByWithAggregationInput[]
    by: MessageLogScalarFieldEnum[] | MessageLogScalarFieldEnum
    having?: MessageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageLogCountAggregateInputType | true
    _min?: MessageLogMinAggregateInputType
    _max?: MessageLogMaxAggregateInputType
  }

  export type MessageLogGroupByOutputType = {
    id: string
    campaignId: string
    campaignLeadId: string
    leadId: string | null
    messageId: string
    messageDate: Date
    messageType: string
    content: string
    status: string
    statusHistory: JsonValue[]
    sentAt: Date | null
    deliveredAt: Date | null
    readAt: Date | null
    failedAt: Date | null
    failureReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: MessageLogCountAggregateOutputType | null
    _min: MessageLogMinAggregateOutputType | null
    _max: MessageLogMaxAggregateOutputType | null
  }

  type GetMessageLogGroupByPayload<T extends MessageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageLogGroupByOutputType[P]>
            : GetScalarType<T[P], MessageLogGroupByOutputType[P]>
        }
      >
    >


  export type MessageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    campaignLeadId?: boolean
    leadId?: boolean
    messageId?: boolean
    messageDate?: boolean
    messageType?: boolean
    content?: boolean
    status?: boolean
    statusHistory?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    campaignLead?: boolean | CampaignLeadDefaultArgs<ExtArgs>
    lead?: boolean | MessageLog$leadArgs<ExtArgs>
  }, ExtArgs["result"]["messageLog"]>

  export type MessageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    campaignLeadId?: boolean
    leadId?: boolean
    messageId?: boolean
    messageDate?: boolean
    messageType?: boolean
    content?: boolean
    status?: boolean
    statusHistory?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    campaignLead?: boolean | CampaignLeadDefaultArgs<ExtArgs>
    lead?: boolean | MessageLog$leadArgs<ExtArgs>
  }, ExtArgs["result"]["messageLog"]>

  export type MessageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    campaignLeadId?: boolean
    leadId?: boolean
    messageId?: boolean
    messageDate?: boolean
    messageType?: boolean
    content?: boolean
    status?: boolean
    statusHistory?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    campaignLead?: boolean | CampaignLeadDefaultArgs<ExtArgs>
    lead?: boolean | MessageLog$leadArgs<ExtArgs>
  }, ExtArgs["result"]["messageLog"]>

  export type MessageLogSelectScalar = {
    id?: boolean
    campaignId?: boolean
    campaignLeadId?: boolean
    leadId?: boolean
    messageId?: boolean
    messageDate?: boolean
    messageType?: boolean
    content?: boolean
    status?: boolean
    statusHistory?: boolean
    sentAt?: boolean
    deliveredAt?: boolean
    readAt?: boolean
    failedAt?: boolean
    failureReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "campaignLeadId" | "leadId" | "messageId" | "messageDate" | "messageType" | "content" | "status" | "statusHistory" | "sentAt" | "deliveredAt" | "readAt" | "failedAt" | "failureReason" | "createdAt" | "updatedAt", ExtArgs["result"]["messageLog"]>
  export type MessageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    campaignLead?: boolean | CampaignLeadDefaultArgs<ExtArgs>
    lead?: boolean | MessageLog$leadArgs<ExtArgs>
  }
  export type MessageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    campaignLead?: boolean | CampaignLeadDefaultArgs<ExtArgs>
    lead?: boolean | MessageLog$leadArgs<ExtArgs>
  }
  export type MessageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    campaignLead?: boolean | CampaignLeadDefaultArgs<ExtArgs>
    lead?: boolean | MessageLog$leadArgs<ExtArgs>
  }

  export type $MessageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageLog"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      campaignLead: Prisma.$CampaignLeadPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      campaignLeadId: string
      leadId: string | null
      messageId: string
      messageDate: Date
      messageType: string
      content: string
      status: string
      statusHistory: Prisma.JsonValue[]
      sentAt: Date | null
      deliveredAt: Date | null
      readAt: Date | null
      failedAt: Date | null
      failureReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["messageLog"]>
    composites: {}
  }

  type MessageLogGetPayload<S extends boolean | null | undefined | MessageLogDefaultArgs> = $Result.GetResult<Prisma.$MessageLogPayload, S>

  type MessageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageLogCountAggregateInputType | true
    }

  export interface MessageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageLog'], meta: { name: 'MessageLog' } }
    /**
     * Find zero or one MessageLog that matches the filter.
     * @param {MessageLogFindUniqueArgs} args - Arguments to find a MessageLog
     * @example
     * // Get one MessageLog
     * const messageLog = await prisma.messageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageLogFindUniqueArgs>(args: SelectSubset<T, MessageLogFindUniqueArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageLogFindUniqueOrThrowArgs} args - Arguments to find a MessageLog
     * @example
     * // Get one MessageLog
     * const messageLog = await prisma.messageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogFindFirstArgs} args - Arguments to find a MessageLog
     * @example
     * // Get one MessageLog
     * const messageLog = await prisma.messageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageLogFindFirstArgs>(args?: SelectSubset<T, MessageLogFindFirstArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogFindFirstOrThrowArgs} args - Arguments to find a MessageLog
     * @example
     * // Get one MessageLog
     * const messageLog = await prisma.messageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageLogs
     * const messageLogs = await prisma.messageLog.findMany()
     * 
     * // Get first 10 MessageLogs
     * const messageLogs = await prisma.messageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageLogWithIdOnly = await prisma.messageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageLogFindManyArgs>(args?: SelectSubset<T, MessageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageLog.
     * @param {MessageLogCreateArgs} args - Arguments to create a MessageLog.
     * @example
     * // Create one MessageLog
     * const MessageLog = await prisma.messageLog.create({
     *   data: {
     *     // ... data to create a MessageLog
     *   }
     * })
     * 
     */
    create<T extends MessageLogCreateArgs>(args: SelectSubset<T, MessageLogCreateArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageLogs.
     * @param {MessageLogCreateManyArgs} args - Arguments to create many MessageLogs.
     * @example
     * // Create many MessageLogs
     * const messageLog = await prisma.messageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageLogCreateManyArgs>(args?: SelectSubset<T, MessageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageLogs and returns the data saved in the database.
     * @param {MessageLogCreateManyAndReturnArgs} args - Arguments to create many MessageLogs.
     * @example
     * // Create many MessageLogs
     * const messageLog = await prisma.messageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageLogs and only return the `id`
     * const messageLogWithIdOnly = await prisma.messageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageLog.
     * @param {MessageLogDeleteArgs} args - Arguments to delete one MessageLog.
     * @example
     * // Delete one MessageLog
     * const MessageLog = await prisma.messageLog.delete({
     *   where: {
     *     // ... filter to delete one MessageLog
     *   }
     * })
     * 
     */
    delete<T extends MessageLogDeleteArgs>(args: SelectSubset<T, MessageLogDeleteArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageLog.
     * @param {MessageLogUpdateArgs} args - Arguments to update one MessageLog.
     * @example
     * // Update one MessageLog
     * const messageLog = await prisma.messageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageLogUpdateArgs>(args: SelectSubset<T, MessageLogUpdateArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageLogs.
     * @param {MessageLogDeleteManyArgs} args - Arguments to filter MessageLogs to delete.
     * @example
     * // Delete a few MessageLogs
     * const { count } = await prisma.messageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageLogDeleteManyArgs>(args?: SelectSubset<T, MessageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageLogs
     * const messageLog = await prisma.messageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageLogUpdateManyArgs>(args: SelectSubset<T, MessageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageLogs and returns the data updated in the database.
     * @param {MessageLogUpdateManyAndReturnArgs} args - Arguments to update many MessageLogs.
     * @example
     * // Update many MessageLogs
     * const messageLog = await prisma.messageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageLogs and only return the `id`
     * const messageLogWithIdOnly = await prisma.messageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageLog.
     * @param {MessageLogUpsertArgs} args - Arguments to update or create a MessageLog.
     * @example
     * // Update or create a MessageLog
     * const messageLog = await prisma.messageLog.upsert({
     *   create: {
     *     // ... data to create a MessageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageLog we want to update
     *   }
     * })
     */
    upsert<T extends MessageLogUpsertArgs>(args: SelectSubset<T, MessageLogUpsertArgs<ExtArgs>>): Prisma__MessageLogClient<$Result.GetResult<Prisma.$MessageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogCountArgs} args - Arguments to filter MessageLogs to count.
     * @example
     * // Count the number of MessageLogs
     * const count = await prisma.messageLog.count({
     *   where: {
     *     // ... the filter for the MessageLogs we want to count
     *   }
     * })
    **/
    count<T extends MessageLogCountArgs>(
      args?: Subset<T, MessageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageLogAggregateArgs>(args: Subset<T, MessageLogAggregateArgs>): Prisma.PrismaPromise<GetMessageLogAggregateType<T>>

    /**
     * Group by MessageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageLogGroupByArgs['orderBy'] }
        : { orderBy?: MessageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageLog model
   */
  readonly fields: MessageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaignLead<T extends CampaignLeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignLeadDefaultArgs<ExtArgs>>): Prisma__CampaignLeadClient<$Result.GetResult<Prisma.$CampaignLeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lead<T extends MessageLog$leadArgs<ExtArgs> = {}>(args?: Subset<T, MessageLog$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageLog model
   */
  interface MessageLogFieldRefs {
    readonly id: FieldRef<"MessageLog", 'String'>
    readonly campaignId: FieldRef<"MessageLog", 'String'>
    readonly campaignLeadId: FieldRef<"MessageLog", 'String'>
    readonly leadId: FieldRef<"MessageLog", 'String'>
    readonly messageId: FieldRef<"MessageLog", 'String'>
    readonly messageDate: FieldRef<"MessageLog", 'DateTime'>
    readonly messageType: FieldRef<"MessageLog", 'String'>
    readonly content: FieldRef<"MessageLog", 'String'>
    readonly status: FieldRef<"MessageLog", 'String'>
    readonly statusHistory: FieldRef<"MessageLog", 'Json[]'>
    readonly sentAt: FieldRef<"MessageLog", 'DateTime'>
    readonly deliveredAt: FieldRef<"MessageLog", 'DateTime'>
    readonly readAt: FieldRef<"MessageLog", 'DateTime'>
    readonly failedAt: FieldRef<"MessageLog", 'DateTime'>
    readonly failureReason: FieldRef<"MessageLog", 'String'>
    readonly createdAt: FieldRef<"MessageLog", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageLog findUnique
   */
  export type MessageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * Filter, which MessageLog to fetch.
     */
    where: MessageLogWhereUniqueInput
  }

  /**
   * MessageLog findUniqueOrThrow
   */
  export type MessageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * Filter, which MessageLog to fetch.
     */
    where: MessageLogWhereUniqueInput
  }

  /**
   * MessageLog findFirst
   */
  export type MessageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * Filter, which MessageLog to fetch.
     */
    where?: MessageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLogs to fetch.
     */
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageLogs.
     */
    cursor?: MessageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageLogs.
     */
    distinct?: MessageLogScalarFieldEnum | MessageLogScalarFieldEnum[]
  }

  /**
   * MessageLog findFirstOrThrow
   */
  export type MessageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * Filter, which MessageLog to fetch.
     */
    where?: MessageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLogs to fetch.
     */
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageLogs.
     */
    cursor?: MessageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageLogs.
     */
    distinct?: MessageLogScalarFieldEnum | MessageLogScalarFieldEnum[]
  }

  /**
   * MessageLog findMany
   */
  export type MessageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * Filter, which MessageLogs to fetch.
     */
    where?: MessageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageLogs to fetch.
     */
    orderBy?: MessageLogOrderByWithRelationInput | MessageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageLogs.
     */
    cursor?: MessageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageLogs.
     */
    skip?: number
    distinct?: MessageLogScalarFieldEnum | MessageLogScalarFieldEnum[]
  }

  /**
   * MessageLog create
   */
  export type MessageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageLog.
     */
    data: XOR<MessageLogCreateInput, MessageLogUncheckedCreateInput>
  }

  /**
   * MessageLog createMany
   */
  export type MessageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageLogs.
     */
    data: MessageLogCreateManyInput | MessageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageLog createManyAndReturn
   */
  export type MessageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * The data used to create many MessageLogs.
     */
    data: MessageLogCreateManyInput | MessageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageLog update
   */
  export type MessageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageLog.
     */
    data: XOR<MessageLogUpdateInput, MessageLogUncheckedUpdateInput>
    /**
     * Choose, which MessageLog to update.
     */
    where: MessageLogWhereUniqueInput
  }

  /**
   * MessageLog updateMany
   */
  export type MessageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageLogs.
     */
    data: XOR<MessageLogUpdateManyMutationInput, MessageLogUncheckedUpdateManyInput>
    /**
     * Filter which MessageLogs to update
     */
    where?: MessageLogWhereInput
    /**
     * Limit how many MessageLogs to update.
     */
    limit?: number
  }

  /**
   * MessageLog updateManyAndReturn
   */
  export type MessageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * The data used to update MessageLogs.
     */
    data: XOR<MessageLogUpdateManyMutationInput, MessageLogUncheckedUpdateManyInput>
    /**
     * Filter which MessageLogs to update
     */
    where?: MessageLogWhereInput
    /**
     * Limit how many MessageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageLog upsert
   */
  export type MessageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageLog to update in case it exists.
     */
    where: MessageLogWhereUniqueInput
    /**
     * In case the MessageLog found by the `where` argument doesn't exist, create a new MessageLog with this data.
     */
    create: XOR<MessageLogCreateInput, MessageLogUncheckedCreateInput>
    /**
     * In case the MessageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageLogUpdateInput, MessageLogUncheckedUpdateInput>
  }

  /**
   * MessageLog delete
   */
  export type MessageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
    /**
     * Filter which MessageLog to delete.
     */
    where: MessageLogWhereUniqueInput
  }

  /**
   * MessageLog deleteMany
   */
  export type MessageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageLogs to delete
     */
    where?: MessageLogWhereInput
    /**
     * Limit how many MessageLogs to delete.
     */
    limit?: number
  }

  /**
   * MessageLog.lead
   */
  export type MessageLog$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * MessageLog without action
   */
  export type MessageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageLog
     */
    select?: MessageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageLog
     */
    omit?: MessageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageLogInclude<ExtArgs> | null
  }


  /**
   * Model MessageAnalytics
   */

  export type AggregateMessageAnalytics = {
    _count: MessageAnalyticsCountAggregateOutputType | null
    _avg: MessageAnalyticsAvgAggregateOutputType | null
    _sum: MessageAnalyticsSumAggregateOutputType | null
    _min: MessageAnalyticsMinAggregateOutputType | null
    _max: MessageAnalyticsMaxAggregateOutputType | null
  }

  export type MessageAnalyticsAvgAggregateOutputType = {
    sentCount: number | null
    deliveredCount: number | null
    readCount: number | null
    respondedCount: number | null
    failedCount: number | null
  }

  export type MessageAnalyticsSumAggregateOutputType = {
    sentCount: number | null
    deliveredCount: number | null
    readCount: number | null
    respondedCount: number | null
    failedCount: number | null
  }

  export type MessageAnalyticsMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    date: Date | null
    sentCount: number | null
    deliveredCount: number | null
    readCount: number | null
    respondedCount: number | null
    failedCount: number | null
  }

  export type MessageAnalyticsMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    date: Date | null
    sentCount: number | null
    deliveredCount: number | null
    readCount: number | null
    respondedCount: number | null
    failedCount: number | null
  }

  export type MessageAnalyticsCountAggregateOutputType = {
    id: number
    campaignId: number
    date: number
    sentCount: number
    deliveredCount: number
    readCount: number
    respondedCount: number
    failedCount: number
    _all: number
  }


  export type MessageAnalyticsAvgAggregateInputType = {
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    respondedCount?: true
    failedCount?: true
  }

  export type MessageAnalyticsSumAggregateInputType = {
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    respondedCount?: true
    failedCount?: true
  }

  export type MessageAnalyticsMinAggregateInputType = {
    id?: true
    campaignId?: true
    date?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    respondedCount?: true
    failedCount?: true
  }

  export type MessageAnalyticsMaxAggregateInputType = {
    id?: true
    campaignId?: true
    date?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    respondedCount?: true
    failedCount?: true
  }

  export type MessageAnalyticsCountAggregateInputType = {
    id?: true
    campaignId?: true
    date?: true
    sentCount?: true
    deliveredCount?: true
    readCount?: true
    respondedCount?: true
    failedCount?: true
    _all?: true
  }

  export type MessageAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAnalytics to aggregate.
     */
    where?: MessageAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAnalytics to fetch.
     */
    orderBy?: MessageAnalyticsOrderByWithRelationInput | MessageAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageAnalytics
    **/
    _count?: true | MessageAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageAnalyticsMaxAggregateInputType
  }

  export type GetMessageAnalyticsAggregateType<T extends MessageAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageAnalytics[P]>
      : GetScalarType<T[P], AggregateMessageAnalytics[P]>
  }




  export type MessageAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAnalyticsWhereInput
    orderBy?: MessageAnalyticsOrderByWithAggregationInput | MessageAnalyticsOrderByWithAggregationInput[]
    by: MessageAnalyticsScalarFieldEnum[] | MessageAnalyticsScalarFieldEnum
    having?: MessageAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageAnalyticsCountAggregateInputType | true
    _avg?: MessageAnalyticsAvgAggregateInputType
    _sum?: MessageAnalyticsSumAggregateInputType
    _min?: MessageAnalyticsMinAggregateInputType
    _max?: MessageAnalyticsMaxAggregateInputType
  }

  export type MessageAnalyticsGroupByOutputType = {
    id: string
    campaignId: string
    date: Date
    sentCount: number
    deliveredCount: number
    readCount: number
    respondedCount: number
    failedCount: number
    _count: MessageAnalyticsCountAggregateOutputType | null
    _avg: MessageAnalyticsAvgAggregateOutputType | null
    _sum: MessageAnalyticsSumAggregateOutputType | null
    _min: MessageAnalyticsMinAggregateOutputType | null
    _max: MessageAnalyticsMaxAggregateOutputType | null
  }

  type GetMessageAnalyticsGroupByPayload<T extends MessageAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], MessageAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type MessageAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    date?: boolean
    sentCount?: boolean
    deliveredCount?: boolean
    readCount?: boolean
    respondedCount?: boolean
    failedCount?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAnalytics"]>

  export type MessageAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    date?: boolean
    sentCount?: boolean
    deliveredCount?: boolean
    readCount?: boolean
    respondedCount?: boolean
    failedCount?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAnalytics"]>

  export type MessageAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    date?: boolean
    sentCount?: boolean
    deliveredCount?: boolean
    readCount?: boolean
    respondedCount?: boolean
    failedCount?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAnalytics"]>

  export type MessageAnalyticsSelectScalar = {
    id?: boolean
    campaignId?: boolean
    date?: boolean
    sentCount?: boolean
    deliveredCount?: boolean
    readCount?: boolean
    respondedCount?: boolean
    failedCount?: boolean
  }

  export type MessageAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "date" | "sentCount" | "deliveredCount" | "readCount" | "respondedCount" | "failedCount", ExtArgs["result"]["messageAnalytics"]>
  export type MessageAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type MessageAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type MessageAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $MessageAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageAnalytics"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      date: Date
      sentCount: number
      deliveredCount: number
      readCount: number
      respondedCount: number
      failedCount: number
    }, ExtArgs["result"]["messageAnalytics"]>
    composites: {}
  }

  type MessageAnalyticsGetPayload<S extends boolean | null | undefined | MessageAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$MessageAnalyticsPayload, S>

  type MessageAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageAnalyticsCountAggregateInputType | true
    }

  export interface MessageAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageAnalytics'], meta: { name: 'MessageAnalytics' } }
    /**
     * Find zero or one MessageAnalytics that matches the filter.
     * @param {MessageAnalyticsFindUniqueArgs} args - Arguments to find a MessageAnalytics
     * @example
     * // Get one MessageAnalytics
     * const messageAnalytics = await prisma.messageAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageAnalyticsFindUniqueArgs>(args: SelectSubset<T, MessageAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__MessageAnalyticsClient<$Result.GetResult<Prisma.$MessageAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a MessageAnalytics
     * @example
     * // Get one MessageAnalytics
     * const messageAnalytics = await prisma.messageAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageAnalyticsClient<$Result.GetResult<Prisma.$MessageAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAnalyticsFindFirstArgs} args - Arguments to find a MessageAnalytics
     * @example
     * // Get one MessageAnalytics
     * const messageAnalytics = await prisma.messageAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageAnalyticsFindFirstArgs>(args?: SelectSubset<T, MessageAnalyticsFindFirstArgs<ExtArgs>>): Prisma__MessageAnalyticsClient<$Result.GetResult<Prisma.$MessageAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAnalyticsFindFirstOrThrowArgs} args - Arguments to find a MessageAnalytics
     * @example
     * // Get one MessageAnalytics
     * const messageAnalytics = await prisma.messageAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageAnalyticsClient<$Result.GetResult<Prisma.$MessageAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageAnalytics
     * const messageAnalytics = await prisma.messageAnalytics.findMany()
     * 
     * // Get first 10 MessageAnalytics
     * const messageAnalytics = await prisma.messageAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageAnalyticsWithIdOnly = await prisma.messageAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageAnalyticsFindManyArgs>(args?: SelectSubset<T, MessageAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageAnalytics.
     * @param {MessageAnalyticsCreateArgs} args - Arguments to create a MessageAnalytics.
     * @example
     * // Create one MessageAnalytics
     * const MessageAnalytics = await prisma.messageAnalytics.create({
     *   data: {
     *     // ... data to create a MessageAnalytics
     *   }
     * })
     * 
     */
    create<T extends MessageAnalyticsCreateArgs>(args: SelectSubset<T, MessageAnalyticsCreateArgs<ExtArgs>>): Prisma__MessageAnalyticsClient<$Result.GetResult<Prisma.$MessageAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageAnalytics.
     * @param {MessageAnalyticsCreateManyArgs} args - Arguments to create many MessageAnalytics.
     * @example
     * // Create many MessageAnalytics
     * const messageAnalytics = await prisma.messageAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageAnalyticsCreateManyArgs>(args?: SelectSubset<T, MessageAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageAnalytics and returns the data saved in the database.
     * @param {MessageAnalyticsCreateManyAndReturnArgs} args - Arguments to create many MessageAnalytics.
     * @example
     * // Create many MessageAnalytics
     * const messageAnalytics = await prisma.messageAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageAnalytics and only return the `id`
     * const messageAnalyticsWithIdOnly = await prisma.messageAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageAnalytics.
     * @param {MessageAnalyticsDeleteArgs} args - Arguments to delete one MessageAnalytics.
     * @example
     * // Delete one MessageAnalytics
     * const MessageAnalytics = await prisma.messageAnalytics.delete({
     *   where: {
     *     // ... filter to delete one MessageAnalytics
     *   }
     * })
     * 
     */
    delete<T extends MessageAnalyticsDeleteArgs>(args: SelectSubset<T, MessageAnalyticsDeleteArgs<ExtArgs>>): Prisma__MessageAnalyticsClient<$Result.GetResult<Prisma.$MessageAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageAnalytics.
     * @param {MessageAnalyticsUpdateArgs} args - Arguments to update one MessageAnalytics.
     * @example
     * // Update one MessageAnalytics
     * const messageAnalytics = await prisma.messageAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageAnalyticsUpdateArgs>(args: SelectSubset<T, MessageAnalyticsUpdateArgs<ExtArgs>>): Prisma__MessageAnalyticsClient<$Result.GetResult<Prisma.$MessageAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageAnalytics.
     * @param {MessageAnalyticsDeleteManyArgs} args - Arguments to filter MessageAnalytics to delete.
     * @example
     * // Delete a few MessageAnalytics
     * const { count } = await prisma.messageAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageAnalyticsDeleteManyArgs>(args?: SelectSubset<T, MessageAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageAnalytics
     * const messageAnalytics = await prisma.messageAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageAnalyticsUpdateManyArgs>(args: SelectSubset<T, MessageAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAnalytics and returns the data updated in the database.
     * @param {MessageAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many MessageAnalytics.
     * @example
     * // Update many MessageAnalytics
     * const messageAnalytics = await prisma.messageAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageAnalytics and only return the `id`
     * const messageAnalyticsWithIdOnly = await prisma.messageAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageAnalytics.
     * @param {MessageAnalyticsUpsertArgs} args - Arguments to update or create a MessageAnalytics.
     * @example
     * // Update or create a MessageAnalytics
     * const messageAnalytics = await prisma.messageAnalytics.upsert({
     *   create: {
     *     // ... data to create a MessageAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends MessageAnalyticsUpsertArgs>(args: SelectSubset<T, MessageAnalyticsUpsertArgs<ExtArgs>>): Prisma__MessageAnalyticsClient<$Result.GetResult<Prisma.$MessageAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAnalyticsCountArgs} args - Arguments to filter MessageAnalytics to count.
     * @example
     * // Count the number of MessageAnalytics
     * const count = await prisma.messageAnalytics.count({
     *   where: {
     *     // ... the filter for the MessageAnalytics we want to count
     *   }
     * })
    **/
    count<T extends MessageAnalyticsCountArgs>(
      args?: Subset<T, MessageAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAnalyticsAggregateArgs>(args: Subset<T, MessageAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetMessageAnalyticsAggregateType<T>>

    /**
     * Group by MessageAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: MessageAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageAnalytics model
   */
  readonly fields: MessageAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageAnalytics model
   */
  interface MessageAnalyticsFieldRefs {
    readonly id: FieldRef<"MessageAnalytics", 'String'>
    readonly campaignId: FieldRef<"MessageAnalytics", 'String'>
    readonly date: FieldRef<"MessageAnalytics", 'DateTime'>
    readonly sentCount: FieldRef<"MessageAnalytics", 'Int'>
    readonly deliveredCount: FieldRef<"MessageAnalytics", 'Int'>
    readonly readCount: FieldRef<"MessageAnalytics", 'Int'>
    readonly respondedCount: FieldRef<"MessageAnalytics", 'Int'>
    readonly failedCount: FieldRef<"MessageAnalytics", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MessageAnalytics findUnique
   */
  export type MessageAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which MessageAnalytics to fetch.
     */
    where: MessageAnalyticsWhereUniqueInput
  }

  /**
   * MessageAnalytics findUniqueOrThrow
   */
  export type MessageAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which MessageAnalytics to fetch.
     */
    where: MessageAnalyticsWhereUniqueInput
  }

  /**
   * MessageAnalytics findFirst
   */
  export type MessageAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which MessageAnalytics to fetch.
     */
    where?: MessageAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAnalytics to fetch.
     */
    orderBy?: MessageAnalyticsOrderByWithRelationInput | MessageAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAnalytics.
     */
    cursor?: MessageAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAnalytics.
     */
    distinct?: MessageAnalyticsScalarFieldEnum | MessageAnalyticsScalarFieldEnum[]
  }

  /**
   * MessageAnalytics findFirstOrThrow
   */
  export type MessageAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which MessageAnalytics to fetch.
     */
    where?: MessageAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAnalytics to fetch.
     */
    orderBy?: MessageAnalyticsOrderByWithRelationInput | MessageAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAnalytics.
     */
    cursor?: MessageAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAnalytics.
     */
    distinct?: MessageAnalyticsScalarFieldEnum | MessageAnalyticsScalarFieldEnum[]
  }

  /**
   * MessageAnalytics findMany
   */
  export type MessageAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which MessageAnalytics to fetch.
     */
    where?: MessageAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAnalytics to fetch.
     */
    orderBy?: MessageAnalyticsOrderByWithRelationInput | MessageAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageAnalytics.
     */
    cursor?: MessageAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAnalytics.
     */
    skip?: number
    distinct?: MessageAnalyticsScalarFieldEnum | MessageAnalyticsScalarFieldEnum[]
  }

  /**
   * MessageAnalytics create
   */
  export type MessageAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageAnalytics.
     */
    data: XOR<MessageAnalyticsCreateInput, MessageAnalyticsUncheckedCreateInput>
  }

  /**
   * MessageAnalytics createMany
   */
  export type MessageAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageAnalytics.
     */
    data: MessageAnalyticsCreateManyInput | MessageAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageAnalytics createManyAndReturn
   */
  export type MessageAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many MessageAnalytics.
     */
    data: MessageAnalyticsCreateManyInput | MessageAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageAnalytics update
   */
  export type MessageAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageAnalytics.
     */
    data: XOR<MessageAnalyticsUpdateInput, MessageAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which MessageAnalytics to update.
     */
    where: MessageAnalyticsWhereUniqueInput
  }

  /**
   * MessageAnalytics updateMany
   */
  export type MessageAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageAnalytics.
     */
    data: XOR<MessageAnalyticsUpdateManyMutationInput, MessageAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which MessageAnalytics to update
     */
    where?: MessageAnalyticsWhereInput
    /**
     * Limit how many MessageAnalytics to update.
     */
    limit?: number
  }

  /**
   * MessageAnalytics updateManyAndReturn
   */
  export type MessageAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update MessageAnalytics.
     */
    data: XOR<MessageAnalyticsUpdateManyMutationInput, MessageAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which MessageAnalytics to update
     */
    where?: MessageAnalyticsWhereInput
    /**
     * Limit how many MessageAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageAnalytics upsert
   */
  export type MessageAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageAnalytics to update in case it exists.
     */
    where: MessageAnalyticsWhereUniqueInput
    /**
     * In case the MessageAnalytics found by the `where` argument doesn't exist, create a new MessageAnalytics with this data.
     */
    create: XOR<MessageAnalyticsCreateInput, MessageAnalyticsUncheckedCreateInput>
    /**
     * In case the MessageAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageAnalyticsUpdateInput, MessageAnalyticsUncheckedUpdateInput>
  }

  /**
   * MessageAnalytics delete
   */
  export type MessageAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which MessageAnalytics to delete.
     */
    where: MessageAnalyticsWhereUniqueInput
  }

  /**
   * MessageAnalytics deleteMany
   */
  export type MessageAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAnalytics to delete
     */
    where?: MessageAnalyticsWhereInput
    /**
     * Limit how many MessageAnalytics to delete.
     */
    limit?: number
  }

  /**
   * MessageAnalytics without action
   */
  export type MessageAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAnalytics
     */
    select?: MessageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAnalytics
     */
    omit?: MessageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    phone: string | null
    name: string | null
    email: string | null
    company: string | null
    notes: string | null
    userId: string | null
    lastInteractionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    source: string | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    phone: string | null
    name: string | null
    email: string | null
    company: string | null
    notes: string | null
    userId: string | null
    lastInteractionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    source: string | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    phone: number
    name: number
    email: number
    company: number
    notes: number
    tags: number
    userId: number
    lastInteractionAt: number
    createdAt: number
    updatedAt: number
    source: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    phone?: true
    name?: true
    email?: true
    company?: true
    notes?: true
    userId?: true
    lastInteractionAt?: true
    createdAt?: true
    updatedAt?: true
    source?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    phone?: true
    name?: true
    email?: true
    company?: true
    notes?: true
    userId?: true
    lastInteractionAt?: true
    createdAt?: true
    updatedAt?: true
    source?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    phone?: true
    name?: true
    email?: true
    company?: true
    notes?: true
    tags?: true
    userId?: true
    lastInteractionAt?: true
    createdAt?: true
    updatedAt?: true
    source?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    phone: string
    name: string | null
    email: string | null
    company: string | null
    notes: string | null
    tags: string[]
    userId: string
    lastInteractionAt: Date | null
    createdAt: Date
    updatedAt: Date
    source: string | null
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    name?: boolean
    email?: boolean
    company?: boolean
    notes?: boolean
    tags?: boolean
    userId?: boolean
    lastInteractionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | Contact$campaignsArgs<ExtArgs>
    conversations?: boolean | Contact$conversationsArgs<ExtArgs>
    contactNotes?: boolean | Contact$contactNotesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    name?: boolean
    email?: boolean
    company?: boolean
    notes?: boolean
    tags?: boolean
    userId?: boolean
    lastInteractionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    name?: boolean
    email?: boolean
    company?: boolean
    notes?: boolean
    tags?: boolean
    userId?: boolean
    lastInteractionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    phone?: boolean
    name?: boolean
    email?: boolean
    company?: boolean
    notes?: boolean
    tags?: boolean
    userId?: boolean
    lastInteractionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone" | "name" | "email" | "company" | "notes" | "tags" | "userId" | "lastInteractionAt" | "createdAt" | "updatedAt" | "source", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | Contact$campaignsArgs<ExtArgs>
    conversations?: boolean | Contact$conversationsArgs<ExtArgs>
    contactNotes?: boolean | Contact$contactNotesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      contactNotes: Prisma.$ContactNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone: string
      name: string | null
      email: string | null
      company: string | null
      notes: string | null
      tags: string[]
      userId: string
      lastInteractionAt: Date | null
      createdAt: Date
      updatedAt: Date
      source: string | null
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaigns<T extends Contact$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends Contact$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contactNotes<T extends Contact$contactNotesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$contactNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly company: FieldRef<"Contact", 'String'>
    readonly notes: FieldRef<"Contact", 'String'>
    readonly tags: FieldRef<"Contact", 'String[]'>
    readonly userId: FieldRef<"Contact", 'String'>
    readonly lastInteractionAt: FieldRef<"Contact", 'DateTime'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
    readonly source: FieldRef<"Contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.campaigns
   */
  export type Contact$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Contact.conversations
   */
  export type Contact$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Contact.contactNotes
   */
  export type Contact$contactNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    where?: ContactNoteWhereInput
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    cursor?: ContactNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactNoteScalarFieldEnum | ContactNoteScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    instanceName: string | null
    contactPhone: string | null
    contactName: string | null
    contactAvatar: string | null
    lastMessageAt: Date | null
    status: string | null
    isActive: boolean | null
    contactId: string | null
    userId: string | null
    isGroup: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    instanceName: string | null
    contactPhone: string | null
    contactName: string | null
    contactAvatar: string | null
    lastMessageAt: Date | null
    status: string | null
    isActive: boolean | null
    contactId: string | null
    userId: string | null
    isGroup: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    instanceName: number
    contactPhone: number
    contactName: number
    contactAvatar: number
    lastMessageAt: number
    status: number
    tags: number
    isActive: number
    contactId: number
    userId: number
    isGroup: number
    groupMetadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    instanceName?: true
    contactPhone?: true
    contactName?: true
    contactAvatar?: true
    lastMessageAt?: true
    status?: true
    isActive?: true
    contactId?: true
    userId?: true
    isGroup?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    instanceName?: true
    contactPhone?: true
    contactName?: true
    contactAvatar?: true
    lastMessageAt?: true
    status?: true
    isActive?: true
    contactId?: true
    userId?: true
    isGroup?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    instanceName?: true
    contactPhone?: true
    contactName?: true
    contactAvatar?: true
    lastMessageAt?: true
    status?: true
    tags?: true
    isActive?: true
    contactId?: true
    userId?: true
    isGroup?: true
    groupMetadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    instanceName: string
    contactPhone: string
    contactName: string | null
    contactAvatar: string | null
    lastMessageAt: Date
    status: string
    tags: JsonValue
    isActive: boolean
    contactId: string | null
    userId: string
    isGroup: boolean
    groupMetadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    contactPhone?: boolean
    contactName?: boolean
    contactAvatar?: boolean
    lastMessageAt?: boolean
    status?: boolean
    tags?: boolean
    isActive?: boolean
    contactId?: boolean
    userId?: boolean
    isGroup?: boolean
    groupMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    contact?: boolean | Conversation$contactArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    MessageReaction?: boolean | Conversation$MessageReactionArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    contactPhone?: boolean
    contactName?: boolean
    contactAvatar?: boolean
    lastMessageAt?: boolean
    status?: boolean
    tags?: boolean
    isActive?: boolean
    contactId?: boolean
    userId?: boolean
    isGroup?: boolean
    groupMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | Conversation$contactArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instanceName?: boolean
    contactPhone?: boolean
    contactName?: boolean
    contactAvatar?: boolean
    lastMessageAt?: boolean
    status?: boolean
    tags?: boolean
    isActive?: boolean
    contactId?: boolean
    userId?: boolean
    isGroup?: boolean
    groupMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | Conversation$contactArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    instanceName?: boolean
    contactPhone?: boolean
    contactName?: boolean
    contactAvatar?: boolean
    lastMessageAt?: boolean
    status?: boolean
    tags?: boolean
    isActive?: boolean
    contactId?: boolean
    userId?: boolean
    isGroup?: boolean
    groupMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instanceName" | "contactPhone" | "contactName" | "contactAvatar" | "lastMessageAt" | "status" | "tags" | "isActive" | "contactId" | "userId" | "isGroup" | "groupMetadata" | "createdAt" | "updatedAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    contact?: boolean | Conversation$contactArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    MessageReaction?: boolean | Conversation$MessageReactionArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | Conversation$contactArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | Conversation$contactArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[]
      contact: Prisma.$ContactPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      MessageReaction: Prisma.$MessageReactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instanceName: string
      contactPhone: string
      contactName: string | null
      contactAvatar: string | null
      lastMessageAt: Date
      status: string
      tags: Prisma.JsonValue
      isActive: boolean
      contactId: string | null
      userId: string
      isGroup: boolean
      groupMetadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contact<T extends Conversation$contactArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    MessageReaction<T extends Conversation$MessageReactionArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$MessageReactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly instanceName: FieldRef<"Conversation", 'String'>
    readonly contactPhone: FieldRef<"Conversation", 'String'>
    readonly contactName: FieldRef<"Conversation", 'String'>
    readonly contactAvatar: FieldRef<"Conversation", 'String'>
    readonly lastMessageAt: FieldRef<"Conversation", 'DateTime'>
    readonly status: FieldRef<"Conversation", 'String'>
    readonly tags: FieldRef<"Conversation", 'Json'>
    readonly isActive: FieldRef<"Conversation", 'Boolean'>
    readonly contactId: FieldRef<"Conversation", 'String'>
    readonly userId: FieldRef<"Conversation", 'String'>
    readonly isGroup: FieldRef<"Conversation", 'Boolean'>
    readonly groupMetadata: FieldRef<"Conversation", 'Json'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation.contact
   */
  export type Conversation$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Conversation.MessageReaction
   */
  export type Conversation$MessageReactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    where?: MessageReactionWhereInput
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    cursor?: MessageReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    messageId: string | null
    content: string | null
    type: string | null
    sender: string | null
    status: $Enums.MessageStatus | null
    timestamp: Date | null
    mediaUrl: string | null
    mediaType: string | null
    userId: string | null
    failureReason: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    messageId: string | null
    content: string | null
    type: string | null
    sender: string | null
    status: $Enums.MessageStatus | null
    timestamp: Date | null
    mediaUrl: string | null
    mediaType: string | null
    userId: string | null
    failureReason: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    messageId: number
    content: number
    type: number
    sender: number
    status: number
    timestamp: number
    mediaUrl: number
    mediaType: number
    replyTo: number
    userId: number
    failureReason: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    messageId?: true
    content?: true
    type?: true
    sender?: true
    status?: true
    timestamp?: true
    mediaUrl?: true
    mediaType?: true
    userId?: true
    failureReason?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    messageId?: true
    content?: true
    type?: true
    sender?: true
    status?: true
    timestamp?: true
    mediaUrl?: true
    mediaType?: true
    userId?: true
    failureReason?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    messageId?: true
    content?: true
    type?: true
    sender?: true
    status?: true
    timestamp?: true
    mediaUrl?: true
    mediaType?: true
    replyTo?: true
    userId?: true
    failureReason?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    messageId: string
    content: string
    type: string
    sender: string
    status: $Enums.MessageStatus
    timestamp: Date
    mediaUrl: string | null
    mediaType: string | null
    replyTo: JsonValue | null
    userId: string
    failureReason: string | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    messageId?: boolean
    content?: boolean
    type?: boolean
    sender?: boolean
    status?: boolean
    timestamp?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    replyTo?: boolean
    userId?: boolean
    failureReason?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    messageId?: boolean
    content?: boolean
    type?: boolean
    sender?: boolean
    status?: boolean
    timestamp?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    replyTo?: boolean
    userId?: boolean
    failureReason?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    messageId?: boolean
    content?: boolean
    type?: boolean
    sender?: boolean
    status?: boolean
    timestamp?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    replyTo?: boolean
    userId?: boolean
    failureReason?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    messageId?: boolean
    content?: boolean
    type?: boolean
    sender?: boolean
    status?: boolean
    timestamp?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    replyTo?: boolean
    userId?: boolean
    failureReason?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "messageId" | "content" | "type" | "sender" | "status" | "timestamp" | "mediaUrl" | "mediaType" | "replyTo" | "userId" | "failureReason" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$MessageAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      messageId: string
      content: string
      type: string
      sender: string
      status: $Enums.MessageStatus
      timestamp: Date
      mediaUrl: string | null
      mediaType: string | null
      replyTo: Prisma.JsonValue | null
      userId: string
      failureReason: string | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Message$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Message$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly messageId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'String'>
    readonly sender: FieldRef<"Message", 'String'>
    readonly status: FieldRef<"Message", 'MessageStatus'>
    readonly timestamp: FieldRef<"Message", 'DateTime'>
    readonly mediaUrl: FieldRef<"Message", 'String'>
    readonly mediaType: FieldRef<"Message", 'String'>
    readonly replyTo: FieldRef<"Message", 'Json'>
    readonly userId: FieldRef<"Message", 'String'>
    readonly failureReason: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.attachments
   */
  export type Message$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    cursor?: MessageAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageAttachment
   */

  export type AggregateMessageAttachment = {
    _count: MessageAttachmentCountAggregateOutputType | null
    _avg: MessageAttachmentAvgAggregateOutputType | null
    _sum: MessageAttachmentSumAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  export type MessageAttachmentAvgAggregateOutputType = {
    size: number | null
  }

  export type MessageAttachmentSumAggregateOutputType = {
    size: number | null
  }

  export type MessageAttachmentMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    type: string | null
    url: string | null
    name: string | null
    mimeType: string | null
    filename: string | null
    size: number | null
    createdAt: Date | null
  }

  export type MessageAttachmentMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    type: string | null
    url: string | null
    name: string | null
    mimeType: string | null
    filename: string | null
    size: number | null
    createdAt: Date | null
  }

  export type MessageAttachmentCountAggregateOutputType = {
    id: number
    messageId: number
    type: number
    url: number
    name: number
    mimeType: number
    filename: number
    size: number
    createdAt: number
    _all: number
  }


  export type MessageAttachmentAvgAggregateInputType = {
    size?: true
  }

  export type MessageAttachmentSumAggregateInputType = {
    size?: true
  }

  export type MessageAttachmentMinAggregateInputType = {
    id?: true
    messageId?: true
    type?: true
    url?: true
    name?: true
    mimeType?: true
    filename?: true
    size?: true
    createdAt?: true
  }

  export type MessageAttachmentMaxAggregateInputType = {
    id?: true
    messageId?: true
    type?: true
    url?: true
    name?: true
    mimeType?: true
    filename?: true
    size?: true
    createdAt?: true
  }

  export type MessageAttachmentCountAggregateInputType = {
    id?: true
    messageId?: true
    type?: true
    url?: true
    name?: true
    mimeType?: true
    filename?: true
    size?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachment to aggregate.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageAttachments
    **/
    _count?: true | MessageAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type GetMessageAttachmentAggregateType<T extends MessageAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageAttachment[P]>
      : GetScalarType<T[P], AggregateMessageAttachment[P]>
  }




  export type MessageAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithAggregationInput | MessageAttachmentOrderByWithAggregationInput[]
    by: MessageAttachmentScalarFieldEnum[] | MessageAttachmentScalarFieldEnum
    having?: MessageAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageAttachmentCountAggregateInputType | true
    _avg?: MessageAttachmentAvgAggregateInputType
    _sum?: MessageAttachmentSumAggregateInputType
    _min?: MessageAttachmentMinAggregateInputType
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type MessageAttachmentGroupByOutputType = {
    id: string
    messageId: string
    type: string
    url: string
    name: string | null
    mimeType: string | null
    filename: string | null
    size: number | null
    createdAt: Date
    _count: MessageAttachmentCountAggregateOutputType | null
    _avg: MessageAttachmentAvgAggregateOutputType | null
    _sum: MessageAttachmentSumAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  type GetMessageAttachmentGroupByPayload<T extends MessageAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type MessageAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    mimeType?: boolean
    filename?: boolean
    size?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    mimeType?: boolean
    filename?: boolean
    size?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    mimeType?: boolean
    filename?: boolean
    size?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectScalar = {
    id?: boolean
    messageId?: boolean
    type?: boolean
    url?: boolean
    name?: boolean
    mimeType?: boolean
    filename?: boolean
    size?: boolean
    createdAt?: boolean
  }

  export type MessageAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "type" | "url" | "name" | "mimeType" | "filename" | "size" | "createdAt", ExtArgs["result"]["messageAttachment"]>
  export type MessageAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type MessageAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type MessageAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $MessageAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageAttachment"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      type: string
      url: string
      name: string | null
      mimeType: string | null
      filename: string | null
      size: number | null
      createdAt: Date
    }, ExtArgs["result"]["messageAttachment"]>
    composites: {}
  }

  type MessageAttachmentGetPayload<S extends boolean | null | undefined | MessageAttachmentDefaultArgs> = $Result.GetResult<Prisma.$MessageAttachmentPayload, S>

  type MessageAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageAttachmentCountAggregateInputType | true
    }

  export interface MessageAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageAttachment'], meta: { name: 'MessageAttachment' } }
    /**
     * Find zero or one MessageAttachment that matches the filter.
     * @param {MessageAttachmentFindUniqueArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageAttachmentFindUniqueArgs>(args: SelectSubset<T, MessageAttachmentFindUniqueArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageAttachmentFindUniqueOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageAttachmentFindFirstArgs>(args?: SelectSubset<T, MessageAttachmentFindFirstArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany()
     * 
     * // Get first 10 MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageAttachmentFindManyArgs>(args?: SelectSubset<T, MessageAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageAttachment.
     * @param {MessageAttachmentCreateArgs} args - Arguments to create a MessageAttachment.
     * @example
     * // Create one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.create({
     *   data: {
     *     // ... data to create a MessageAttachment
     *   }
     * })
     * 
     */
    create<T extends MessageAttachmentCreateArgs>(args: SelectSubset<T, MessageAttachmentCreateArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageAttachments.
     * @param {MessageAttachmentCreateManyArgs} args - Arguments to create many MessageAttachments.
     * @example
     * // Create many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageAttachmentCreateManyArgs>(args?: SelectSubset<T, MessageAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageAttachments and returns the data saved in the database.
     * @param {MessageAttachmentCreateManyAndReturnArgs} args - Arguments to create many MessageAttachments.
     * @example
     * // Create many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageAttachments and only return the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageAttachment.
     * @param {MessageAttachmentDeleteArgs} args - Arguments to delete one MessageAttachment.
     * @example
     * // Delete one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.delete({
     *   where: {
     *     // ... filter to delete one MessageAttachment
     *   }
     * })
     * 
     */
    delete<T extends MessageAttachmentDeleteArgs>(args: SelectSubset<T, MessageAttachmentDeleteArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageAttachment.
     * @param {MessageAttachmentUpdateArgs} args - Arguments to update one MessageAttachment.
     * @example
     * // Update one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageAttachmentUpdateArgs>(args: SelectSubset<T, MessageAttachmentUpdateArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageAttachments.
     * @param {MessageAttachmentDeleteManyArgs} args - Arguments to filter MessageAttachments to delete.
     * @example
     * // Delete a few MessageAttachments
     * const { count } = await prisma.messageAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageAttachmentDeleteManyArgs>(args?: SelectSubset<T, MessageAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageAttachmentUpdateManyArgs>(args: SelectSubset<T, MessageAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAttachments and returns the data updated in the database.
     * @param {MessageAttachmentUpdateManyAndReturnArgs} args - Arguments to update many MessageAttachments.
     * @example
     * // Update many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageAttachments and only return the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageAttachment.
     * @param {MessageAttachmentUpsertArgs} args - Arguments to update or create a MessageAttachment.
     * @example
     * // Update or create a MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.upsert({
     *   create: {
     *     // ... data to create a MessageAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageAttachment we want to update
     *   }
     * })
     */
    upsert<T extends MessageAttachmentUpsertArgs>(args: SelectSubset<T, MessageAttachmentUpsertArgs<ExtArgs>>): Prisma__MessageAttachmentClient<$Result.GetResult<Prisma.$MessageAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentCountArgs} args - Arguments to filter MessageAttachments to count.
     * @example
     * // Count the number of MessageAttachments
     * const count = await prisma.messageAttachment.count({
     *   where: {
     *     // ... the filter for the MessageAttachments we want to count
     *   }
     * })
    **/
    count<T extends MessageAttachmentCountArgs>(
      args?: Subset<T, MessageAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAttachmentAggregateArgs>(args: Subset<T, MessageAttachmentAggregateArgs>): Prisma.PrismaPromise<GetMessageAttachmentAggregateType<T>>

    /**
     * Group by MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: MessageAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageAttachment model
   */
  readonly fields: MessageAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageAttachment model
   */
  interface MessageAttachmentFieldRefs {
    readonly id: FieldRef<"MessageAttachment", 'String'>
    readonly messageId: FieldRef<"MessageAttachment", 'String'>
    readonly type: FieldRef<"MessageAttachment", 'String'>
    readonly url: FieldRef<"MessageAttachment", 'String'>
    readonly name: FieldRef<"MessageAttachment", 'String'>
    readonly mimeType: FieldRef<"MessageAttachment", 'String'>
    readonly filename: FieldRef<"MessageAttachment", 'String'>
    readonly size: FieldRef<"MessageAttachment", 'Int'>
    readonly createdAt: FieldRef<"MessageAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageAttachment findUnique
   */
  export type MessageAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment findUniqueOrThrow
   */
  export type MessageAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment findFirst
   */
  export type MessageAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment findFirstOrThrow
   */
  export type MessageAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment findMany
   */
  export type MessageAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachments to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }

  /**
   * MessageAttachment create
   */
  export type MessageAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageAttachment.
     */
    data: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
  }

  /**
   * MessageAttachment createMany
   */
  export type MessageAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageAttachments.
     */
    data: MessageAttachmentCreateManyInput | MessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageAttachment createManyAndReturn
   */
  export type MessageAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many MessageAttachments.
     */
    data: MessageAttachmentCreateManyInput | MessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageAttachment update
   */
  export type MessageAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageAttachment.
     */
    data: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
    /**
     * Choose, which MessageAttachment to update.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment updateMany
   */
  export type MessageAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageAttachments.
     */
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAttachments to update
     */
    where?: MessageAttachmentWhereInput
    /**
     * Limit how many MessageAttachments to update.
     */
    limit?: number
  }

  /**
   * MessageAttachment updateManyAndReturn
   */
  export type MessageAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update MessageAttachments.
     */
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAttachments to update
     */
    where?: MessageAttachmentWhereInput
    /**
     * Limit how many MessageAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageAttachment upsert
   */
  export type MessageAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageAttachment to update in case it exists.
     */
    where: MessageAttachmentWhereUniqueInput
    /**
     * In case the MessageAttachment found by the `where` argument doesn't exist, create a new MessageAttachment with this data.
     */
    create: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
    /**
     * In case the MessageAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
  }

  /**
   * MessageAttachment delete
   */
  export type MessageAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter which MessageAttachment to delete.
     */
    where: MessageAttachmentWhereUniqueInput
  }

  /**
   * MessageAttachment deleteMany
   */
  export type MessageAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachments to delete
     */
    where?: MessageAttachmentWhereInput
    /**
     * Limit how many MessageAttachments to delete.
     */
    limit?: number
  }

  /**
   * MessageAttachment without action
   */
  export type MessageAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageAttachment
     */
    omit?: MessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model CampaignErrorLog
   */

  export type AggregateCampaignErrorLog = {
    _count: CampaignErrorLogCountAggregateOutputType | null
    _min: CampaignErrorLogMinAggregateOutputType | null
    _max: CampaignErrorLogMaxAggregateOutputType | null
  }

  export type CampaignErrorLogMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type CampaignErrorLogMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type CampaignErrorLogCountAggregateOutputType = {
    id: number
    campaignId: number
    errorMessage: number
    errorDetails: number
    createdAt: number
    _all: number
  }


  export type CampaignErrorLogMinAggregateInputType = {
    id?: true
    campaignId?: true
    errorMessage?: true
    createdAt?: true
  }

  export type CampaignErrorLogMaxAggregateInputType = {
    id?: true
    campaignId?: true
    errorMessage?: true
    createdAt?: true
  }

  export type CampaignErrorLogCountAggregateInputType = {
    id?: true
    campaignId?: true
    errorMessage?: true
    errorDetails?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignErrorLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignErrorLog to aggregate.
     */
    where?: CampaignErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignErrorLogs to fetch.
     */
    orderBy?: CampaignErrorLogOrderByWithRelationInput | CampaignErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignErrorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignErrorLogs
    **/
    _count?: true | CampaignErrorLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignErrorLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignErrorLogMaxAggregateInputType
  }

  export type GetCampaignErrorLogAggregateType<T extends CampaignErrorLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignErrorLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignErrorLog[P]>
      : GetScalarType<T[P], AggregateCampaignErrorLog[P]>
  }




  export type CampaignErrorLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignErrorLogWhereInput
    orderBy?: CampaignErrorLogOrderByWithAggregationInput | CampaignErrorLogOrderByWithAggregationInput[]
    by: CampaignErrorLogScalarFieldEnum[] | CampaignErrorLogScalarFieldEnum
    having?: CampaignErrorLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignErrorLogCountAggregateInputType | true
    _min?: CampaignErrorLogMinAggregateInputType
    _max?: CampaignErrorLogMaxAggregateInputType
  }

  export type CampaignErrorLogGroupByOutputType = {
    id: string
    campaignId: string
    errorMessage: string
    errorDetails: JsonValue | null
    createdAt: Date
    _count: CampaignErrorLogCountAggregateOutputType | null
    _min: CampaignErrorLogMinAggregateOutputType | null
    _max: CampaignErrorLogMaxAggregateOutputType | null
  }

  type GetCampaignErrorLogGroupByPayload<T extends CampaignErrorLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignErrorLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignErrorLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignErrorLogGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignErrorLogGroupByOutputType[P]>
        }
      >
    >


  export type CampaignErrorLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    errorMessage?: boolean
    errorDetails?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignErrorLog"]>

  export type CampaignErrorLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    errorMessage?: boolean
    errorDetails?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignErrorLog"]>

  export type CampaignErrorLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    errorMessage?: boolean
    errorDetails?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignErrorLog"]>

  export type CampaignErrorLogSelectScalar = {
    id?: boolean
    campaignId?: boolean
    errorMessage?: boolean
    errorDetails?: boolean
    createdAt?: boolean
  }

  export type CampaignErrorLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "errorMessage" | "errorDetails" | "createdAt", ExtArgs["result"]["campaignErrorLog"]>
  export type CampaignErrorLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignErrorLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignErrorLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignErrorLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignErrorLog"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      errorMessage: string
      errorDetails: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["campaignErrorLog"]>
    composites: {}
  }

  type CampaignErrorLogGetPayload<S extends boolean | null | undefined | CampaignErrorLogDefaultArgs> = $Result.GetResult<Prisma.$CampaignErrorLogPayload, S>

  type CampaignErrorLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignErrorLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignErrorLogCountAggregateInputType | true
    }

  export interface CampaignErrorLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignErrorLog'], meta: { name: 'CampaignErrorLog' } }
    /**
     * Find zero or one CampaignErrorLog that matches the filter.
     * @param {CampaignErrorLogFindUniqueArgs} args - Arguments to find a CampaignErrorLog
     * @example
     * // Get one CampaignErrorLog
     * const campaignErrorLog = await prisma.campaignErrorLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignErrorLogFindUniqueArgs>(args: SelectSubset<T, CampaignErrorLogFindUniqueArgs<ExtArgs>>): Prisma__CampaignErrorLogClient<$Result.GetResult<Prisma.$CampaignErrorLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignErrorLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignErrorLogFindUniqueOrThrowArgs} args - Arguments to find a CampaignErrorLog
     * @example
     * // Get one CampaignErrorLog
     * const campaignErrorLog = await prisma.campaignErrorLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignErrorLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignErrorLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignErrorLogClient<$Result.GetResult<Prisma.$CampaignErrorLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignErrorLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignErrorLogFindFirstArgs} args - Arguments to find a CampaignErrorLog
     * @example
     * // Get one CampaignErrorLog
     * const campaignErrorLog = await prisma.campaignErrorLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignErrorLogFindFirstArgs>(args?: SelectSubset<T, CampaignErrorLogFindFirstArgs<ExtArgs>>): Prisma__CampaignErrorLogClient<$Result.GetResult<Prisma.$CampaignErrorLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignErrorLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignErrorLogFindFirstOrThrowArgs} args - Arguments to find a CampaignErrorLog
     * @example
     * // Get one CampaignErrorLog
     * const campaignErrorLog = await prisma.campaignErrorLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignErrorLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignErrorLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignErrorLogClient<$Result.GetResult<Prisma.$CampaignErrorLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignErrorLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignErrorLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignErrorLogs
     * const campaignErrorLogs = await prisma.campaignErrorLog.findMany()
     * 
     * // Get first 10 CampaignErrorLogs
     * const campaignErrorLogs = await prisma.campaignErrorLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignErrorLogWithIdOnly = await prisma.campaignErrorLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignErrorLogFindManyArgs>(args?: SelectSubset<T, CampaignErrorLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignErrorLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignErrorLog.
     * @param {CampaignErrorLogCreateArgs} args - Arguments to create a CampaignErrorLog.
     * @example
     * // Create one CampaignErrorLog
     * const CampaignErrorLog = await prisma.campaignErrorLog.create({
     *   data: {
     *     // ... data to create a CampaignErrorLog
     *   }
     * })
     * 
     */
    create<T extends CampaignErrorLogCreateArgs>(args: SelectSubset<T, CampaignErrorLogCreateArgs<ExtArgs>>): Prisma__CampaignErrorLogClient<$Result.GetResult<Prisma.$CampaignErrorLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignErrorLogs.
     * @param {CampaignErrorLogCreateManyArgs} args - Arguments to create many CampaignErrorLogs.
     * @example
     * // Create many CampaignErrorLogs
     * const campaignErrorLog = await prisma.campaignErrorLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignErrorLogCreateManyArgs>(args?: SelectSubset<T, CampaignErrorLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignErrorLogs and returns the data saved in the database.
     * @param {CampaignErrorLogCreateManyAndReturnArgs} args - Arguments to create many CampaignErrorLogs.
     * @example
     * // Create many CampaignErrorLogs
     * const campaignErrorLog = await prisma.campaignErrorLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignErrorLogs and only return the `id`
     * const campaignErrorLogWithIdOnly = await prisma.campaignErrorLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignErrorLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignErrorLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignErrorLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignErrorLog.
     * @param {CampaignErrorLogDeleteArgs} args - Arguments to delete one CampaignErrorLog.
     * @example
     * // Delete one CampaignErrorLog
     * const CampaignErrorLog = await prisma.campaignErrorLog.delete({
     *   where: {
     *     // ... filter to delete one CampaignErrorLog
     *   }
     * })
     * 
     */
    delete<T extends CampaignErrorLogDeleteArgs>(args: SelectSubset<T, CampaignErrorLogDeleteArgs<ExtArgs>>): Prisma__CampaignErrorLogClient<$Result.GetResult<Prisma.$CampaignErrorLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignErrorLog.
     * @param {CampaignErrorLogUpdateArgs} args - Arguments to update one CampaignErrorLog.
     * @example
     * // Update one CampaignErrorLog
     * const campaignErrorLog = await prisma.campaignErrorLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignErrorLogUpdateArgs>(args: SelectSubset<T, CampaignErrorLogUpdateArgs<ExtArgs>>): Prisma__CampaignErrorLogClient<$Result.GetResult<Prisma.$CampaignErrorLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignErrorLogs.
     * @param {CampaignErrorLogDeleteManyArgs} args - Arguments to filter CampaignErrorLogs to delete.
     * @example
     * // Delete a few CampaignErrorLogs
     * const { count } = await prisma.campaignErrorLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignErrorLogDeleteManyArgs>(args?: SelectSubset<T, CampaignErrorLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignErrorLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignErrorLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignErrorLogs
     * const campaignErrorLog = await prisma.campaignErrorLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignErrorLogUpdateManyArgs>(args: SelectSubset<T, CampaignErrorLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignErrorLogs and returns the data updated in the database.
     * @param {CampaignErrorLogUpdateManyAndReturnArgs} args - Arguments to update many CampaignErrorLogs.
     * @example
     * // Update many CampaignErrorLogs
     * const campaignErrorLog = await prisma.campaignErrorLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignErrorLogs and only return the `id`
     * const campaignErrorLogWithIdOnly = await prisma.campaignErrorLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignErrorLogUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignErrorLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignErrorLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignErrorLog.
     * @param {CampaignErrorLogUpsertArgs} args - Arguments to update or create a CampaignErrorLog.
     * @example
     * // Update or create a CampaignErrorLog
     * const campaignErrorLog = await prisma.campaignErrorLog.upsert({
     *   create: {
     *     // ... data to create a CampaignErrorLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignErrorLog we want to update
     *   }
     * })
     */
    upsert<T extends CampaignErrorLogUpsertArgs>(args: SelectSubset<T, CampaignErrorLogUpsertArgs<ExtArgs>>): Prisma__CampaignErrorLogClient<$Result.GetResult<Prisma.$CampaignErrorLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignErrorLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignErrorLogCountArgs} args - Arguments to filter CampaignErrorLogs to count.
     * @example
     * // Count the number of CampaignErrorLogs
     * const count = await prisma.campaignErrorLog.count({
     *   where: {
     *     // ... the filter for the CampaignErrorLogs we want to count
     *   }
     * })
    **/
    count<T extends CampaignErrorLogCountArgs>(
      args?: Subset<T, CampaignErrorLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignErrorLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignErrorLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignErrorLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignErrorLogAggregateArgs>(args: Subset<T, CampaignErrorLogAggregateArgs>): Prisma.PrismaPromise<GetCampaignErrorLogAggregateType<T>>

    /**
     * Group by CampaignErrorLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignErrorLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignErrorLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignErrorLogGroupByArgs['orderBy'] }
        : { orderBy?: CampaignErrorLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignErrorLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignErrorLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignErrorLog model
   */
  readonly fields: CampaignErrorLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignErrorLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignErrorLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignErrorLog model
   */
  interface CampaignErrorLogFieldRefs {
    readonly id: FieldRef<"CampaignErrorLog", 'String'>
    readonly campaignId: FieldRef<"CampaignErrorLog", 'String'>
    readonly errorMessage: FieldRef<"CampaignErrorLog", 'String'>
    readonly errorDetails: FieldRef<"CampaignErrorLog", 'Json'>
    readonly createdAt: FieldRef<"CampaignErrorLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignErrorLog findUnique
   */
  export type CampaignErrorLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignErrorLog to fetch.
     */
    where: CampaignErrorLogWhereUniqueInput
  }

  /**
   * CampaignErrorLog findUniqueOrThrow
   */
  export type CampaignErrorLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignErrorLog to fetch.
     */
    where: CampaignErrorLogWhereUniqueInput
  }

  /**
   * CampaignErrorLog findFirst
   */
  export type CampaignErrorLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignErrorLog to fetch.
     */
    where?: CampaignErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignErrorLogs to fetch.
     */
    orderBy?: CampaignErrorLogOrderByWithRelationInput | CampaignErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignErrorLogs.
     */
    cursor?: CampaignErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignErrorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignErrorLogs.
     */
    distinct?: CampaignErrorLogScalarFieldEnum | CampaignErrorLogScalarFieldEnum[]
  }

  /**
   * CampaignErrorLog findFirstOrThrow
   */
  export type CampaignErrorLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignErrorLog to fetch.
     */
    where?: CampaignErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignErrorLogs to fetch.
     */
    orderBy?: CampaignErrorLogOrderByWithRelationInput | CampaignErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignErrorLogs.
     */
    cursor?: CampaignErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignErrorLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignErrorLogs.
     */
    distinct?: CampaignErrorLogScalarFieldEnum | CampaignErrorLogScalarFieldEnum[]
  }

  /**
   * CampaignErrorLog findMany
   */
  export type CampaignErrorLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignErrorLogs to fetch.
     */
    where?: CampaignErrorLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignErrorLogs to fetch.
     */
    orderBy?: CampaignErrorLogOrderByWithRelationInput | CampaignErrorLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignErrorLogs.
     */
    cursor?: CampaignErrorLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignErrorLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignErrorLogs.
     */
    skip?: number
    distinct?: CampaignErrorLogScalarFieldEnum | CampaignErrorLogScalarFieldEnum[]
  }

  /**
   * CampaignErrorLog create
   */
  export type CampaignErrorLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignErrorLog.
     */
    data: XOR<CampaignErrorLogCreateInput, CampaignErrorLogUncheckedCreateInput>
  }

  /**
   * CampaignErrorLog createMany
   */
  export type CampaignErrorLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignErrorLogs.
     */
    data: CampaignErrorLogCreateManyInput | CampaignErrorLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignErrorLog createManyAndReturn
   */
  export type CampaignErrorLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignErrorLogs.
     */
    data: CampaignErrorLogCreateManyInput | CampaignErrorLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignErrorLog update
   */
  export type CampaignErrorLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignErrorLog.
     */
    data: XOR<CampaignErrorLogUpdateInput, CampaignErrorLogUncheckedUpdateInput>
    /**
     * Choose, which CampaignErrorLog to update.
     */
    where: CampaignErrorLogWhereUniqueInput
  }

  /**
   * CampaignErrorLog updateMany
   */
  export type CampaignErrorLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignErrorLogs.
     */
    data: XOR<CampaignErrorLogUpdateManyMutationInput, CampaignErrorLogUncheckedUpdateManyInput>
    /**
     * Filter which CampaignErrorLogs to update
     */
    where?: CampaignErrorLogWhereInput
    /**
     * Limit how many CampaignErrorLogs to update.
     */
    limit?: number
  }

  /**
   * CampaignErrorLog updateManyAndReturn
   */
  export type CampaignErrorLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * The data used to update CampaignErrorLogs.
     */
    data: XOR<CampaignErrorLogUpdateManyMutationInput, CampaignErrorLogUncheckedUpdateManyInput>
    /**
     * Filter which CampaignErrorLogs to update
     */
    where?: CampaignErrorLogWhereInput
    /**
     * Limit how many CampaignErrorLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignErrorLog upsert
   */
  export type CampaignErrorLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignErrorLog to update in case it exists.
     */
    where: CampaignErrorLogWhereUniqueInput
    /**
     * In case the CampaignErrorLog found by the `where` argument doesn't exist, create a new CampaignErrorLog with this data.
     */
    create: XOR<CampaignErrorLogCreateInput, CampaignErrorLogUncheckedCreateInput>
    /**
     * In case the CampaignErrorLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignErrorLogUpdateInput, CampaignErrorLogUncheckedUpdateInput>
  }

  /**
   * CampaignErrorLog delete
   */
  export type CampaignErrorLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogInclude<ExtArgs> | null
    /**
     * Filter which CampaignErrorLog to delete.
     */
    where: CampaignErrorLogWhereUniqueInput
  }

  /**
   * CampaignErrorLog deleteMany
   */
  export type CampaignErrorLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignErrorLogs to delete
     */
    where?: CampaignErrorLogWhereInput
    /**
     * Limit how many CampaignErrorLogs to delete.
     */
    limit?: number
  }

  /**
   * CampaignErrorLog without action
   */
  export type CampaignErrorLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignErrorLog
     */
    select?: CampaignErrorLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignErrorLog
     */
    omit?: CampaignErrorLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignErrorLogInclude<ExtArgs> | null
  }


  /**
   * Model ContactNote
   */

  export type AggregateContactNote = {
    _count: ContactNoteCountAggregateOutputType | null
    _min: ContactNoteMinAggregateOutputType | null
    _max: ContactNoteMaxAggregateOutputType | null
  }

  export type ContactNoteMinAggregateOutputType = {
    id: string | null
    contactId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ContactNoteMaxAggregateOutputType = {
    id: string | null
    contactId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type ContactNoteCountAggregateOutputType = {
    id: number
    contactId: number
    content: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type ContactNoteMinAggregateInputType = {
    id?: true
    contactId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ContactNoteMaxAggregateInputType = {
    id?: true
    contactId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ContactNoteCountAggregateInputType = {
    id?: true
    contactId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type ContactNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactNote to aggregate.
     */
    where?: ContactNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactNotes to fetch.
     */
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactNotes
    **/
    _count?: true | ContactNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactNoteMaxAggregateInputType
  }

  export type GetContactNoteAggregateType<T extends ContactNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateContactNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactNote[P]>
      : GetScalarType<T[P], AggregateContactNote[P]>
  }




  export type ContactNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactNoteWhereInput
    orderBy?: ContactNoteOrderByWithAggregationInput | ContactNoteOrderByWithAggregationInput[]
    by: ContactNoteScalarFieldEnum[] | ContactNoteScalarFieldEnum
    having?: ContactNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactNoteCountAggregateInputType | true
    _min?: ContactNoteMinAggregateInputType
    _max?: ContactNoteMaxAggregateInputType
  }

  export type ContactNoteGroupByOutputType = {
    id: string
    contactId: string
    content: string
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: ContactNoteCountAggregateOutputType | null
    _min: ContactNoteMinAggregateOutputType | null
    _max: ContactNoteMaxAggregateOutputType | null
  }

  type GetContactNoteGroupByPayload<T extends ContactNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ContactNoteGroupByOutputType[P]>
        }
      >
    >


  export type ContactNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactNote"]>

  export type ContactNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactNote"]>

  export type ContactNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactNote"]>

  export type ContactNoteSelectScalar = {
    id?: boolean
    contactId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type ContactNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contactId" | "content" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["contactNote"]>
  export type ContactNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContactNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactNote"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contactId: string
      content: string
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["contactNote"]>
    composites: {}
  }

  type ContactNoteGetPayload<S extends boolean | null | undefined | ContactNoteDefaultArgs> = $Result.GetResult<Prisma.$ContactNotePayload, S>

  type ContactNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactNoteCountAggregateInputType | true
    }

  export interface ContactNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactNote'], meta: { name: 'ContactNote' } }
    /**
     * Find zero or one ContactNote that matches the filter.
     * @param {ContactNoteFindUniqueArgs} args - Arguments to find a ContactNote
     * @example
     * // Get one ContactNote
     * const contactNote = await prisma.contactNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactNoteFindUniqueArgs>(args: SelectSubset<T, ContactNoteFindUniqueArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactNoteFindUniqueOrThrowArgs} args - Arguments to find a ContactNote
     * @example
     * // Get one ContactNote
     * const contactNote = await prisma.contactNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteFindFirstArgs} args - Arguments to find a ContactNote
     * @example
     * // Get one ContactNote
     * const contactNote = await prisma.contactNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactNoteFindFirstArgs>(args?: SelectSubset<T, ContactNoteFindFirstArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteFindFirstOrThrowArgs} args - Arguments to find a ContactNote
     * @example
     * // Get one ContactNote
     * const contactNote = await prisma.contactNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactNotes
     * const contactNotes = await prisma.contactNote.findMany()
     * 
     * // Get first 10 ContactNotes
     * const contactNotes = await prisma.contactNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactNoteWithIdOnly = await prisma.contactNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactNoteFindManyArgs>(args?: SelectSubset<T, ContactNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactNote.
     * @param {ContactNoteCreateArgs} args - Arguments to create a ContactNote.
     * @example
     * // Create one ContactNote
     * const ContactNote = await prisma.contactNote.create({
     *   data: {
     *     // ... data to create a ContactNote
     *   }
     * })
     * 
     */
    create<T extends ContactNoteCreateArgs>(args: SelectSubset<T, ContactNoteCreateArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactNotes.
     * @param {ContactNoteCreateManyArgs} args - Arguments to create many ContactNotes.
     * @example
     * // Create many ContactNotes
     * const contactNote = await prisma.contactNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactNoteCreateManyArgs>(args?: SelectSubset<T, ContactNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactNotes and returns the data saved in the database.
     * @param {ContactNoteCreateManyAndReturnArgs} args - Arguments to create many ContactNotes.
     * @example
     * // Create many ContactNotes
     * const contactNote = await prisma.contactNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactNotes and only return the `id`
     * const contactNoteWithIdOnly = await prisma.contactNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactNote.
     * @param {ContactNoteDeleteArgs} args - Arguments to delete one ContactNote.
     * @example
     * // Delete one ContactNote
     * const ContactNote = await prisma.contactNote.delete({
     *   where: {
     *     // ... filter to delete one ContactNote
     *   }
     * })
     * 
     */
    delete<T extends ContactNoteDeleteArgs>(args: SelectSubset<T, ContactNoteDeleteArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactNote.
     * @param {ContactNoteUpdateArgs} args - Arguments to update one ContactNote.
     * @example
     * // Update one ContactNote
     * const contactNote = await prisma.contactNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactNoteUpdateArgs>(args: SelectSubset<T, ContactNoteUpdateArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactNotes.
     * @param {ContactNoteDeleteManyArgs} args - Arguments to filter ContactNotes to delete.
     * @example
     * // Delete a few ContactNotes
     * const { count } = await prisma.contactNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactNoteDeleteManyArgs>(args?: SelectSubset<T, ContactNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactNotes
     * const contactNote = await prisma.contactNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactNoteUpdateManyArgs>(args: SelectSubset<T, ContactNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactNotes and returns the data updated in the database.
     * @param {ContactNoteUpdateManyAndReturnArgs} args - Arguments to update many ContactNotes.
     * @example
     * // Update many ContactNotes
     * const contactNote = await prisma.contactNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactNotes and only return the `id`
     * const contactNoteWithIdOnly = await prisma.contactNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactNote.
     * @param {ContactNoteUpsertArgs} args - Arguments to update or create a ContactNote.
     * @example
     * // Update or create a ContactNote
     * const contactNote = await prisma.contactNote.upsert({
     *   create: {
     *     // ... data to create a ContactNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactNote we want to update
     *   }
     * })
     */
    upsert<T extends ContactNoteUpsertArgs>(args: SelectSubset<T, ContactNoteUpsertArgs<ExtArgs>>): Prisma__ContactNoteClient<$Result.GetResult<Prisma.$ContactNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteCountArgs} args - Arguments to filter ContactNotes to count.
     * @example
     * // Count the number of ContactNotes
     * const count = await prisma.contactNote.count({
     *   where: {
     *     // ... the filter for the ContactNotes we want to count
     *   }
     * })
    **/
    count<T extends ContactNoteCountArgs>(
      args?: Subset<T, ContactNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactNoteAggregateArgs>(args: Subset<T, ContactNoteAggregateArgs>): Prisma.PrismaPromise<GetContactNoteAggregateType<T>>

    /**
     * Group by ContactNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactNoteGroupByArgs['orderBy'] }
        : { orderBy?: ContactNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactNote model
   */
  readonly fields: ContactNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactNote model
   */
  interface ContactNoteFieldRefs {
    readonly id: FieldRef<"ContactNote", 'String'>
    readonly contactId: FieldRef<"ContactNote", 'String'>
    readonly content: FieldRef<"ContactNote", 'String'>
    readonly createdAt: FieldRef<"ContactNote", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactNote", 'DateTime'>
    readonly userId: FieldRef<"ContactNote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContactNote findUnique
   */
  export type ContactNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * Filter, which ContactNote to fetch.
     */
    where: ContactNoteWhereUniqueInput
  }

  /**
   * ContactNote findUniqueOrThrow
   */
  export type ContactNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * Filter, which ContactNote to fetch.
     */
    where: ContactNoteWhereUniqueInput
  }

  /**
   * ContactNote findFirst
   */
  export type ContactNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * Filter, which ContactNote to fetch.
     */
    where?: ContactNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactNotes to fetch.
     */
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactNotes.
     */
    cursor?: ContactNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactNotes.
     */
    distinct?: ContactNoteScalarFieldEnum | ContactNoteScalarFieldEnum[]
  }

  /**
   * ContactNote findFirstOrThrow
   */
  export type ContactNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * Filter, which ContactNote to fetch.
     */
    where?: ContactNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactNotes to fetch.
     */
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactNotes.
     */
    cursor?: ContactNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactNotes.
     */
    distinct?: ContactNoteScalarFieldEnum | ContactNoteScalarFieldEnum[]
  }

  /**
   * ContactNote findMany
   */
  export type ContactNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * Filter, which ContactNotes to fetch.
     */
    where?: ContactNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactNotes to fetch.
     */
    orderBy?: ContactNoteOrderByWithRelationInput | ContactNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactNotes.
     */
    cursor?: ContactNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactNotes.
     */
    skip?: number
    distinct?: ContactNoteScalarFieldEnum | ContactNoteScalarFieldEnum[]
  }

  /**
   * ContactNote create
   */
  export type ContactNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactNote.
     */
    data: XOR<ContactNoteCreateInput, ContactNoteUncheckedCreateInput>
  }

  /**
   * ContactNote createMany
   */
  export type ContactNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactNotes.
     */
    data: ContactNoteCreateManyInput | ContactNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactNote createManyAndReturn
   */
  export type ContactNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * The data used to create many ContactNotes.
     */
    data: ContactNoteCreateManyInput | ContactNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactNote update
   */
  export type ContactNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactNote.
     */
    data: XOR<ContactNoteUpdateInput, ContactNoteUncheckedUpdateInput>
    /**
     * Choose, which ContactNote to update.
     */
    where: ContactNoteWhereUniqueInput
  }

  /**
   * ContactNote updateMany
   */
  export type ContactNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactNotes.
     */
    data: XOR<ContactNoteUpdateManyMutationInput, ContactNoteUncheckedUpdateManyInput>
    /**
     * Filter which ContactNotes to update
     */
    where?: ContactNoteWhereInput
    /**
     * Limit how many ContactNotes to update.
     */
    limit?: number
  }

  /**
   * ContactNote updateManyAndReturn
   */
  export type ContactNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * The data used to update ContactNotes.
     */
    data: XOR<ContactNoteUpdateManyMutationInput, ContactNoteUncheckedUpdateManyInput>
    /**
     * Filter which ContactNotes to update
     */
    where?: ContactNoteWhereInput
    /**
     * Limit how many ContactNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactNote upsert
   */
  export type ContactNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactNote to update in case it exists.
     */
    where: ContactNoteWhereUniqueInput
    /**
     * In case the ContactNote found by the `where` argument doesn't exist, create a new ContactNote with this data.
     */
    create: XOR<ContactNoteCreateInput, ContactNoteUncheckedCreateInput>
    /**
     * In case the ContactNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactNoteUpdateInput, ContactNoteUncheckedUpdateInput>
  }

  /**
   * ContactNote delete
   */
  export type ContactNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
    /**
     * Filter which ContactNote to delete.
     */
    where: ContactNoteWhereUniqueInput
  }

  /**
   * ContactNote deleteMany
   */
  export type ContactNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactNotes to delete
     */
    where?: ContactNoteWhereInput
    /**
     * Limit how many ContactNotes to delete.
     */
    limit?: number
  }

  /**
   * ContactNote without action
   */
  export type ContactNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactNote
     */
    select?: ContactNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactNote
     */
    omit?: ContactNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactNoteInclude<ExtArgs> | null
  }


  /**
   * Model MessageReaction
   */

  export type AggregateMessageReaction = {
    _count: MessageReactionCountAggregateOutputType | null
    _min: MessageReactionMinAggregateOutputType | null
    _max: MessageReactionMaxAggregateOutputType | null
  }

  export type MessageReactionMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    conversationId: string | null
    reaction: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type MessageReactionMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    conversationId: string | null
    reaction: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type MessageReactionCountAggregateOutputType = {
    id: number
    messageId: number
    conversationId: number
    reaction: number
    userId: number
    createdAt: number
    _all: number
  }


  export type MessageReactionMinAggregateInputType = {
    id?: true
    messageId?: true
    conversationId?: true
    reaction?: true
    userId?: true
    createdAt?: true
  }

  export type MessageReactionMaxAggregateInputType = {
    id?: true
    messageId?: true
    conversationId?: true
    reaction?: true
    userId?: true
    createdAt?: true
  }

  export type MessageReactionCountAggregateInputType = {
    id?: true
    messageId?: true
    conversationId?: true
    reaction?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type MessageReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReaction to aggregate.
     */
    where?: MessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReactions to fetch.
     */
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageReactions
    **/
    _count?: true | MessageReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageReactionMaxAggregateInputType
  }

  export type GetMessageReactionAggregateType<T extends MessageReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageReaction[P]>
      : GetScalarType<T[P], AggregateMessageReaction[P]>
  }




  export type MessageReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReactionWhereInput
    orderBy?: MessageReactionOrderByWithAggregationInput | MessageReactionOrderByWithAggregationInput[]
    by: MessageReactionScalarFieldEnum[] | MessageReactionScalarFieldEnum
    having?: MessageReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageReactionCountAggregateInputType | true
    _min?: MessageReactionMinAggregateInputType
    _max?: MessageReactionMaxAggregateInputType
  }

  export type MessageReactionGroupByOutputType = {
    id: string
    messageId: string
    conversationId: string
    reaction: string
    userId: string
    createdAt: Date
    _count: MessageReactionCountAggregateOutputType | null
    _min: MessageReactionMinAggregateOutputType | null
    _max: MessageReactionMaxAggregateOutputType | null
  }

  type GetMessageReactionGroupByPayload<T extends MessageReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageReactionGroupByOutputType[P]>
            : GetScalarType<T[P], MessageReactionGroupByOutputType[P]>
        }
      >
    >


  export type MessageReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    conversationId?: boolean
    reaction?: boolean
    userId?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageReaction"]>

  export type MessageReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    conversationId?: boolean
    reaction?: boolean
    userId?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageReaction"]>

  export type MessageReactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    conversationId?: boolean
    reaction?: boolean
    userId?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageReaction"]>

  export type MessageReactionSelectScalar = {
    id?: boolean
    messageId?: boolean
    conversationId?: boolean
    reaction?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type MessageReactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "conversationId" | "reaction" | "userId" | "createdAt", ExtArgs["result"]["messageReaction"]>
  export type MessageReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageReactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $MessageReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageReaction"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      conversationId: string
      reaction: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["messageReaction"]>
    composites: {}
  }

  type MessageReactionGetPayload<S extends boolean | null | undefined | MessageReactionDefaultArgs> = $Result.GetResult<Prisma.$MessageReactionPayload, S>

  type MessageReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageReactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageReactionCountAggregateInputType | true
    }

  export interface MessageReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageReaction'], meta: { name: 'MessageReaction' } }
    /**
     * Find zero or one MessageReaction that matches the filter.
     * @param {MessageReactionFindUniqueArgs} args - Arguments to find a MessageReaction
     * @example
     * // Get one MessageReaction
     * const messageReaction = await prisma.messageReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageReactionFindUniqueArgs>(args: SelectSubset<T, MessageReactionFindUniqueArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageReaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageReactionFindUniqueOrThrowArgs} args - Arguments to find a MessageReaction
     * @example
     * // Get one MessageReaction
     * const messageReaction = await prisma.messageReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionFindFirstArgs} args - Arguments to find a MessageReaction
     * @example
     * // Get one MessageReaction
     * const messageReaction = await prisma.messageReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageReactionFindFirstArgs>(args?: SelectSubset<T, MessageReactionFindFirstArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageReaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionFindFirstOrThrowArgs} args - Arguments to find a MessageReaction
     * @example
     * // Get one MessageReaction
     * const messageReaction = await prisma.messageReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageReactions
     * const messageReactions = await prisma.messageReaction.findMany()
     * 
     * // Get first 10 MessageReactions
     * const messageReactions = await prisma.messageReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageReactionWithIdOnly = await prisma.messageReaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageReactionFindManyArgs>(args?: SelectSubset<T, MessageReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageReaction.
     * @param {MessageReactionCreateArgs} args - Arguments to create a MessageReaction.
     * @example
     * // Create one MessageReaction
     * const MessageReaction = await prisma.messageReaction.create({
     *   data: {
     *     // ... data to create a MessageReaction
     *   }
     * })
     * 
     */
    create<T extends MessageReactionCreateArgs>(args: SelectSubset<T, MessageReactionCreateArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageReactions.
     * @param {MessageReactionCreateManyArgs} args - Arguments to create many MessageReactions.
     * @example
     * // Create many MessageReactions
     * const messageReaction = await prisma.messageReaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageReactionCreateManyArgs>(args?: SelectSubset<T, MessageReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageReactions and returns the data saved in the database.
     * @param {MessageReactionCreateManyAndReturnArgs} args - Arguments to create many MessageReactions.
     * @example
     * // Create many MessageReactions
     * const messageReaction = await prisma.messageReaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageReactions and only return the `id`
     * const messageReactionWithIdOnly = await prisma.messageReaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageReaction.
     * @param {MessageReactionDeleteArgs} args - Arguments to delete one MessageReaction.
     * @example
     * // Delete one MessageReaction
     * const MessageReaction = await prisma.messageReaction.delete({
     *   where: {
     *     // ... filter to delete one MessageReaction
     *   }
     * })
     * 
     */
    delete<T extends MessageReactionDeleteArgs>(args: SelectSubset<T, MessageReactionDeleteArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageReaction.
     * @param {MessageReactionUpdateArgs} args - Arguments to update one MessageReaction.
     * @example
     * // Update one MessageReaction
     * const messageReaction = await prisma.messageReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageReactionUpdateArgs>(args: SelectSubset<T, MessageReactionUpdateArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageReactions.
     * @param {MessageReactionDeleteManyArgs} args - Arguments to filter MessageReactions to delete.
     * @example
     * // Delete a few MessageReactions
     * const { count } = await prisma.messageReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageReactionDeleteManyArgs>(args?: SelectSubset<T, MessageReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageReactions
     * const messageReaction = await prisma.messageReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageReactionUpdateManyArgs>(args: SelectSubset<T, MessageReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReactions and returns the data updated in the database.
     * @param {MessageReactionUpdateManyAndReturnArgs} args - Arguments to update many MessageReactions.
     * @example
     * // Update many MessageReactions
     * const messageReaction = await prisma.messageReaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageReactions and only return the `id`
     * const messageReactionWithIdOnly = await prisma.messageReaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageReactionUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageReactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageReaction.
     * @param {MessageReactionUpsertArgs} args - Arguments to update or create a MessageReaction.
     * @example
     * // Update or create a MessageReaction
     * const messageReaction = await prisma.messageReaction.upsert({
     *   create: {
     *     // ... data to create a MessageReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageReaction we want to update
     *   }
     * })
     */
    upsert<T extends MessageReactionUpsertArgs>(args: SelectSubset<T, MessageReactionUpsertArgs<ExtArgs>>): Prisma__MessageReactionClient<$Result.GetResult<Prisma.$MessageReactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionCountArgs} args - Arguments to filter MessageReactions to count.
     * @example
     * // Count the number of MessageReactions
     * const count = await prisma.messageReaction.count({
     *   where: {
     *     // ... the filter for the MessageReactions we want to count
     *   }
     * })
    **/
    count<T extends MessageReactionCountArgs>(
      args?: Subset<T, MessageReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageReactionAggregateArgs>(args: Subset<T, MessageReactionAggregateArgs>): Prisma.PrismaPromise<GetMessageReactionAggregateType<T>>

    /**
     * Group by MessageReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageReactionGroupByArgs['orderBy'] }
        : { orderBy?: MessageReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageReaction model
   */
  readonly fields: MessageReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageReaction model
   */
  interface MessageReactionFieldRefs {
    readonly id: FieldRef<"MessageReaction", 'String'>
    readonly messageId: FieldRef<"MessageReaction", 'String'>
    readonly conversationId: FieldRef<"MessageReaction", 'String'>
    readonly reaction: FieldRef<"MessageReaction", 'String'>
    readonly userId: FieldRef<"MessageReaction", 'String'>
    readonly createdAt: FieldRef<"MessageReaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageReaction findUnique
   */
  export type MessageReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReaction to fetch.
     */
    where: MessageReactionWhereUniqueInput
  }

  /**
   * MessageReaction findUniqueOrThrow
   */
  export type MessageReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReaction to fetch.
     */
    where: MessageReactionWhereUniqueInput
  }

  /**
   * MessageReaction findFirst
   */
  export type MessageReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReaction to fetch.
     */
    where?: MessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReactions to fetch.
     */
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReactions.
     */
    cursor?: MessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReactions.
     */
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }

  /**
   * MessageReaction findFirstOrThrow
   */
  export type MessageReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReaction to fetch.
     */
    where?: MessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReactions to fetch.
     */
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReactions.
     */
    cursor?: MessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReactions.
     */
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }

  /**
   * MessageReaction findMany
   */
  export type MessageReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReactions to fetch.
     */
    where?: MessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReactions to fetch.
     */
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageReactions.
     */
    cursor?: MessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReactions.
     */
    skip?: number
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }

  /**
   * MessageReaction create
   */
  export type MessageReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageReaction.
     */
    data: XOR<MessageReactionCreateInput, MessageReactionUncheckedCreateInput>
  }

  /**
   * MessageReaction createMany
   */
  export type MessageReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageReactions.
     */
    data: MessageReactionCreateManyInput | MessageReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageReaction createManyAndReturn
   */
  export type MessageReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * The data used to create many MessageReactions.
     */
    data: MessageReactionCreateManyInput | MessageReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageReaction update
   */
  export type MessageReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageReaction.
     */
    data: XOR<MessageReactionUpdateInput, MessageReactionUncheckedUpdateInput>
    /**
     * Choose, which MessageReaction to update.
     */
    where: MessageReactionWhereUniqueInput
  }

  /**
   * MessageReaction updateMany
   */
  export type MessageReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageReactions.
     */
    data: XOR<MessageReactionUpdateManyMutationInput, MessageReactionUncheckedUpdateManyInput>
    /**
     * Filter which MessageReactions to update
     */
    where?: MessageReactionWhereInput
    /**
     * Limit how many MessageReactions to update.
     */
    limit?: number
  }

  /**
   * MessageReaction updateManyAndReturn
   */
  export type MessageReactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * The data used to update MessageReactions.
     */
    data: XOR<MessageReactionUpdateManyMutationInput, MessageReactionUncheckedUpdateManyInput>
    /**
     * Filter which MessageReactions to update
     */
    where?: MessageReactionWhereInput
    /**
     * Limit how many MessageReactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageReaction upsert
   */
  export type MessageReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageReaction to update in case it exists.
     */
    where: MessageReactionWhereUniqueInput
    /**
     * In case the MessageReaction found by the `where` argument doesn't exist, create a new MessageReaction with this data.
     */
    create: XOR<MessageReactionCreateInput, MessageReactionUncheckedCreateInput>
    /**
     * In case the MessageReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageReactionUpdateInput, MessageReactionUncheckedUpdateInput>
  }

  /**
   * MessageReaction delete
   */
  export type MessageReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter which MessageReaction to delete.
     */
    where: MessageReactionWhereUniqueInput
  }

  /**
   * MessageReaction deleteMany
   */
  export type MessageReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReactions to delete
     */
    where?: MessageReactionWhereInput
    /**
     * Limit how many MessageReactions to delete.
     */
    limit?: number
  }

  /**
   * MessageReaction without action
   */
  export type MessageReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReaction
     */
    omit?: MessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReactionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    profile: 'profile',
    phone: 'phone',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripeSubscriptionStatus: 'stripeSubscriptionStatus',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    whatleadCompanyId: 'whatleadCompanyId',
    plan: 'plan',
    status: 'status',
    maxInstances: 'maxInstances',
    messagesPerDay: 'messagesPerDay',
    features: 'features',
    support: 'support',
    trialEndDate: 'trialEndDate',
    referredBy: 'referredBy',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CompaniesUnitesScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    productdefault: 'productdefault',
    campaignstatus: 'campaignstatus',
    enablecuration: 'enablecuration',
    enabletosendustolead: 'enabletosendustolead',
    enabled: 'enabled',
    isconversationia: 'isconversationia',
    campaignnumberbusiness: 'campaignnumberbusiness',
    whatsappprovider: 'whatsappprovider',
    enabletosendprovider: 'enabletosendprovider',
    enabletosecondcallprovider: 'enabletosecondcallprovider',
    integrationconfiguration: 'integrationconfiguration',
    integrationname: 'integrationname',
    templatelistvars: 'templatelistvars',
    metaconfiguration: 'metaconfiguration',
    messageperruns: 'messageperruns',
    notifyconfiguration: 'notifyconfiguration',
    updatedAt: 'updatedAt',
    whitelabel_config: 'whitelabel_config',
    whatleadCompanyId: 'whatleadCompanyId'
  };

  export type CompaniesUnitesScalarFieldEnum = (typeof CompaniesUnitesScalarFieldEnum)[keyof typeof CompaniesUnitesScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    externalid: 'externalid',
    sourceid: 'sourceid',
    name: 'name',
    phone: 'phone',
    email: 'email',
    lastmessagesent: 'lastmessagesent',
    stepsecondcalltemplate: 'stepsecondcalltemplate',
    stepnointeraction: 'stepnointeraction',
    nointeractionquantity: 'nointeractionquantity',
    accepttemplate: 'accepttemplate',
    acceptsecondtemplate: 'acceptsecondtemplate',
    status: 'status',
    dialog: 'dialog',
    configid: 'configid',
    whitelabelconfig: 'whitelabelconfig',
    lastintent: 'lastintent',
    broker: 'broker',
    origin: 'origin',
    send: 'send',
    sendAt: 'sendAt',
    isBusinessAutoResponder: 'isBusinessAutoResponder',
    startmessage: 'startmessage',
    schedulingdata: 'schedulingdata',
    productchoosebyclient: 'productchoosebyclient',
    productid: 'productid',
    createdat: 'createdat',
    updatedat: 'updatedat',
    curation: 'curation'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    stripePaymentId: 'stripePaymentId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    dueDate: 'dueDate',
    customerId: 'customerId',
    metadata: 'metadata',
    disputeStatus: 'disputeStatus',
    disputeReason: 'disputeReason',
    cancelReason: 'cancelReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const InstanceScalarFieldEnum: {
    id: 'id',
    instanceName: 'instanceName',
    connectionStatus: 'connectionStatus',
    number: 'number',
    ownerJid: 'ownerJid',
    profilePicUrl: 'profilePicUrl',
    integration: 'integration',
    token: 'token',
    clientName: 'clientName',
    profileName: 'profileName',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    disconnectedAt: 'disconnectedAt',
    disconnectionObject: 'disconnectionObject',
    disconnectionReasonCode: 'disconnectionReasonCode',
    proxyConfig: 'proxyConfig',
    typebot: 'typebot'
  };

  export type InstanceScalarFieldEnum = (typeof InstanceScalarFieldEnum)[keyof typeof InstanceScalarFieldEnum]


  export const MediaStatsScalarFieldEnum: {
    id: 'id',
    instanceName: 'instanceName',
    date: 'date',
    text: 'text',
    image: 'image',
    video: 'video',
    audio: 'audio',
    sticker: 'sticker',
    reaction: 'reaction',
    isReceived: 'isReceived',
    totalDaily: 'totalDaily',
    totalAllTime: 'totalAllTime',
    totalSent: 'totalSent',
    totalReceived: 'totalReceived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaStatsScalarFieldEnum = (typeof MediaStatsScalarFieldEnum)[keyof typeof MediaStatsScalarFieldEnum]


  export const WarmupStatsScalarFieldEnum: {
    id: 'id',
    instanceName: 'instanceName',
    status: 'status',
    messagesSent: 'messagesSent',
    messagesReceived: 'messagesReceived',
    warmupTime: 'warmupTime',
    lastActive: 'lastActive',
    startTime: 'startTime',
    pauseTime: 'pauseTime',
    progress: 'progress',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    mediaStatsId: 'mediaStatsId',
    mediaReceivedId: 'mediaReceivedId'
  };

  export type WarmupStatsScalarFieldEnum = (typeof WarmupStatsScalarFieldEnum)[keyof typeof WarmupStatsScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    type: 'type',
    message: 'message',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType',
    mediaCaption: 'mediaCaption',
    scheduledDate: 'scheduledDate',
    scheduledStatus: 'scheduledStatus',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    pausedAt: 'pausedAt',
    progress: 'progress',
    minDelay: 'minDelay',
    maxDelay: 'maxDelay',
    userId: 'userId',
    instanceId: 'instanceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isAiResponder: 'isAiResponder'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignDispatchScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    instanceName: 'instanceName',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignDispatchScalarFieldEnum = (typeof CampaignDispatchScalarFieldEnum)[keyof typeof CampaignDispatchScalarFieldEnum]


  export const CampaignMessageScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    type: 'type',
    content: 'content',
    order: 'order',
    caption: 'caption',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignMessageScalarFieldEnum = (typeof CampaignMessageScalarFieldEnum)[keyof typeof CampaignMessageScalarFieldEnum]


  export const CampaignLeadScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    campaignId: 'campaignId',
    name: 'name',
    phone: 'phone',
    status: 'status',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    readAt: 'readAt',
    failedAt: 'failedAt',
    failureReason: 'failureReason',
    messageId: 'messageId',
    segment: 'segment',
    engagement: 'engagement',
    syncedWithCRM: 'syncedWithCRM',
    syncedAt: 'syncedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignLeadScalarFieldEnum = (typeof CampaignLeadScalarFieldEnum)[keyof typeof CampaignLeadScalarFieldEnum]


  export const CampaignScheduleScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    instanceName: 'instanceName',
    scheduledDate: 'scheduledDate',
    status: 'status',
    message: 'message',
    mediaType: 'mediaType',
    mediaUrl: 'mediaUrl',
    mediaCaption: 'mediaCaption',
    minDelay: 'minDelay',
    maxDelay: 'maxDelay',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type CampaignScheduleScalarFieldEnum = (typeof CampaignScheduleScalarFieldEnum)[keyof typeof CampaignScheduleScalarFieldEnum]


  export const CampaignStatisticsScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    totalLeads: 'totalLeads',
    sentCount: 'sentCount',
    deliveredCount: 'deliveredCount',
    readCount: 'readCount',
    failedCount: 'failedCount',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignStatisticsScalarFieldEnum = (typeof CampaignStatisticsScalarFieldEnum)[keyof typeof CampaignStatisticsScalarFieldEnum]


  export const MessageLogScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    campaignLeadId: 'campaignLeadId',
    leadId: 'leadId',
    messageId: 'messageId',
    messageDate: 'messageDate',
    messageType: 'messageType',
    content: 'content',
    status: 'status',
    statusHistory: 'statusHistory',
    sentAt: 'sentAt',
    deliveredAt: 'deliveredAt',
    readAt: 'readAt',
    failedAt: 'failedAt',
    failureReason: 'failureReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageLogScalarFieldEnum = (typeof MessageLogScalarFieldEnum)[keyof typeof MessageLogScalarFieldEnum]


  export const MessageAnalyticsScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    date: 'date',
    sentCount: 'sentCount',
    deliveredCount: 'deliveredCount',
    readCount: 'readCount',
    respondedCount: 'respondedCount',
    failedCount: 'failedCount'
  };

  export type MessageAnalyticsScalarFieldEnum = (typeof MessageAnalyticsScalarFieldEnum)[keyof typeof MessageAnalyticsScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    phone: 'phone',
    name: 'name',
    email: 'email',
    company: 'company',
    notes: 'notes',
    tags: 'tags',
    userId: 'userId',
    lastInteractionAt: 'lastInteractionAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    source: 'source'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    instanceName: 'instanceName',
    contactPhone: 'contactPhone',
    contactName: 'contactName',
    contactAvatar: 'contactAvatar',
    lastMessageAt: 'lastMessageAt',
    status: 'status',
    tags: 'tags',
    isActive: 'isActive',
    contactId: 'contactId',
    userId: 'userId',
    isGroup: 'isGroup',
    groupMetadata: 'groupMetadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    messageId: 'messageId',
    content: 'content',
    type: 'type',
    sender: 'sender',
    status: 'status',
    timestamp: 'timestamp',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType',
    replyTo: 'replyTo',
    userId: 'userId',
    failureReason: 'failureReason',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageAttachmentScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    type: 'type',
    url: 'url',
    name: 'name',
    mimeType: 'mimeType',
    filename: 'filename',
    size: 'size',
    createdAt: 'createdAt'
  };

  export type MessageAttachmentScalarFieldEnum = (typeof MessageAttachmentScalarFieldEnum)[keyof typeof MessageAttachmentScalarFieldEnum]


  export const CampaignErrorLogScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    errorMessage: 'errorMessage',
    errorDetails: 'errorDetails',
    createdAt: 'createdAt'
  };

  export type CampaignErrorLogScalarFieldEnum = (typeof CampaignErrorLogScalarFieldEnum)[keyof typeof CampaignErrorLogScalarFieldEnum]


  export const ContactNoteScalarFieldEnum: {
    id: 'id',
    contactId: 'contactId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type ContactNoteScalarFieldEnum = (typeof ContactNoteScalarFieldEnum)[keyof typeof ContactNoteScalarFieldEnum]


  export const MessageReactionScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    conversationId: 'conversationId',
    reaction: 'reaction',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type MessageReactionScalarFieldEnum = (typeof MessageReactionScalarFieldEnum)[keyof typeof MessageReactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'InstanceStatus'
   */
  export type EnumInstanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstanceStatus'>
    


  /**
   * Reference to a field of type 'InstanceStatus[]'
   */
  export type ListEnumInstanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstanceStatus[]'>
    


  /**
   * Reference to a field of type 'MessageStatus'
   */
  export type EnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus'>
    


  /**
   * Reference to a field of type 'MessageStatus[]'
   */
  export type ListEnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    active?: BoolNullableFilter<"Company"> | boolean | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    WhatleadUser?: UserListRelationFilter
    whatleadparceiroconfigs?: CompaniesUnitesListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    WhatleadUser?: UserOrderByRelationAggregateInput
    whatleadparceiroconfigs?: CompaniesUnitesOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    active?: BoolNullableFilter<"Company"> | boolean | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    WhatleadUser?: UserListRelationFilter
    whatleadparceiroconfigs?: CompaniesUnitesListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    active?: BoolNullableWithAggregatesFilter<"Company"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profile?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionStatus?: StringNullableFilter<"User"> | string | null
    active?: BoolNullableFilter<"User"> | boolean | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    whatleadCompanyId?: StringFilter<"User"> | string
    plan?: StringFilter<"User"> | string
    status?: BoolFilter<"User"> | boolean
    maxInstances?: IntFilter<"User"> | number
    messagesPerDay?: IntFilter<"User"> | number
    features?: StringNullableListFilter<"User">
    support?: StringFilter<"User"> | string
    trialEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    referredBy?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    instances?: InstanceListRelationFilter
    payments?: PaymentListRelationFilter
    warmupStats?: WarmupStatsListRelationFilter
    Campaign?: CampaignListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    CampaignLead?: CampaignLeadListRelationFilter
    affiliate?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    affiliates?: UserListRelationFilter
    Message?: MessageListRelationFilter
    Conversation?: ConversationListRelationFilter
    contacts?: ContactListRelationFilter
    contactNotes?: ContactNoteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    profile?: SortOrder
    phone?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeSubscriptionStatus?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatleadCompanyId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
    features?: SortOrder
    support?: SortOrder
    trialEndDate?: SortOrderInput | SortOrder
    referredBy?: SortOrderInput | SortOrder
    role?: SortOrder
    instances?: InstanceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    warmupStats?: WarmupStatsOrderByRelationAggregateInput
    Campaign?: CampaignOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    CampaignLead?: CampaignLeadOrderByRelationAggregateInput
    affiliate?: UserOrderByWithRelationInput
    affiliates?: UserOrderByRelationAggregateInput
    Message?: MessageOrderByRelationAggregateInput
    Conversation?: ConversationOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    contactNotes?: ContactNoteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profile?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionStatus?: StringNullableFilter<"User"> | string | null
    active?: BoolNullableFilter<"User"> | boolean | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    whatleadCompanyId?: StringFilter<"User"> | string
    plan?: StringFilter<"User"> | string
    status?: BoolFilter<"User"> | boolean
    maxInstances?: IntFilter<"User"> | number
    messagesPerDay?: IntFilter<"User"> | number
    features?: StringNullableListFilter<"User">
    support?: StringFilter<"User"> | string
    trialEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    referredBy?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    instances?: InstanceListRelationFilter
    payments?: PaymentListRelationFilter
    warmupStats?: WarmupStatsListRelationFilter
    Campaign?: CampaignListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    CampaignLead?: CampaignLeadListRelationFilter
    affiliate?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    affiliates?: UserListRelationFilter
    Message?: MessageListRelationFilter
    Conversation?: ConversationListRelationFilter
    contacts?: ContactListRelationFilter
    contactNotes?: ContactNoteListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    profile?: SortOrder
    phone?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeSubscriptionStatus?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatleadCompanyId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
    features?: SortOrder
    support?: SortOrder
    trialEndDate?: SortOrderInput | SortOrder
    referredBy?: SortOrderInput | SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    profile?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripeSubscriptionStatus?: StringNullableWithAggregatesFilter<"User"> | string | null
    active?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    whatleadCompanyId?: StringWithAggregatesFilter<"User"> | string
    plan?: StringWithAggregatesFilter<"User"> | string
    status?: BoolWithAggregatesFilter<"User"> | boolean
    maxInstances?: IntWithAggregatesFilter<"User"> | number
    messagesPerDay?: IntWithAggregatesFilter<"User"> | number
    features?: StringNullableListFilter<"User">
    support?: StringWithAggregatesFilter<"User"> | string
    trialEndDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    referredBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
  }

  export type CompaniesUnitesWhereInput = {
    AND?: CompaniesUnitesWhereInput | CompaniesUnitesWhereInput[]
    OR?: CompaniesUnitesWhereInput[]
    NOT?: CompaniesUnitesWhereInput | CompaniesUnitesWhereInput[]
    id?: StringFilter<"CompaniesUnites"> | string
    createdAt?: DateTimeNullableFilter<"CompaniesUnites"> | Date | string | null
    name?: StringNullableFilter<"CompaniesUnites"> | string | null
    productdefault?: StringNullableFilter<"CompaniesUnites"> | string | null
    campaignstatus?: StringNullableFilter<"CompaniesUnites"> | string | null
    enablecuration?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabletosendustolead?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabled?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    isconversationia?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    campaignnumberbusiness?: StringNullableFilter<"CompaniesUnites"> | string | null
    whatsappprovider?: StringNullableFilter<"CompaniesUnites"> | string | null
    enabletosendprovider?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabletosecondcallprovider?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    integrationconfiguration?: JsonNullableFilter<"CompaniesUnites">
    integrationname?: StringNullableFilter<"CompaniesUnites"> | string | null
    templatelistvars?: JsonNullableListFilter<"CompaniesUnites">
    metaconfiguration?: JsonNullableFilter<"CompaniesUnites">
    messageperruns?: JsonNullableListFilter<"CompaniesUnites">
    notifyconfiguration?: JsonNullableFilter<"CompaniesUnites">
    updatedAt?: DateTimeNullableFilter<"CompaniesUnites"> | Date | string | null
    whitelabel_config?: StringFilter<"CompaniesUnites"> | string
    whatleadCompanyId?: StringNullableFilter<"CompaniesUnites"> | string | null
    leads?: LeadListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type CompaniesUnitesOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    productdefault?: SortOrderInput | SortOrder
    campaignstatus?: SortOrderInput | SortOrder
    enablecuration?: SortOrderInput | SortOrder
    enabletosendustolead?: SortOrderInput | SortOrder
    enabled?: SortOrderInput | SortOrder
    isconversationia?: SortOrderInput | SortOrder
    campaignnumberbusiness?: SortOrderInput | SortOrder
    whatsappprovider?: SortOrderInput | SortOrder
    enabletosendprovider?: SortOrderInput | SortOrder
    enabletosecondcallprovider?: SortOrderInput | SortOrder
    integrationconfiguration?: SortOrderInput | SortOrder
    integrationname?: SortOrderInput | SortOrder
    templatelistvars?: SortOrder
    metaconfiguration?: SortOrderInput | SortOrder
    messageperruns?: SortOrder
    notifyconfiguration?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    whitelabel_config?: SortOrder
    whatleadCompanyId?: SortOrderInput | SortOrder
    leads?: LeadOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type CompaniesUnitesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignnumberbusiness?: string
    AND?: CompaniesUnitesWhereInput | CompaniesUnitesWhereInput[]
    OR?: CompaniesUnitesWhereInput[]
    NOT?: CompaniesUnitesWhereInput | CompaniesUnitesWhereInput[]
    createdAt?: DateTimeNullableFilter<"CompaniesUnites"> | Date | string | null
    name?: StringNullableFilter<"CompaniesUnites"> | string | null
    productdefault?: StringNullableFilter<"CompaniesUnites"> | string | null
    campaignstatus?: StringNullableFilter<"CompaniesUnites"> | string | null
    enablecuration?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabletosendustolead?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabled?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    isconversationia?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    whatsappprovider?: StringNullableFilter<"CompaniesUnites"> | string | null
    enabletosendprovider?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabletosecondcallprovider?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    integrationconfiguration?: JsonNullableFilter<"CompaniesUnites">
    integrationname?: StringNullableFilter<"CompaniesUnites"> | string | null
    templatelistvars?: JsonNullableListFilter<"CompaniesUnites">
    metaconfiguration?: JsonNullableFilter<"CompaniesUnites">
    messageperruns?: JsonNullableListFilter<"CompaniesUnites">
    notifyconfiguration?: JsonNullableFilter<"CompaniesUnites">
    updatedAt?: DateTimeNullableFilter<"CompaniesUnites"> | Date | string | null
    whitelabel_config?: StringFilter<"CompaniesUnites"> | string
    whatleadCompanyId?: StringNullableFilter<"CompaniesUnites"> | string | null
    leads?: LeadListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id" | "campaignnumberbusiness">

  export type CompaniesUnitesOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    productdefault?: SortOrderInput | SortOrder
    campaignstatus?: SortOrderInput | SortOrder
    enablecuration?: SortOrderInput | SortOrder
    enabletosendustolead?: SortOrderInput | SortOrder
    enabled?: SortOrderInput | SortOrder
    isconversationia?: SortOrderInput | SortOrder
    campaignnumberbusiness?: SortOrderInput | SortOrder
    whatsappprovider?: SortOrderInput | SortOrder
    enabletosendprovider?: SortOrderInput | SortOrder
    enabletosecondcallprovider?: SortOrderInput | SortOrder
    integrationconfiguration?: SortOrderInput | SortOrder
    integrationname?: SortOrderInput | SortOrder
    templatelistvars?: SortOrder
    metaconfiguration?: SortOrderInput | SortOrder
    messageperruns?: SortOrder
    notifyconfiguration?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    whitelabel_config?: SortOrder
    whatleadCompanyId?: SortOrderInput | SortOrder
    _count?: CompaniesUnitesCountOrderByAggregateInput
    _max?: CompaniesUnitesMaxOrderByAggregateInput
    _min?: CompaniesUnitesMinOrderByAggregateInput
  }

  export type CompaniesUnitesScalarWhereWithAggregatesInput = {
    AND?: CompaniesUnitesScalarWhereWithAggregatesInput | CompaniesUnitesScalarWhereWithAggregatesInput[]
    OR?: CompaniesUnitesScalarWhereWithAggregatesInput[]
    NOT?: CompaniesUnitesScalarWhereWithAggregatesInput | CompaniesUnitesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompaniesUnites"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"CompaniesUnites"> | Date | string | null
    name?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
    productdefault?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
    campaignstatus?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
    enablecuration?: BoolNullableWithAggregatesFilter<"CompaniesUnites"> | boolean | null
    enabletosendustolead?: BoolNullableWithAggregatesFilter<"CompaniesUnites"> | boolean | null
    enabled?: BoolNullableWithAggregatesFilter<"CompaniesUnites"> | boolean | null
    isconversationia?: BoolNullableWithAggregatesFilter<"CompaniesUnites"> | boolean | null
    campaignnumberbusiness?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
    whatsappprovider?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
    enabletosendprovider?: BoolNullableWithAggregatesFilter<"CompaniesUnites"> | boolean | null
    enabletosecondcallprovider?: BoolNullableWithAggregatesFilter<"CompaniesUnites"> | boolean | null
    integrationconfiguration?: JsonNullableWithAggregatesFilter<"CompaniesUnites">
    integrationname?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
    templatelistvars?: JsonNullableListFilter<"CompaniesUnites">
    metaconfiguration?: JsonNullableWithAggregatesFilter<"CompaniesUnites">
    messageperruns?: JsonNullableListFilter<"CompaniesUnites">
    notifyconfiguration?: JsonNullableWithAggregatesFilter<"CompaniesUnites">
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CompaniesUnites"> | Date | string | null
    whitelabel_config?: StringWithAggregatesFilter<"CompaniesUnites"> | string
    whatleadCompanyId?: StringNullableWithAggregatesFilter<"CompaniesUnites"> | string | null
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    externalid?: StringNullableFilter<"Lead"> | string | null
    sourceid?: StringNullableFilter<"Lead"> | string | null
    name?: StringFilter<"Lead"> | string
    phone?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    lastmessagesent?: DateTimeNullableFilter<"Lead"> | Date | string | null
    stepsecondcalltemplate?: IntNullableFilter<"Lead"> | number | null
    stepnointeraction?: IntNullableFilter<"Lead"> | number | null
    nointeractionquantity?: IntNullableFilter<"Lead"> | number | null
    accepttemplate?: BoolNullableFilter<"Lead"> | boolean | null
    acceptsecondtemplate?: BoolNullableFilter<"Lead"> | boolean | null
    status?: StringNullableFilter<"Lead"> | string | null
    dialog?: JsonNullableListFilter<"Lead">
    configid?: StringFilter<"Lead"> | string
    whitelabelconfig?: StringFilter<"Lead"> | string
    lastintent?: StringNullableFilter<"Lead"> | string | null
    broker?: StringNullableFilter<"Lead"> | string | null
    origin?: StringNullableFilter<"Lead"> | string | null
    send?: BoolNullableFilter<"Lead"> | boolean | null
    sendAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    isBusinessAutoResponder?: BoolNullableFilter<"Lead"> | boolean | null
    startmessage?: DateTimeNullableFilter<"Lead"> | Date | string | null
    schedulingdata?: StringNullableFilter<"Lead"> | string | null
    productchoosebyclient?: StringNullableFilter<"Lead"> | string | null
    productid?: IntNullableFilter<"Lead"> | number | null
    createdat?: DateTimeFilter<"Lead"> | Date | string
    updatedat?: DateTimeFilter<"Lead"> | Date | string
    curation?: JsonNullableFilter<"Lead">
    MessageLog?: MessageLogListRelationFilter
    config?: XOR<CompaniesUnitesScalarRelationFilter, CompaniesUnitesWhereInput>
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    externalid?: SortOrderInput | SortOrder
    sourceid?: SortOrderInput | SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    lastmessagesent?: SortOrderInput | SortOrder
    stepsecondcalltemplate?: SortOrderInput | SortOrder
    stepnointeraction?: SortOrderInput | SortOrder
    nointeractionquantity?: SortOrderInput | SortOrder
    accepttemplate?: SortOrderInput | SortOrder
    acceptsecondtemplate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    dialog?: SortOrder
    configid?: SortOrder
    whitelabelconfig?: SortOrder
    lastintent?: SortOrderInput | SortOrder
    broker?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    send?: SortOrderInput | SortOrder
    sendAt?: SortOrderInput | SortOrder
    isBusinessAutoResponder?: SortOrderInput | SortOrder
    startmessage?: SortOrderInput | SortOrder
    schedulingdata?: SortOrderInput | SortOrder
    productchoosebyclient?: SortOrderInput | SortOrder
    productid?: SortOrderInput | SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
    curation?: SortOrderInput | SortOrder
    MessageLog?: MessageLogOrderByRelationAggregateInput
    config?: CompaniesUnitesOrderByWithRelationInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    externalid?: StringNullableFilter<"Lead"> | string | null
    sourceid?: StringNullableFilter<"Lead"> | string | null
    name?: StringFilter<"Lead"> | string
    phone?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    lastmessagesent?: DateTimeNullableFilter<"Lead"> | Date | string | null
    stepsecondcalltemplate?: IntNullableFilter<"Lead"> | number | null
    stepnointeraction?: IntNullableFilter<"Lead"> | number | null
    nointeractionquantity?: IntNullableFilter<"Lead"> | number | null
    accepttemplate?: BoolNullableFilter<"Lead"> | boolean | null
    acceptsecondtemplate?: BoolNullableFilter<"Lead"> | boolean | null
    status?: StringNullableFilter<"Lead"> | string | null
    dialog?: JsonNullableListFilter<"Lead">
    configid?: StringFilter<"Lead"> | string
    whitelabelconfig?: StringFilter<"Lead"> | string
    lastintent?: StringNullableFilter<"Lead"> | string | null
    broker?: StringNullableFilter<"Lead"> | string | null
    origin?: StringNullableFilter<"Lead"> | string | null
    send?: BoolNullableFilter<"Lead"> | boolean | null
    sendAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    isBusinessAutoResponder?: BoolNullableFilter<"Lead"> | boolean | null
    startmessage?: DateTimeNullableFilter<"Lead"> | Date | string | null
    schedulingdata?: StringNullableFilter<"Lead"> | string | null
    productchoosebyclient?: StringNullableFilter<"Lead"> | string | null
    productid?: IntNullableFilter<"Lead"> | number | null
    createdat?: DateTimeFilter<"Lead"> | Date | string
    updatedat?: DateTimeFilter<"Lead"> | Date | string
    curation?: JsonNullableFilter<"Lead">
    MessageLog?: MessageLogListRelationFilter
    config?: XOR<CompaniesUnitesScalarRelationFilter, CompaniesUnitesWhereInput>
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    externalid?: SortOrderInput | SortOrder
    sourceid?: SortOrderInput | SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    lastmessagesent?: SortOrderInput | SortOrder
    stepsecondcalltemplate?: SortOrderInput | SortOrder
    stepnointeraction?: SortOrderInput | SortOrder
    nointeractionquantity?: SortOrderInput | SortOrder
    accepttemplate?: SortOrderInput | SortOrder
    acceptsecondtemplate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    dialog?: SortOrder
    configid?: SortOrder
    whitelabelconfig?: SortOrder
    lastintent?: SortOrderInput | SortOrder
    broker?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    send?: SortOrderInput | SortOrder
    sendAt?: SortOrderInput | SortOrder
    isBusinessAutoResponder?: SortOrderInput | SortOrder
    startmessage?: SortOrderInput | SortOrder
    schedulingdata?: SortOrderInput | SortOrder
    productchoosebyclient?: SortOrderInput | SortOrder
    productid?: SortOrderInput | SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
    curation?: SortOrderInput | SortOrder
    _count?: LeadCountOrderByAggregateInput
    _avg?: LeadAvgOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
    _sum?: LeadSumOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    externalid?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    sourceid?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    name?: StringWithAggregatesFilter<"Lead"> | string
    phone?: StringWithAggregatesFilter<"Lead"> | string
    email?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    lastmessagesent?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    stepsecondcalltemplate?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    stepnointeraction?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    nointeractionquantity?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    accepttemplate?: BoolNullableWithAggregatesFilter<"Lead"> | boolean | null
    acceptsecondtemplate?: BoolNullableWithAggregatesFilter<"Lead"> | boolean | null
    status?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    dialog?: JsonNullableListFilter<"Lead">
    configid?: StringWithAggregatesFilter<"Lead"> | string
    whitelabelconfig?: StringWithAggregatesFilter<"Lead"> | string
    lastintent?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    broker?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    origin?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    send?: BoolNullableWithAggregatesFilter<"Lead"> | boolean | null
    sendAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    isBusinessAutoResponder?: BoolNullableWithAggregatesFilter<"Lead"> | boolean | null
    startmessage?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    schedulingdata?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    productchoosebyclient?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    productid?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    createdat?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedat?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    curation?: JsonNullableWithAggregatesFilter<"Lead">
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    stripePaymentId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    dueDate?: DateTimeFilter<"Payment"> | Date | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    disputeStatus?: StringNullableFilter<"Payment"> | string | null
    disputeReason?: StringNullableFilter<"Payment"> | string | null
    cancelReason?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    userId?: StringNullableFilter<"Payment"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    customerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    disputeStatus?: SortOrderInput | SortOrder
    disputeReason?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePaymentId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    dueDate?: DateTimeFilter<"Payment"> | Date | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    disputeStatus?: StringNullableFilter<"Payment"> | string | null
    disputeReason?: StringNullableFilter<"Payment"> | string | null
    cancelReason?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    userId?: StringNullableFilter<"Payment"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "stripePaymentId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    customerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    disputeStatus?: SortOrderInput | SortOrder
    disputeReason?: SortOrderInput | SortOrder
    cancelReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    stripePaymentId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: IntWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    dueDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    customerId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    disputeStatus?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    disputeReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    cancelReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type InstanceWhereInput = {
    AND?: InstanceWhereInput | InstanceWhereInput[]
    OR?: InstanceWhereInput[]
    NOT?: InstanceWhereInput | InstanceWhereInput[]
    id?: StringFilter<"Instance"> | string
    instanceName?: StringFilter<"Instance"> | string
    connectionStatus?: EnumInstanceStatusFilter<"Instance"> | $Enums.InstanceStatus
    number?: StringNullableFilter<"Instance"> | string | null
    ownerJid?: StringNullableFilter<"Instance"> | string | null
    profilePicUrl?: StringNullableFilter<"Instance"> | string | null
    integration?: StringFilter<"Instance"> | string
    token?: StringNullableFilter<"Instance"> | string | null
    clientName?: StringNullableFilter<"Instance"> | string | null
    profileName?: StringNullableFilter<"Instance"> | string | null
    userId?: StringFilter<"Instance"> | string
    createdAt?: DateTimeFilter<"Instance"> | Date | string
    updatedAt?: DateTimeFilter<"Instance"> | Date | string
    disconnectedAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    disconnectionObject?: JsonNullableFilter<"Instance">
    disconnectionReasonCode?: StringNullableFilter<"Instance"> | string | null
    proxyConfig?: JsonNullableFilter<"Instance">
    typebot?: JsonNullableFilter<"Instance">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaigns?: CampaignListRelationFilter
    campaignSchedules?: CampaignScheduleListRelationFilter
    campaignDispatches?: CampaignDispatchListRelationFilter
    warmupStats?: WarmupStatsListRelationFilter
    mediaStats?: MediaStatsListRelationFilter
  }

  export type InstanceOrderByWithRelationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    connectionStatus?: SortOrder
    number?: SortOrderInput | SortOrder
    ownerJid?: SortOrderInput | SortOrder
    profilePicUrl?: SortOrderInput | SortOrder
    integration?: SortOrder
    token?: SortOrderInput | SortOrder
    clientName?: SortOrderInput | SortOrder
    profileName?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disconnectedAt?: SortOrderInput | SortOrder
    disconnectionObject?: SortOrderInput | SortOrder
    disconnectionReasonCode?: SortOrderInput | SortOrder
    proxyConfig?: SortOrderInput | SortOrder
    typebot?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    campaigns?: CampaignOrderByRelationAggregateInput
    campaignSchedules?: CampaignScheduleOrderByRelationAggregateInput
    campaignDispatches?: CampaignDispatchOrderByRelationAggregateInput
    warmupStats?: WarmupStatsOrderByRelationAggregateInput
    mediaStats?: MediaStatsOrderByRelationAggregateInput
  }

  export type InstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceName?: string
    AND?: InstanceWhereInput | InstanceWhereInput[]
    OR?: InstanceWhereInput[]
    NOT?: InstanceWhereInput | InstanceWhereInput[]
    connectionStatus?: EnumInstanceStatusFilter<"Instance"> | $Enums.InstanceStatus
    number?: StringNullableFilter<"Instance"> | string | null
    ownerJid?: StringNullableFilter<"Instance"> | string | null
    profilePicUrl?: StringNullableFilter<"Instance"> | string | null
    integration?: StringFilter<"Instance"> | string
    token?: StringNullableFilter<"Instance"> | string | null
    clientName?: StringNullableFilter<"Instance"> | string | null
    profileName?: StringNullableFilter<"Instance"> | string | null
    userId?: StringFilter<"Instance"> | string
    createdAt?: DateTimeFilter<"Instance"> | Date | string
    updatedAt?: DateTimeFilter<"Instance"> | Date | string
    disconnectedAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    disconnectionObject?: JsonNullableFilter<"Instance">
    disconnectionReasonCode?: StringNullableFilter<"Instance"> | string | null
    proxyConfig?: JsonNullableFilter<"Instance">
    typebot?: JsonNullableFilter<"Instance">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaigns?: CampaignListRelationFilter
    campaignSchedules?: CampaignScheduleListRelationFilter
    campaignDispatches?: CampaignDispatchListRelationFilter
    warmupStats?: WarmupStatsListRelationFilter
    mediaStats?: MediaStatsListRelationFilter
  }, "id" | "instanceName">

  export type InstanceOrderByWithAggregationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    connectionStatus?: SortOrder
    number?: SortOrderInput | SortOrder
    ownerJid?: SortOrderInput | SortOrder
    profilePicUrl?: SortOrderInput | SortOrder
    integration?: SortOrder
    token?: SortOrderInput | SortOrder
    clientName?: SortOrderInput | SortOrder
    profileName?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disconnectedAt?: SortOrderInput | SortOrder
    disconnectionObject?: SortOrderInput | SortOrder
    disconnectionReasonCode?: SortOrderInput | SortOrder
    proxyConfig?: SortOrderInput | SortOrder
    typebot?: SortOrderInput | SortOrder
    _count?: InstanceCountOrderByAggregateInput
    _max?: InstanceMaxOrderByAggregateInput
    _min?: InstanceMinOrderByAggregateInput
  }

  export type InstanceScalarWhereWithAggregatesInput = {
    AND?: InstanceScalarWhereWithAggregatesInput | InstanceScalarWhereWithAggregatesInput[]
    OR?: InstanceScalarWhereWithAggregatesInput[]
    NOT?: InstanceScalarWhereWithAggregatesInput | InstanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Instance"> | string
    instanceName?: StringWithAggregatesFilter<"Instance"> | string
    connectionStatus?: EnumInstanceStatusWithAggregatesFilter<"Instance"> | $Enums.InstanceStatus
    number?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    ownerJid?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    profilePicUrl?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    integration?: StringWithAggregatesFilter<"Instance"> | string
    token?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    clientName?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    profileName?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    userId?: StringWithAggregatesFilter<"Instance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Instance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Instance"> | Date | string
    disconnectedAt?: DateTimeNullableWithAggregatesFilter<"Instance"> | Date | string | null
    disconnectionObject?: JsonNullableWithAggregatesFilter<"Instance">
    disconnectionReasonCode?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    proxyConfig?: JsonNullableWithAggregatesFilter<"Instance">
    typebot?: JsonNullableWithAggregatesFilter<"Instance">
  }

  export type MediaStatsWhereInput = {
    AND?: MediaStatsWhereInput | MediaStatsWhereInput[]
    OR?: MediaStatsWhereInput[]
    NOT?: MediaStatsWhereInput | MediaStatsWhereInput[]
    id?: StringFilter<"MediaStats"> | string
    instanceName?: StringFilter<"MediaStats"> | string
    date?: DateTimeFilter<"MediaStats"> | Date | string
    text?: IntFilter<"MediaStats"> | number
    image?: IntFilter<"MediaStats"> | number
    video?: IntFilter<"MediaStats"> | number
    audio?: IntFilter<"MediaStats"> | number
    sticker?: IntFilter<"MediaStats"> | number
    reaction?: IntFilter<"MediaStats"> | number
    isReceived?: BoolFilter<"MediaStats"> | boolean
    totalDaily?: IntFilter<"MediaStats"> | number
    totalAllTime?: IntFilter<"MediaStats"> | number
    totalSent?: IntFilter<"MediaStats"> | number
    totalReceived?: IntFilter<"MediaStats"> | number
    createdAt?: DateTimeFilter<"MediaStats"> | Date | string
    updatedAt?: DateTimeFilter<"MediaStats"> | Date | string
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    warmupStatsReceived?: WarmupStatsListRelationFilter
    warmupStatsSent?: WarmupStatsListRelationFilter
  }

  export type MediaStatsOrderByWithRelationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    date?: SortOrder
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    isReceived?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instance?: InstanceOrderByWithRelationInput
    warmupStatsReceived?: WarmupStatsOrderByRelationAggregateInput
    warmupStatsSent?: WarmupStatsOrderByRelationAggregateInput
  }

  export type MediaStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaStatsWhereInput | MediaStatsWhereInput[]
    OR?: MediaStatsWhereInput[]
    NOT?: MediaStatsWhereInput | MediaStatsWhereInput[]
    instanceName?: StringFilter<"MediaStats"> | string
    date?: DateTimeFilter<"MediaStats"> | Date | string
    text?: IntFilter<"MediaStats"> | number
    image?: IntFilter<"MediaStats"> | number
    video?: IntFilter<"MediaStats"> | number
    audio?: IntFilter<"MediaStats"> | number
    sticker?: IntFilter<"MediaStats"> | number
    reaction?: IntFilter<"MediaStats"> | number
    isReceived?: BoolFilter<"MediaStats"> | boolean
    totalDaily?: IntFilter<"MediaStats"> | number
    totalAllTime?: IntFilter<"MediaStats"> | number
    totalSent?: IntFilter<"MediaStats"> | number
    totalReceived?: IntFilter<"MediaStats"> | number
    createdAt?: DateTimeFilter<"MediaStats"> | Date | string
    updatedAt?: DateTimeFilter<"MediaStats"> | Date | string
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    warmupStatsReceived?: WarmupStatsListRelationFilter
    warmupStatsSent?: WarmupStatsListRelationFilter
  }, "id">

  export type MediaStatsOrderByWithAggregationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    date?: SortOrder
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    isReceived?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaStatsCountOrderByAggregateInput
    _avg?: MediaStatsAvgOrderByAggregateInput
    _max?: MediaStatsMaxOrderByAggregateInput
    _min?: MediaStatsMinOrderByAggregateInput
    _sum?: MediaStatsSumOrderByAggregateInput
  }

  export type MediaStatsScalarWhereWithAggregatesInput = {
    AND?: MediaStatsScalarWhereWithAggregatesInput | MediaStatsScalarWhereWithAggregatesInput[]
    OR?: MediaStatsScalarWhereWithAggregatesInput[]
    NOT?: MediaStatsScalarWhereWithAggregatesInput | MediaStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaStats"> | string
    instanceName?: StringWithAggregatesFilter<"MediaStats"> | string
    date?: DateTimeWithAggregatesFilter<"MediaStats"> | Date | string
    text?: IntWithAggregatesFilter<"MediaStats"> | number
    image?: IntWithAggregatesFilter<"MediaStats"> | number
    video?: IntWithAggregatesFilter<"MediaStats"> | number
    audio?: IntWithAggregatesFilter<"MediaStats"> | number
    sticker?: IntWithAggregatesFilter<"MediaStats"> | number
    reaction?: IntWithAggregatesFilter<"MediaStats"> | number
    isReceived?: BoolWithAggregatesFilter<"MediaStats"> | boolean
    totalDaily?: IntWithAggregatesFilter<"MediaStats"> | number
    totalAllTime?: IntWithAggregatesFilter<"MediaStats"> | number
    totalSent?: IntWithAggregatesFilter<"MediaStats"> | number
    totalReceived?: IntWithAggregatesFilter<"MediaStats"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MediaStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MediaStats"> | Date | string
  }

  export type WarmupStatsWhereInput = {
    AND?: WarmupStatsWhereInput | WarmupStatsWhereInput[]
    OR?: WarmupStatsWhereInput[]
    NOT?: WarmupStatsWhereInput | WarmupStatsWhereInput[]
    id?: StringFilter<"WarmupStats"> | string
    instanceName?: StringFilter<"WarmupStats"> | string
    status?: StringFilter<"WarmupStats"> | string
    messagesSent?: IntFilter<"WarmupStats"> | number
    messagesReceived?: IntFilter<"WarmupStats"> | number
    warmupTime?: IntFilter<"WarmupStats"> | number
    lastActive?: DateTimeFilter<"WarmupStats"> | Date | string
    startTime?: DateTimeNullableFilter<"WarmupStats"> | Date | string | null
    pauseTime?: DateTimeNullableFilter<"WarmupStats"> | Date | string | null
    progress?: IntFilter<"WarmupStats"> | number
    userId?: StringFilter<"WarmupStats"> | string
    createdAt?: DateTimeFilter<"WarmupStats"> | Date | string
    updatedAt?: DateTimeFilter<"WarmupStats"> | Date | string
    mediaStatsId?: StringNullableFilter<"WarmupStats"> | string | null
    mediaReceivedId?: StringNullableFilter<"WarmupStats"> | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    mediaReceived?: XOR<MediaStatsNullableScalarRelationFilter, MediaStatsWhereInput> | null
    mediaStats?: XOR<MediaStatsNullableScalarRelationFilter, MediaStatsWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WarmupStatsOrderByWithRelationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    lastActive?: SortOrder
    startTime?: SortOrderInput | SortOrder
    pauseTime?: SortOrderInput | SortOrder
    progress?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaStatsId?: SortOrderInput | SortOrder
    mediaReceivedId?: SortOrderInput | SortOrder
    instance?: InstanceOrderByWithRelationInput
    mediaReceived?: MediaStatsOrderByWithRelationInput
    mediaStats?: MediaStatsOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type WarmupStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceName?: string
    AND?: WarmupStatsWhereInput | WarmupStatsWhereInput[]
    OR?: WarmupStatsWhereInput[]
    NOT?: WarmupStatsWhereInput | WarmupStatsWhereInput[]
    status?: StringFilter<"WarmupStats"> | string
    messagesSent?: IntFilter<"WarmupStats"> | number
    messagesReceived?: IntFilter<"WarmupStats"> | number
    warmupTime?: IntFilter<"WarmupStats"> | number
    lastActive?: DateTimeFilter<"WarmupStats"> | Date | string
    startTime?: DateTimeNullableFilter<"WarmupStats"> | Date | string | null
    pauseTime?: DateTimeNullableFilter<"WarmupStats"> | Date | string | null
    progress?: IntFilter<"WarmupStats"> | number
    userId?: StringFilter<"WarmupStats"> | string
    createdAt?: DateTimeFilter<"WarmupStats"> | Date | string
    updatedAt?: DateTimeFilter<"WarmupStats"> | Date | string
    mediaStatsId?: StringNullableFilter<"WarmupStats"> | string | null
    mediaReceivedId?: StringNullableFilter<"WarmupStats"> | string | null
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    mediaReceived?: XOR<MediaStatsNullableScalarRelationFilter, MediaStatsWhereInput> | null
    mediaStats?: XOR<MediaStatsNullableScalarRelationFilter, MediaStatsWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "instanceName">

  export type WarmupStatsOrderByWithAggregationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    lastActive?: SortOrder
    startTime?: SortOrderInput | SortOrder
    pauseTime?: SortOrderInput | SortOrder
    progress?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaStatsId?: SortOrderInput | SortOrder
    mediaReceivedId?: SortOrderInput | SortOrder
    _count?: WarmupStatsCountOrderByAggregateInput
    _avg?: WarmupStatsAvgOrderByAggregateInput
    _max?: WarmupStatsMaxOrderByAggregateInput
    _min?: WarmupStatsMinOrderByAggregateInput
    _sum?: WarmupStatsSumOrderByAggregateInput
  }

  export type WarmupStatsScalarWhereWithAggregatesInput = {
    AND?: WarmupStatsScalarWhereWithAggregatesInput | WarmupStatsScalarWhereWithAggregatesInput[]
    OR?: WarmupStatsScalarWhereWithAggregatesInput[]
    NOT?: WarmupStatsScalarWhereWithAggregatesInput | WarmupStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WarmupStats"> | string
    instanceName?: StringWithAggregatesFilter<"WarmupStats"> | string
    status?: StringWithAggregatesFilter<"WarmupStats"> | string
    messagesSent?: IntWithAggregatesFilter<"WarmupStats"> | number
    messagesReceived?: IntWithAggregatesFilter<"WarmupStats"> | number
    warmupTime?: IntWithAggregatesFilter<"WarmupStats"> | number
    lastActive?: DateTimeWithAggregatesFilter<"WarmupStats"> | Date | string
    startTime?: DateTimeNullableWithAggregatesFilter<"WarmupStats"> | Date | string | null
    pauseTime?: DateTimeNullableWithAggregatesFilter<"WarmupStats"> | Date | string | null
    progress?: IntWithAggregatesFilter<"WarmupStats"> | number
    userId?: StringWithAggregatesFilter<"WarmupStats"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WarmupStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WarmupStats"> | Date | string
    mediaStatsId?: StringNullableWithAggregatesFilter<"WarmupStats"> | string | null
    mediaReceivedId?: StringNullableWithAggregatesFilter<"WarmupStats"> | string | null
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    status?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    message?: StringNullableFilter<"Campaign"> | string | null
    mediaUrl?: StringNullableFilter<"Campaign"> | string | null
    mediaType?: StringNullableFilter<"Campaign"> | string | null
    mediaCaption?: StringNullableFilter<"Campaign"> | string | null
    scheduledDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    scheduledStatus?: StringNullableFilter<"Campaign"> | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    progress?: IntFilter<"Campaign"> | number
    minDelay?: IntFilter<"Campaign"> | number
    maxDelay?: IntFilter<"Campaign"> | number
    userId?: StringFilter<"Campaign"> | string
    instanceId?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    isAiResponder?: JsonNullableFilter<"Campaign">
    MessageLog?: MessageLogListRelationFilter
    leads?: CampaignLeadListRelationFilter
    messages?: CampaignMessageListRelationFilter
    statistics?: XOR<CampaignStatisticsNullableScalarRelationFilter, CampaignStatisticsWhereInput> | null
    dispatches?: CampaignDispatchListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    instance?: XOR<InstanceNullableScalarRelationFilter, InstanceWhereInput> | null
    CampaignErrorLog?: CampaignErrorLogListRelationFilter
    CampaignSchedule?: CampaignScheduleListRelationFilter
    MessageAnalytics?: MessageAnalyticsListRelationFilter
    contacts?: ContactListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    message?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    mediaCaption?: SortOrderInput | SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    scheduledStatus?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    pausedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    userId?: SortOrder
    instanceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAiResponder?: SortOrderInput | SortOrder
    MessageLog?: MessageLogOrderByRelationAggregateInput
    leads?: CampaignLeadOrderByRelationAggregateInput
    messages?: CampaignMessageOrderByRelationAggregateInput
    statistics?: CampaignStatisticsOrderByWithRelationInput
    dispatches?: CampaignDispatchOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    instance?: InstanceOrderByWithRelationInput
    CampaignErrorLog?: CampaignErrorLogOrderByRelationAggregateInput
    CampaignSchedule?: CampaignScheduleOrderByRelationAggregateInput
    MessageAnalytics?: MessageAnalyticsOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    status?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    message?: StringNullableFilter<"Campaign"> | string | null
    mediaUrl?: StringNullableFilter<"Campaign"> | string | null
    mediaType?: StringNullableFilter<"Campaign"> | string | null
    mediaCaption?: StringNullableFilter<"Campaign"> | string | null
    scheduledDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    scheduledStatus?: StringNullableFilter<"Campaign"> | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    progress?: IntFilter<"Campaign"> | number
    minDelay?: IntFilter<"Campaign"> | number
    maxDelay?: IntFilter<"Campaign"> | number
    userId?: StringFilter<"Campaign"> | string
    instanceId?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    isAiResponder?: JsonNullableFilter<"Campaign">
    MessageLog?: MessageLogListRelationFilter
    leads?: CampaignLeadListRelationFilter
    messages?: CampaignMessageListRelationFilter
    statistics?: XOR<CampaignStatisticsNullableScalarRelationFilter, CampaignStatisticsWhereInput> | null
    dispatches?: CampaignDispatchListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    instance?: XOR<InstanceNullableScalarRelationFilter, InstanceWhereInput> | null
    CampaignErrorLog?: CampaignErrorLogListRelationFilter
    CampaignSchedule?: CampaignScheduleListRelationFilter
    MessageAnalytics?: MessageAnalyticsListRelationFilter
    contacts?: ContactListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    message?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    mediaCaption?: SortOrderInput | SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    scheduledStatus?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    pausedAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    userId?: SortOrder
    instanceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAiResponder?: SortOrderInput | SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    status?: StringWithAggregatesFilter<"Campaign"> | string
    type?: StringWithAggregatesFilter<"Campaign"> | string
    message?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    mediaType?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    mediaCaption?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    scheduledDate?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    scheduledStatus?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    pausedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    progress?: IntWithAggregatesFilter<"Campaign"> | number
    minDelay?: IntWithAggregatesFilter<"Campaign"> | number
    maxDelay?: IntWithAggregatesFilter<"Campaign"> | number
    userId?: StringWithAggregatesFilter<"Campaign"> | string
    instanceId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    isAiResponder?: JsonNullableWithAggregatesFilter<"Campaign">
  }

  export type CampaignDispatchWhereInput = {
    AND?: CampaignDispatchWhereInput | CampaignDispatchWhereInput[]
    OR?: CampaignDispatchWhereInput[]
    NOT?: CampaignDispatchWhereInput | CampaignDispatchWhereInput[]
    id?: StringFilter<"CampaignDispatch"> | string
    campaignId?: StringFilter<"CampaignDispatch"> | string
    instanceName?: StringFilter<"CampaignDispatch"> | string
    status?: StringFilter<"CampaignDispatch"> | string
    startedAt?: DateTimeNullableFilter<"CampaignDispatch"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CampaignDispatch"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignDispatch"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignDispatch"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type CampaignDispatchOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    instance?: InstanceOrderByWithRelationInput
  }

  export type CampaignDispatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignDispatchWhereInput | CampaignDispatchWhereInput[]
    OR?: CampaignDispatchWhereInput[]
    NOT?: CampaignDispatchWhereInput | CampaignDispatchWhereInput[]
    campaignId?: StringFilter<"CampaignDispatch"> | string
    instanceName?: StringFilter<"CampaignDispatch"> | string
    status?: StringFilter<"CampaignDispatch"> | string
    startedAt?: DateTimeNullableFilter<"CampaignDispatch"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CampaignDispatch"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignDispatch"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignDispatch"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id">

  export type CampaignDispatchOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignDispatchCountOrderByAggregateInput
    _max?: CampaignDispatchMaxOrderByAggregateInput
    _min?: CampaignDispatchMinOrderByAggregateInput
  }

  export type CampaignDispatchScalarWhereWithAggregatesInput = {
    AND?: CampaignDispatchScalarWhereWithAggregatesInput | CampaignDispatchScalarWhereWithAggregatesInput[]
    OR?: CampaignDispatchScalarWhereWithAggregatesInput[]
    NOT?: CampaignDispatchScalarWhereWithAggregatesInput | CampaignDispatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignDispatch"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignDispatch"> | string
    instanceName?: StringWithAggregatesFilter<"CampaignDispatch"> | string
    status?: StringWithAggregatesFilter<"CampaignDispatch"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"CampaignDispatch"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"CampaignDispatch"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignDispatch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignDispatch"> | Date | string
  }

  export type CampaignMessageWhereInput = {
    AND?: CampaignMessageWhereInput | CampaignMessageWhereInput[]
    OR?: CampaignMessageWhereInput[]
    NOT?: CampaignMessageWhereInput | CampaignMessageWhereInput[]
    id?: StringFilter<"CampaignMessage"> | string
    campaignId?: StringFilter<"CampaignMessage"> | string
    type?: StringFilter<"CampaignMessage"> | string
    content?: StringFilter<"CampaignMessage"> | string
    order?: IntFilter<"CampaignMessage"> | number
    caption?: StringNullableFilter<"CampaignMessage"> | string | null
    createdAt?: DateTimeFilter<"CampaignMessage"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignMessage"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignMessageOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    caption?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignMessageWhereInput | CampaignMessageWhereInput[]
    OR?: CampaignMessageWhereInput[]
    NOT?: CampaignMessageWhereInput | CampaignMessageWhereInput[]
    campaignId?: StringFilter<"CampaignMessage"> | string
    type?: StringFilter<"CampaignMessage"> | string
    content?: StringFilter<"CampaignMessage"> | string
    order?: IntFilter<"CampaignMessage"> | number
    caption?: StringNullableFilter<"CampaignMessage"> | string | null
    createdAt?: DateTimeFilter<"CampaignMessage"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignMessage"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignMessageOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    caption?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignMessageCountOrderByAggregateInput
    _avg?: CampaignMessageAvgOrderByAggregateInput
    _max?: CampaignMessageMaxOrderByAggregateInput
    _min?: CampaignMessageMinOrderByAggregateInput
    _sum?: CampaignMessageSumOrderByAggregateInput
  }

  export type CampaignMessageScalarWhereWithAggregatesInput = {
    AND?: CampaignMessageScalarWhereWithAggregatesInput | CampaignMessageScalarWhereWithAggregatesInput[]
    OR?: CampaignMessageScalarWhereWithAggregatesInput[]
    NOT?: CampaignMessageScalarWhereWithAggregatesInput | CampaignMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignMessage"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignMessage"> | string
    type?: StringWithAggregatesFilter<"CampaignMessage"> | string
    content?: StringWithAggregatesFilter<"CampaignMessage"> | string
    order?: IntWithAggregatesFilter<"CampaignMessage"> | number
    caption?: StringNullableWithAggregatesFilter<"CampaignMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignMessage"> | Date | string
  }

  export type CampaignLeadWhereInput = {
    AND?: CampaignLeadWhereInput | CampaignLeadWhereInput[]
    OR?: CampaignLeadWhereInput[]
    NOT?: CampaignLeadWhereInput | CampaignLeadWhereInput[]
    id?: StringFilter<"CampaignLead"> | string
    userId?: StringFilter<"CampaignLead"> | string
    campaignId?: StringFilter<"CampaignLead"> | string
    name?: StringNullableFilter<"CampaignLead"> | string | null
    phone?: StringFilter<"CampaignLead"> | string
    status?: StringFilter<"CampaignLead"> | string
    sentAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    readAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    failureReason?: StringNullableFilter<"CampaignLead"> | string | null
    messageId?: StringNullableFilter<"CampaignLead"> | string | null
    segment?: StringNullableFilter<"CampaignLead"> | string | null
    engagement?: StringNullableFilter<"CampaignLead"> | string | null
    syncedWithCRM?: BoolFilter<"CampaignLead"> | boolean
    syncedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignLead"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignLead"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messageLogs?: MessageLogListRelationFilter
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignLeadOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    segment?: SortOrderInput | SortOrder
    engagement?: SortOrderInput | SortOrder
    syncedWithCRM?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    messageLogs?: MessageLogOrderByRelationAggregateInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignLeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unique_campaign_phone?: CampaignLeadUnique_campaign_phoneCompoundUniqueInput
    AND?: CampaignLeadWhereInput | CampaignLeadWhereInput[]
    OR?: CampaignLeadWhereInput[]
    NOT?: CampaignLeadWhereInput | CampaignLeadWhereInput[]
    userId?: StringFilter<"CampaignLead"> | string
    campaignId?: StringFilter<"CampaignLead"> | string
    name?: StringNullableFilter<"CampaignLead"> | string | null
    phone?: StringFilter<"CampaignLead"> | string
    status?: StringFilter<"CampaignLead"> | string
    sentAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    readAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    failureReason?: StringNullableFilter<"CampaignLead"> | string | null
    messageId?: StringNullableFilter<"CampaignLead"> | string | null
    segment?: StringNullableFilter<"CampaignLead"> | string | null
    engagement?: StringNullableFilter<"CampaignLead"> | string | null
    syncedWithCRM?: BoolFilter<"CampaignLead"> | boolean
    syncedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignLead"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignLead"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messageLogs?: MessageLogListRelationFilter
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id" | "unique_campaign_phone">

  export type CampaignLeadOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    segment?: SortOrderInput | SortOrder
    engagement?: SortOrderInput | SortOrder
    syncedWithCRM?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignLeadCountOrderByAggregateInput
    _max?: CampaignLeadMaxOrderByAggregateInput
    _min?: CampaignLeadMinOrderByAggregateInput
  }

  export type CampaignLeadScalarWhereWithAggregatesInput = {
    AND?: CampaignLeadScalarWhereWithAggregatesInput | CampaignLeadScalarWhereWithAggregatesInput[]
    OR?: CampaignLeadScalarWhereWithAggregatesInput[]
    NOT?: CampaignLeadScalarWhereWithAggregatesInput | CampaignLeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignLead"> | string
    userId?: StringWithAggregatesFilter<"CampaignLead"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignLead"> | string
    name?: StringNullableWithAggregatesFilter<"CampaignLead"> | string | null
    phone?: StringWithAggregatesFilter<"CampaignLead"> | string
    status?: StringWithAggregatesFilter<"CampaignLead"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
    failureReason?: StringNullableWithAggregatesFilter<"CampaignLead"> | string | null
    messageId?: StringNullableWithAggregatesFilter<"CampaignLead"> | string | null
    segment?: StringNullableWithAggregatesFilter<"CampaignLead"> | string | null
    engagement?: StringNullableWithAggregatesFilter<"CampaignLead"> | string | null
    syncedWithCRM?: BoolWithAggregatesFilter<"CampaignLead"> | boolean
    syncedAt?: DateTimeNullableWithAggregatesFilter<"CampaignLead"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignLead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignLead"> | Date | string
  }

  export type CampaignScheduleWhereInput = {
    AND?: CampaignScheduleWhereInput | CampaignScheduleWhereInput[]
    OR?: CampaignScheduleWhereInput[]
    NOT?: CampaignScheduleWhereInput | CampaignScheduleWhereInput[]
    id?: StringFilter<"CampaignSchedule"> | string
    campaignId?: StringFilter<"CampaignSchedule"> | string
    instanceName?: StringFilter<"CampaignSchedule"> | string
    scheduledDate?: DateTimeFilter<"CampaignSchedule"> | Date | string
    status?: StringFilter<"CampaignSchedule"> | string
    message?: StringNullableFilter<"CampaignSchedule"> | string | null
    mediaType?: StringNullableFilter<"CampaignSchedule"> | string | null
    mediaUrl?: StringNullableFilter<"CampaignSchedule"> | string | null
    mediaCaption?: StringNullableFilter<"CampaignSchedule"> | string | null
    minDelay?: IntFilter<"CampaignSchedule"> | number
    maxDelay?: IntFilter<"CampaignSchedule"> | number
    createdAt?: DateTimeFilter<"CampaignSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignSchedule"> | Date | string
    startedAt?: DateTimeNullableFilter<"CampaignSchedule"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CampaignSchedule"> | Date | string | null
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type CampaignScheduleOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    instanceName?: SortOrder
    scheduledDate?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaCaption?: SortOrderInput | SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    campaign?: CampaignOrderByWithRelationInput
    instance?: InstanceOrderByWithRelationInput
  }

  export type CampaignScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignScheduleWhereInput | CampaignScheduleWhereInput[]
    OR?: CampaignScheduleWhereInput[]
    NOT?: CampaignScheduleWhereInput | CampaignScheduleWhereInput[]
    campaignId?: StringFilter<"CampaignSchedule"> | string
    instanceName?: StringFilter<"CampaignSchedule"> | string
    scheduledDate?: DateTimeFilter<"CampaignSchedule"> | Date | string
    status?: StringFilter<"CampaignSchedule"> | string
    message?: StringNullableFilter<"CampaignSchedule"> | string | null
    mediaType?: StringNullableFilter<"CampaignSchedule"> | string | null
    mediaUrl?: StringNullableFilter<"CampaignSchedule"> | string | null
    mediaCaption?: StringNullableFilter<"CampaignSchedule"> | string | null
    minDelay?: IntFilter<"CampaignSchedule"> | number
    maxDelay?: IntFilter<"CampaignSchedule"> | number
    createdAt?: DateTimeFilter<"CampaignSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignSchedule"> | Date | string
    startedAt?: DateTimeNullableFilter<"CampaignSchedule"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CampaignSchedule"> | Date | string | null
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id">

  export type CampaignScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    instanceName?: SortOrder
    scheduledDate?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaCaption?: SortOrderInput | SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: CampaignScheduleCountOrderByAggregateInput
    _avg?: CampaignScheduleAvgOrderByAggregateInput
    _max?: CampaignScheduleMaxOrderByAggregateInput
    _min?: CampaignScheduleMinOrderByAggregateInput
    _sum?: CampaignScheduleSumOrderByAggregateInput
  }

  export type CampaignScheduleScalarWhereWithAggregatesInput = {
    AND?: CampaignScheduleScalarWhereWithAggregatesInput | CampaignScheduleScalarWhereWithAggregatesInput[]
    OR?: CampaignScheduleScalarWhereWithAggregatesInput[]
    NOT?: CampaignScheduleScalarWhereWithAggregatesInput | CampaignScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignSchedule"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignSchedule"> | string
    instanceName?: StringWithAggregatesFilter<"CampaignSchedule"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"CampaignSchedule"> | Date | string
    status?: StringWithAggregatesFilter<"CampaignSchedule"> | string
    message?: StringNullableWithAggregatesFilter<"CampaignSchedule"> | string | null
    mediaType?: StringNullableWithAggregatesFilter<"CampaignSchedule"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"CampaignSchedule"> | string | null
    mediaCaption?: StringNullableWithAggregatesFilter<"CampaignSchedule"> | string | null
    minDelay?: IntWithAggregatesFilter<"CampaignSchedule"> | number
    maxDelay?: IntWithAggregatesFilter<"CampaignSchedule"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CampaignSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignSchedule"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"CampaignSchedule"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"CampaignSchedule"> | Date | string | null
  }

  export type CampaignStatisticsWhereInput = {
    AND?: CampaignStatisticsWhereInput | CampaignStatisticsWhereInput[]
    OR?: CampaignStatisticsWhereInput[]
    NOT?: CampaignStatisticsWhereInput | CampaignStatisticsWhereInput[]
    id?: StringFilter<"CampaignStatistics"> | string
    campaignId?: StringFilter<"CampaignStatistics"> | string
    totalLeads?: IntFilter<"CampaignStatistics"> | number
    sentCount?: IntFilter<"CampaignStatistics"> | number
    deliveredCount?: IntFilter<"CampaignStatistics"> | number
    readCount?: IntFilter<"CampaignStatistics"> | number
    failedCount?: IntFilter<"CampaignStatistics"> | number
    startedAt?: DateTimeNullableFilter<"CampaignStatistics"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CampaignStatistics"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignStatistics"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignStatistics"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignStatisticsOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignStatisticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId?: string
    AND?: CampaignStatisticsWhereInput | CampaignStatisticsWhereInput[]
    OR?: CampaignStatisticsWhereInput[]
    NOT?: CampaignStatisticsWhereInput | CampaignStatisticsWhereInput[]
    totalLeads?: IntFilter<"CampaignStatistics"> | number
    sentCount?: IntFilter<"CampaignStatistics"> | number
    deliveredCount?: IntFilter<"CampaignStatistics"> | number
    readCount?: IntFilter<"CampaignStatistics"> | number
    failedCount?: IntFilter<"CampaignStatistics"> | number
    startedAt?: DateTimeNullableFilter<"CampaignStatistics"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CampaignStatistics"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignStatistics"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignStatistics"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id" | "campaignId">

  export type CampaignStatisticsOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignStatisticsCountOrderByAggregateInput
    _avg?: CampaignStatisticsAvgOrderByAggregateInput
    _max?: CampaignStatisticsMaxOrderByAggregateInput
    _min?: CampaignStatisticsMinOrderByAggregateInput
    _sum?: CampaignStatisticsSumOrderByAggregateInput
  }

  export type CampaignStatisticsScalarWhereWithAggregatesInput = {
    AND?: CampaignStatisticsScalarWhereWithAggregatesInput | CampaignStatisticsScalarWhereWithAggregatesInput[]
    OR?: CampaignStatisticsScalarWhereWithAggregatesInput[]
    NOT?: CampaignStatisticsScalarWhereWithAggregatesInput | CampaignStatisticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignStatistics"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignStatistics"> | string
    totalLeads?: IntWithAggregatesFilter<"CampaignStatistics"> | number
    sentCount?: IntWithAggregatesFilter<"CampaignStatistics"> | number
    deliveredCount?: IntWithAggregatesFilter<"CampaignStatistics"> | number
    readCount?: IntWithAggregatesFilter<"CampaignStatistics"> | number
    failedCount?: IntWithAggregatesFilter<"CampaignStatistics"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"CampaignStatistics"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"CampaignStatistics"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignStatistics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignStatistics"> | Date | string
  }

  export type MessageLogWhereInput = {
    AND?: MessageLogWhereInput | MessageLogWhereInput[]
    OR?: MessageLogWhereInput[]
    NOT?: MessageLogWhereInput | MessageLogWhereInput[]
    id?: StringFilter<"MessageLog"> | string
    campaignId?: StringFilter<"MessageLog"> | string
    campaignLeadId?: StringFilter<"MessageLog"> | string
    leadId?: StringNullableFilter<"MessageLog"> | string | null
    messageId?: StringFilter<"MessageLog"> | string
    messageDate?: DateTimeFilter<"MessageLog"> | Date | string
    messageType?: StringFilter<"MessageLog"> | string
    content?: StringFilter<"MessageLog"> | string
    status?: StringFilter<"MessageLog"> | string
    statusHistory?: JsonNullableListFilter<"MessageLog">
    sentAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    readAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    failureReason?: StringNullableFilter<"MessageLog"> | string | null
    createdAt?: DateTimeFilter<"MessageLog"> | Date | string
    updatedAt?: DateTimeFilter<"MessageLog"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    campaignLead?: XOR<CampaignLeadScalarRelationFilter, CampaignLeadWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
  }

  export type MessageLogOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    campaignLeadId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    messageId?: SortOrder
    messageDate?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    status?: SortOrder
    statusHistory?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    campaignLead?: CampaignLeadOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
  }

  export type MessageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_messageDate?: MessageLogMessageIdMessageDateCompoundUniqueInput
    AND?: MessageLogWhereInput | MessageLogWhereInput[]
    OR?: MessageLogWhereInput[]
    NOT?: MessageLogWhereInput | MessageLogWhereInput[]
    campaignId?: StringFilter<"MessageLog"> | string
    campaignLeadId?: StringFilter<"MessageLog"> | string
    leadId?: StringNullableFilter<"MessageLog"> | string | null
    messageId?: StringFilter<"MessageLog"> | string
    messageDate?: DateTimeFilter<"MessageLog"> | Date | string
    messageType?: StringFilter<"MessageLog"> | string
    content?: StringFilter<"MessageLog"> | string
    status?: StringFilter<"MessageLog"> | string
    statusHistory?: JsonNullableListFilter<"MessageLog">
    sentAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    readAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    failureReason?: StringNullableFilter<"MessageLog"> | string | null
    createdAt?: DateTimeFilter<"MessageLog"> | Date | string
    updatedAt?: DateTimeFilter<"MessageLog"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    campaignLead?: XOR<CampaignLeadScalarRelationFilter, CampaignLeadWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
  }, "id" | "messageId_messageDate">

  export type MessageLogOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    campaignLeadId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    messageId?: SortOrder
    messageDate?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    status?: SortOrder
    statusHistory?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageLogCountOrderByAggregateInput
    _max?: MessageLogMaxOrderByAggregateInput
    _min?: MessageLogMinOrderByAggregateInput
  }

  export type MessageLogScalarWhereWithAggregatesInput = {
    AND?: MessageLogScalarWhereWithAggregatesInput | MessageLogScalarWhereWithAggregatesInput[]
    OR?: MessageLogScalarWhereWithAggregatesInput[]
    NOT?: MessageLogScalarWhereWithAggregatesInput | MessageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageLog"> | string
    campaignId?: StringWithAggregatesFilter<"MessageLog"> | string
    campaignLeadId?: StringWithAggregatesFilter<"MessageLog"> | string
    leadId?: StringNullableWithAggregatesFilter<"MessageLog"> | string | null
    messageId?: StringWithAggregatesFilter<"MessageLog"> | string
    messageDate?: DateTimeWithAggregatesFilter<"MessageLog"> | Date | string
    messageType?: StringWithAggregatesFilter<"MessageLog"> | string
    content?: StringWithAggregatesFilter<"MessageLog"> | string
    status?: StringWithAggregatesFilter<"MessageLog"> | string
    statusHistory?: JsonNullableListFilter<"MessageLog">
    sentAt?: DateTimeNullableWithAggregatesFilter<"MessageLog"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"MessageLog"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"MessageLog"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"MessageLog"> | Date | string | null
    failureReason?: StringNullableWithAggregatesFilter<"MessageLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MessageLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageLog"> | Date | string
  }

  export type MessageAnalyticsWhereInput = {
    AND?: MessageAnalyticsWhereInput | MessageAnalyticsWhereInput[]
    OR?: MessageAnalyticsWhereInput[]
    NOT?: MessageAnalyticsWhereInput | MessageAnalyticsWhereInput[]
    id?: StringFilter<"MessageAnalytics"> | string
    campaignId?: StringFilter<"MessageAnalytics"> | string
    date?: DateTimeFilter<"MessageAnalytics"> | Date | string
    sentCount?: IntFilter<"MessageAnalytics"> | number
    deliveredCount?: IntFilter<"MessageAnalytics"> | number
    readCount?: IntFilter<"MessageAnalytics"> | number
    respondedCount?: IntFilter<"MessageAnalytics"> | number
    failedCount?: IntFilter<"MessageAnalytics"> | number
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type MessageAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    respondedCount?: SortOrder
    failedCount?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type MessageAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_date?: MessageAnalyticsCampaignIdDateCompoundUniqueInput
    AND?: MessageAnalyticsWhereInput | MessageAnalyticsWhereInput[]
    OR?: MessageAnalyticsWhereInput[]
    NOT?: MessageAnalyticsWhereInput | MessageAnalyticsWhereInput[]
    campaignId?: StringFilter<"MessageAnalytics"> | string
    date?: DateTimeFilter<"MessageAnalytics"> | Date | string
    sentCount?: IntFilter<"MessageAnalytics"> | number
    deliveredCount?: IntFilter<"MessageAnalytics"> | number
    readCount?: IntFilter<"MessageAnalytics"> | number
    respondedCount?: IntFilter<"MessageAnalytics"> | number
    failedCount?: IntFilter<"MessageAnalytics"> | number
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id" | "campaignId_date">

  export type MessageAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    respondedCount?: SortOrder
    failedCount?: SortOrder
    _count?: MessageAnalyticsCountOrderByAggregateInput
    _avg?: MessageAnalyticsAvgOrderByAggregateInput
    _max?: MessageAnalyticsMaxOrderByAggregateInput
    _min?: MessageAnalyticsMinOrderByAggregateInput
    _sum?: MessageAnalyticsSumOrderByAggregateInput
  }

  export type MessageAnalyticsScalarWhereWithAggregatesInput = {
    AND?: MessageAnalyticsScalarWhereWithAggregatesInput | MessageAnalyticsScalarWhereWithAggregatesInput[]
    OR?: MessageAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: MessageAnalyticsScalarWhereWithAggregatesInput | MessageAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageAnalytics"> | string
    campaignId?: StringWithAggregatesFilter<"MessageAnalytics"> | string
    date?: DateTimeWithAggregatesFilter<"MessageAnalytics"> | Date | string
    sentCount?: IntWithAggregatesFilter<"MessageAnalytics"> | number
    deliveredCount?: IntWithAggregatesFilter<"MessageAnalytics"> | number
    readCount?: IntWithAggregatesFilter<"MessageAnalytics"> | number
    respondedCount?: IntWithAggregatesFilter<"MessageAnalytics"> | number
    failedCount?: IntWithAggregatesFilter<"MessageAnalytics"> | number
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    phone?: StringFilter<"Contact"> | string
    name?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    tags?: StringNullableListFilter<"Contact">
    userId?: StringFilter<"Contact"> | string
    lastInteractionAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    source?: StringNullableFilter<"Contact"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaigns?: CampaignListRelationFilter
    conversations?: ConversationListRelationFilter
    contactNotes?: ContactNoteListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    phone?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    userId?: SortOrder
    lastInteractionAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    campaigns?: CampaignOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    contactNotes?: ContactNoteOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone_userId?: ContactPhoneUserIdCompoundUniqueInput
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    phone?: StringFilter<"Contact"> | string
    name?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    tags?: StringNullableListFilter<"Contact">
    userId?: StringFilter<"Contact"> | string
    lastInteractionAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    source?: StringNullableFilter<"Contact"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaigns?: CampaignListRelationFilter
    conversations?: ConversationListRelationFilter
    contactNotes?: ContactNoteListRelationFilter
  }, "id" | "phone_userId">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    phone?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    userId?: SortOrder
    lastInteractionAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrderInput | SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    phone?: StringWithAggregatesFilter<"Contact"> | string
    name?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    company?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    tags?: StringNullableListFilter<"Contact">
    userId?: StringWithAggregatesFilter<"Contact"> | string
    lastInteractionAt?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    source?: StringNullableWithAggregatesFilter<"Contact"> | string | null
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    instanceName?: StringFilter<"Conversation"> | string
    contactPhone?: StringFilter<"Conversation"> | string
    contactName?: StringNullableFilter<"Conversation"> | string | null
    contactAvatar?: StringNullableFilter<"Conversation"> | string | null
    lastMessageAt?: DateTimeFilter<"Conversation"> | Date | string
    status?: StringFilter<"Conversation"> | string
    tags?: JsonFilter<"Conversation">
    isActive?: BoolFilter<"Conversation"> | boolean
    contactId?: StringNullableFilter<"Conversation"> | string | null
    userId?: StringFilter<"Conversation"> | string
    isGroup?: BoolFilter<"Conversation"> | boolean
    groupMetadata?: JsonNullableFilter<"Conversation">
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    messages?: MessageListRelationFilter
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    MessageReaction?: MessageReactionListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    contactPhone?: SortOrder
    contactName?: SortOrderInput | SortOrder
    contactAvatar?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    contactId?: SortOrderInput | SortOrder
    userId?: SortOrder
    isGroup?: SortOrder
    groupMetadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messages?: MessageOrderByRelationAggregateInput
    contact?: ContactOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    MessageReaction?: MessageReactionOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceName_contactPhone?: ConversationInstanceNameContactPhoneCompoundUniqueInput
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    instanceName?: StringFilter<"Conversation"> | string
    contactPhone?: StringFilter<"Conversation"> | string
    contactName?: StringNullableFilter<"Conversation"> | string | null
    contactAvatar?: StringNullableFilter<"Conversation"> | string | null
    lastMessageAt?: DateTimeFilter<"Conversation"> | Date | string
    status?: StringFilter<"Conversation"> | string
    tags?: JsonFilter<"Conversation">
    isActive?: BoolFilter<"Conversation"> | boolean
    contactId?: StringNullableFilter<"Conversation"> | string | null
    userId?: StringFilter<"Conversation"> | string
    isGroup?: BoolFilter<"Conversation"> | boolean
    groupMetadata?: JsonNullableFilter<"Conversation">
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    messages?: MessageListRelationFilter
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    MessageReaction?: MessageReactionListRelationFilter
  }, "id" | "instanceName_contactPhone">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    instanceName?: SortOrder
    contactPhone?: SortOrder
    contactName?: SortOrderInput | SortOrder
    contactAvatar?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    contactId?: SortOrderInput | SortOrder
    userId?: SortOrder
    isGroup?: SortOrder
    groupMetadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    instanceName?: StringWithAggregatesFilter<"Conversation"> | string
    contactPhone?: StringWithAggregatesFilter<"Conversation"> | string
    contactName?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    contactAvatar?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    lastMessageAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    status?: StringWithAggregatesFilter<"Conversation"> | string
    tags?: JsonWithAggregatesFilter<"Conversation">
    isActive?: BoolWithAggregatesFilter<"Conversation"> | boolean
    contactId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    userId?: StringWithAggregatesFilter<"Conversation"> | string
    isGroup?: BoolWithAggregatesFilter<"Conversation"> | boolean
    groupMetadata?: JsonNullableWithAggregatesFilter<"Conversation">
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    messageId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    sender?: StringFilter<"Message"> | string
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    timestamp?: DateTimeFilter<"Message"> | Date | string
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    mediaType?: StringNullableFilter<"Message"> | string | null
    replyTo?: JsonNullableFilter<"Message">
    userId?: StringFilter<"Message"> | string
    failureReason?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: MessageAttachmentListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    sender?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    replyTo?: SortOrderInput | SortOrder
    userId?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    attachments?: MessageAttachmentOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    sender?: StringFilter<"Message"> | string
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    timestamp?: DateTimeFilter<"Message"> | Date | string
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    mediaType?: StringNullableFilter<"Message"> | string | null
    replyTo?: JsonNullableFilter<"Message">
    userId?: StringFilter<"Message"> | string
    failureReason?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: MessageAttachmentListRelationFilter
  }, "id" | "messageId">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    sender?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    replyTo?: SortOrderInput | SortOrder
    userId?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    messageId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    type?: StringWithAggregatesFilter<"Message"> | string
    sender?: StringWithAggregatesFilter<"Message"> | string
    status?: EnumMessageStatusWithAggregatesFilter<"Message"> | $Enums.MessageStatus
    timestamp?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    mediaUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    mediaType?: StringNullableWithAggregatesFilter<"Message"> | string | null
    replyTo?: JsonNullableWithAggregatesFilter<"Message">
    userId?: StringWithAggregatesFilter<"Message"> | string
    failureReason?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type MessageAttachmentWhereInput = {
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    messageId?: StringFilter<"MessageAttachment"> | string
    type?: StringFilter<"MessageAttachment"> | string
    url?: StringFilter<"MessageAttachment"> | string
    name?: StringNullableFilter<"MessageAttachment"> | string | null
    mimeType?: StringNullableFilter<"MessageAttachment"> | string | null
    filename?: StringNullableFilter<"MessageAttachment"> | string | null
    size?: IntNullableFilter<"MessageAttachment"> | number | null
    createdAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }

  export type MessageAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type MessageAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    messageId?: StringFilter<"MessageAttachment"> | string
    type?: StringFilter<"MessageAttachment"> | string
    url?: StringFilter<"MessageAttachment"> | string
    name?: StringNullableFilter<"MessageAttachment"> | string | null
    mimeType?: StringNullableFilter<"MessageAttachment"> | string | null
    filename?: StringNullableFilter<"MessageAttachment"> | string | null
    size?: IntNullableFilter<"MessageAttachment"> | number | null
    createdAt?: DateTimeFilter<"MessageAttachment"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }, "id">

  export type MessageAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageAttachmentCountOrderByAggregateInput
    _avg?: MessageAttachmentAvgOrderByAggregateInput
    _max?: MessageAttachmentMaxOrderByAggregateInput
    _min?: MessageAttachmentMinOrderByAggregateInput
    _sum?: MessageAttachmentSumOrderByAggregateInput
  }

  export type MessageAttachmentScalarWhereWithAggregatesInput = {
    AND?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    OR?: MessageAttachmentScalarWhereWithAggregatesInput[]
    NOT?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageAttachment"> | string
    messageId?: StringWithAggregatesFilter<"MessageAttachment"> | string
    type?: StringWithAggregatesFilter<"MessageAttachment"> | string
    url?: StringWithAggregatesFilter<"MessageAttachment"> | string
    name?: StringNullableWithAggregatesFilter<"MessageAttachment"> | string | null
    mimeType?: StringNullableWithAggregatesFilter<"MessageAttachment"> | string | null
    filename?: StringNullableWithAggregatesFilter<"MessageAttachment"> | string | null
    size?: IntNullableWithAggregatesFilter<"MessageAttachment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MessageAttachment"> | Date | string
  }

  export type CampaignErrorLogWhereInput = {
    AND?: CampaignErrorLogWhereInput | CampaignErrorLogWhereInput[]
    OR?: CampaignErrorLogWhereInput[]
    NOT?: CampaignErrorLogWhereInput | CampaignErrorLogWhereInput[]
    id?: StringFilter<"CampaignErrorLog"> | string
    campaignId?: StringFilter<"CampaignErrorLog"> | string
    errorMessage?: StringFilter<"CampaignErrorLog"> | string
    errorDetails?: JsonNullableFilter<"CampaignErrorLog">
    createdAt?: DateTimeFilter<"CampaignErrorLog"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignErrorLogOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    errorMessage?: SortOrder
    errorDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignErrorLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignErrorLogWhereInput | CampaignErrorLogWhereInput[]
    OR?: CampaignErrorLogWhereInput[]
    NOT?: CampaignErrorLogWhereInput | CampaignErrorLogWhereInput[]
    campaignId?: StringFilter<"CampaignErrorLog"> | string
    errorMessage?: StringFilter<"CampaignErrorLog"> | string
    errorDetails?: JsonNullableFilter<"CampaignErrorLog">
    createdAt?: DateTimeFilter<"CampaignErrorLog"> | Date | string
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignErrorLogOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    errorMessage?: SortOrder
    errorDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CampaignErrorLogCountOrderByAggregateInput
    _max?: CampaignErrorLogMaxOrderByAggregateInput
    _min?: CampaignErrorLogMinOrderByAggregateInput
  }

  export type CampaignErrorLogScalarWhereWithAggregatesInput = {
    AND?: CampaignErrorLogScalarWhereWithAggregatesInput | CampaignErrorLogScalarWhereWithAggregatesInput[]
    OR?: CampaignErrorLogScalarWhereWithAggregatesInput[]
    NOT?: CampaignErrorLogScalarWhereWithAggregatesInput | CampaignErrorLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignErrorLog"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignErrorLog"> | string
    errorMessage?: StringWithAggregatesFilter<"CampaignErrorLog"> | string
    errorDetails?: JsonNullableWithAggregatesFilter<"CampaignErrorLog">
    createdAt?: DateTimeWithAggregatesFilter<"CampaignErrorLog"> | Date | string
  }

  export type ContactNoteWhereInput = {
    AND?: ContactNoteWhereInput | ContactNoteWhereInput[]
    OR?: ContactNoteWhereInput[]
    NOT?: ContactNoteWhereInput | ContactNoteWhereInput[]
    id?: StringFilter<"ContactNote"> | string
    contactId?: StringFilter<"ContactNote"> | string
    content?: StringFilter<"ContactNote"> | string
    createdAt?: DateTimeFilter<"ContactNote"> | Date | string
    updatedAt?: DateTimeFilter<"ContactNote"> | Date | string
    userId?: StringFilter<"ContactNote"> | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ContactNoteOrderByWithRelationInput = {
    id?: SortOrder
    contactId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    contact?: ContactOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ContactNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactNoteWhereInput | ContactNoteWhereInput[]
    OR?: ContactNoteWhereInput[]
    NOT?: ContactNoteWhereInput | ContactNoteWhereInput[]
    contactId?: StringFilter<"ContactNote"> | string
    content?: StringFilter<"ContactNote"> | string
    createdAt?: DateTimeFilter<"ContactNote"> | Date | string
    updatedAt?: DateTimeFilter<"ContactNote"> | Date | string
    userId?: StringFilter<"ContactNote"> | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ContactNoteOrderByWithAggregationInput = {
    id?: SortOrder
    contactId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: ContactNoteCountOrderByAggregateInput
    _max?: ContactNoteMaxOrderByAggregateInput
    _min?: ContactNoteMinOrderByAggregateInput
  }

  export type ContactNoteScalarWhereWithAggregatesInput = {
    AND?: ContactNoteScalarWhereWithAggregatesInput | ContactNoteScalarWhereWithAggregatesInput[]
    OR?: ContactNoteScalarWhereWithAggregatesInput[]
    NOT?: ContactNoteScalarWhereWithAggregatesInput | ContactNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactNote"> | string
    contactId?: StringWithAggregatesFilter<"ContactNote"> | string
    content?: StringWithAggregatesFilter<"ContactNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactNote"> | Date | string
    userId?: StringWithAggregatesFilter<"ContactNote"> | string
  }

  export type MessageReactionWhereInput = {
    AND?: MessageReactionWhereInput | MessageReactionWhereInput[]
    OR?: MessageReactionWhereInput[]
    NOT?: MessageReactionWhereInput | MessageReactionWhereInput[]
    id?: StringFilter<"MessageReaction"> | string
    messageId?: StringFilter<"MessageReaction"> | string
    conversationId?: StringFilter<"MessageReaction"> | string
    reaction?: StringFilter<"MessageReaction"> | string
    userId?: StringFilter<"MessageReaction"> | string
    createdAt?: DateTimeFilter<"MessageReaction"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type MessageReactionOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    conversationId?: SortOrder
    reaction?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type MessageReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageReactionWhereInput | MessageReactionWhereInput[]
    OR?: MessageReactionWhereInput[]
    NOT?: MessageReactionWhereInput | MessageReactionWhereInput[]
    messageId?: StringFilter<"MessageReaction"> | string
    conversationId?: StringFilter<"MessageReaction"> | string
    reaction?: StringFilter<"MessageReaction"> | string
    userId?: StringFilter<"MessageReaction"> | string
    createdAt?: DateTimeFilter<"MessageReaction"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id">

  export type MessageReactionOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    conversationId?: SortOrder
    reaction?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: MessageReactionCountOrderByAggregateInput
    _max?: MessageReactionMaxOrderByAggregateInput
    _min?: MessageReactionMinOrderByAggregateInput
  }

  export type MessageReactionScalarWhereWithAggregatesInput = {
    AND?: MessageReactionScalarWhereWithAggregatesInput | MessageReactionScalarWhereWithAggregatesInput[]
    OR?: MessageReactionScalarWhereWithAggregatesInput[]
    NOT?: MessageReactionScalarWhereWithAggregatesInput | MessageReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageReaction"> | string
    messageId?: StringWithAggregatesFilter<"MessageReaction"> | string
    conversationId?: StringWithAggregatesFilter<"MessageReaction"> | string
    reaction?: StringWithAggregatesFilter<"MessageReaction"> | string
    userId?: StringWithAggregatesFilter<"MessageReaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MessageReaction"> | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    WhatleadUser?: UserCreateNestedManyWithoutCompanyInput
    whatleadparceiroconfigs?: CompaniesUnitesCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    WhatleadUser?: UserUncheckedCreateNestedManyWithoutCompanyInput
    whatleadparceiroconfigs?: CompaniesUnitesUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WhatleadUser?: UserUpdateManyWithoutCompanyNestedInput
    whatleadparceiroconfigs?: CompaniesUnitesUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WhatleadUser?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    whatleadparceiroconfigs?: CompaniesUnitesUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutUserInput
    affiliate?: UserCreateNestedOneWithoutAffiliatesInput
    affiliates?: UserCreateNestedManyWithoutAffiliateInput
    Message?: MessageCreateNestedManyWithoutUserInput
    Conversation?: ConversationCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutUserInput
    affiliates?: UserUncheckedCreateNestedManyWithoutAffiliateInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    Conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutUserNestedInput
    affiliate?: UserUpdateOneWithoutAffiliatesNestedInput
    affiliates?: UserUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutUserNestedInput
    affiliates?: UserUncheckedUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesUnitesCreateInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    leads?: LeadCreateNestedManyWithoutConfigInput
    company?: CompanyCreateNestedOneWithoutWhatleadparceiroconfigsInput
  }

  export type CompaniesUnitesUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    whatleadCompanyId?: string | null
    leads?: LeadUncheckedCreateNestedManyWithoutConfigInput
  }

  export type CompaniesUnitesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    leads?: LeadUpdateManyWithoutConfigNestedInput
    company?: CompanyUpdateOneWithoutWhatleadparceiroconfigsNestedInput
  }

  export type CompaniesUnitesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    whatleadCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    leads?: LeadUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type CompaniesUnitesCreateManyInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    whatleadCompanyId?: string | null
  }

  export type CompaniesUnitesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesUnitesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    whatleadCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadCreateInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string
    updatedat?: Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutLeadInput
    config: CompaniesUnitesCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    configid: string
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string
    updatedat?: Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: DateTimeFieldUpdateOperationsInput | Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutLeadNestedInput
    config?: CompaniesUnitesUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    configid?: StringFieldUpdateOperationsInput | string
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: DateTimeFieldUpdateOperationsInput | Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    configid: string
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string
    updatedat?: Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: DateTimeFieldUpdateOperationsInput | Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    configid?: StringFieldUpdateOperationsInput | string
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: DateTimeFieldUpdateOperationsInput | Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    dueDate: Date | string
    customerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: string | null
    disputeReason?: string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    dueDate: Date | string
    customerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: string | null
    disputeReason?: string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    dueDate: Date | string
    customerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: string | null
    disputeReason?: string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstanceCreateInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutInstancesInput
    campaigns?: CampaignCreateNestedManyWithoutInstanceInput
    campaignSchedules?: CampaignScheduleCreateNestedManyWithoutInstanceInput
    campaignDispatches?: CampaignDispatchCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutInstanceInput
    mediaStats?: MediaStatsCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedCreateNestedManyWithoutInstanceInput
    campaignSchedules?: CampaignScheduleUncheckedCreateNestedManyWithoutInstanceInput
    campaignDispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutInstanceInput
    mediaStats?: MediaStatsUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutInstancesNestedInput
    campaigns?: CampaignUpdateManyWithoutInstanceNestedInput
    campaignSchedules?: CampaignScheduleUpdateManyWithoutInstanceNestedInput
    campaignDispatches?: CampaignDispatchUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutInstanceNestedInput
    mediaStats?: MediaStatsUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedUpdateManyWithoutInstanceNestedInput
    campaignSchedules?: CampaignScheduleUncheckedUpdateManyWithoutInstanceNestedInput
    campaignDispatches?: CampaignDispatchUncheckedUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutInstanceNestedInput
    mediaStats?: MediaStatsUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceCreateManyInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InstanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InstanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MediaStatsCreateInput = {
    id?: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutMediaStatsInput
    warmupStatsReceived?: WarmupStatsCreateNestedManyWithoutMediaReceivedInput
    warmupStatsSent?: WarmupStatsCreateNestedManyWithoutMediaStatsInput
  }

  export type MediaStatsUncheckedCreateInput = {
    id?: string
    instanceName: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warmupStatsReceived?: WarmupStatsUncheckedCreateNestedManyWithoutMediaReceivedInput
    warmupStatsSent?: WarmupStatsUncheckedCreateNestedManyWithoutMediaStatsInput
  }

  export type MediaStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutMediaStatsNestedInput
    warmupStatsReceived?: WarmupStatsUpdateManyWithoutMediaReceivedNestedInput
    warmupStatsSent?: WarmupStatsUpdateManyWithoutMediaStatsNestedInput
  }

  export type MediaStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warmupStatsReceived?: WarmupStatsUncheckedUpdateManyWithoutMediaReceivedNestedInput
    warmupStatsSent?: WarmupStatsUncheckedUpdateManyWithoutMediaStatsNestedInput
  }

  export type MediaStatsCreateManyInput = {
    id?: string
    instanceName: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarmupStatsCreateInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutWarmupStatsInput
    mediaReceived?: MediaStatsCreateNestedOneWithoutWarmupStatsReceivedInput
    mediaStats?: MediaStatsCreateNestedOneWithoutWarmupStatsSentInput
    user: UserCreateNestedOneWithoutWarmupStatsInput
  }

  export type WarmupStatsUncheckedCreateInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
    mediaReceivedId?: string | null
  }

  export type WarmupStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutWarmupStatsNestedInput
    mediaReceived?: MediaStatsUpdateOneWithoutWarmupStatsReceivedNestedInput
    mediaStats?: MediaStatsUpdateOneWithoutWarmupStatsSentNestedInput
    user?: UserUpdateOneRequiredWithoutWarmupStatsNestedInput
  }

  export type WarmupStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarmupStatsCreateManyInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
    mediaReceivedId?: string | null
  }

  export type WarmupStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarmupStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchCreateNestedManyWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
    instance?: InstanceCreateNestedOneWithoutCampaignsInput
    CampaignErrorLog?: CampaignErrorLogCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsCreateNestedManyWithoutCampaignInput
    contacts?: ContactCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutCampaignInput
    CampaignErrorLog?: CampaignErrorLogUncheckedCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleUncheckedCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsUncheckedCreateNestedManyWithoutCampaignInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUpdateManyWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
    instance?: InstanceUpdateOneWithoutCampaignsNestedInput
    CampaignErrorLog?: CampaignErrorLogUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignErrorLog?: CampaignErrorLogUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUncheckedUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUncheckedUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignDispatchCreateInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutDispatchesInput
    instance: InstanceCreateNestedOneWithoutCampaignDispatchesInput
  }

  export type CampaignDispatchUncheckedCreateInput = {
    id?: string
    campaignId: string
    instanceName: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignDispatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutDispatchesNestedInput
    instance?: InstanceUpdateOneRequiredWithoutCampaignDispatchesNestedInput
  }

  export type CampaignDispatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignDispatchCreateManyInput = {
    id?: string
    campaignId: string
    instanceName: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignDispatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignDispatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMessageCreateInput = {
    id?: string
    type: string
    content: string
    order: number
    caption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMessagesInput
  }

  export type CampaignMessageUncheckedCreateInput = {
    id?: string
    campaignId: string
    type: string
    content: string
    order: number
    caption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type CampaignMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMessageCreateManyInput = {
    id?: string
    campaignId: string
    type: string
    content: string
    order: number
    caption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLeadCreateInput = {
    id?: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    segment?: string | null
    engagement?: string | null
    syncedWithCRM?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignLeadInput
    messageLogs?: MessageLogCreateNestedManyWithoutCampaignLeadInput
    campaign: CampaignCreateNestedOneWithoutLeadsInput
  }

  export type CampaignLeadUncheckedCreateInput = {
    id?: string
    userId: string
    campaignId: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    segment?: string | null
    engagement?: string | null
    syncedWithCRM?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messageLogs?: MessageLogUncheckedCreateNestedManyWithoutCampaignLeadInput
  }

  export type CampaignLeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: NullableStringFieldUpdateOperationsInput | string | null
    syncedWithCRM?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignLeadNestedInput
    messageLogs?: MessageLogUpdateManyWithoutCampaignLeadNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type CampaignLeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: NullableStringFieldUpdateOperationsInput | string | null
    syncedWithCRM?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageLogs?: MessageLogUncheckedUpdateManyWithoutCampaignLeadNestedInput
  }

  export type CampaignLeadCreateManyInput = {
    id?: string
    userId: string
    campaignId: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    segment?: string | null
    engagement?: string | null
    syncedWithCRM?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignLeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: NullableStringFieldUpdateOperationsInput | string | null
    syncedWithCRM?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: NullableStringFieldUpdateOperationsInput | string | null
    syncedWithCRM?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignScheduleCreateInput = {
    id?: string
    scheduledDate: Date | string
    status?: string
    message?: string | null
    mediaType?: string | null
    mediaUrl?: string | null
    mediaCaption?: string | null
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutCampaignScheduleInput
    instance: InstanceCreateNestedOneWithoutCampaignSchedulesInput
  }

  export type CampaignScheduleUncheckedCreateInput = {
    id?: string
    campaignId: string
    instanceName: string
    scheduledDate: Date | string
    status?: string
    message?: string | null
    mediaType?: string | null
    mediaUrl?: string | null
    mediaCaption?: string | null
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type CampaignScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutCampaignScheduleNestedInput
    instance?: InstanceUpdateOneRequiredWithoutCampaignSchedulesNestedInput
  }

  export type CampaignScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignScheduleCreateManyInput = {
    id?: string
    campaignId: string
    instanceName: string
    scheduledDate: Date | string
    status?: string
    message?: string | null
    mediaType?: string | null
    mediaUrl?: string | null
    mediaCaption?: string | null
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type CampaignScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignStatisticsCreateInput = {
    id?: string
    totalLeads?: number
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutStatisticsInput
  }

  export type CampaignStatisticsUncheckedCreateInput = {
    id?: string
    campaignId: string
    totalLeads?: number
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignStatisticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutStatisticsNestedInput
  }

  export type CampaignStatisticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignStatisticsCreateManyInput = {
    id?: string
    campaignId: string
    totalLeads?: number
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignStatisticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignStatisticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLogCreateInput = {
    id?: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMessageLogInput
    campaignLead: CampaignLeadCreateNestedOneWithoutMessageLogsInput
    lead?: LeadCreateNestedOneWithoutMessageLogInput
  }

  export type MessageLogUncheckedCreateInput = {
    id?: string
    campaignId: string
    campaignLeadId: string
    leadId?: string | null
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMessageLogNestedInput
    campaignLead?: CampaignLeadUpdateOneRequiredWithoutMessageLogsNestedInput
    lead?: LeadUpdateOneWithoutMessageLogNestedInput
  }

  export type MessageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignLeadId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLogCreateManyInput = {
    id?: string
    campaignId: string
    campaignLeadId: string
    leadId?: string | null
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignLeadId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAnalyticsCreateInput = {
    id?: string
    date: Date | string
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    respondedCount?: number
    failedCount?: number
    campaign: CampaignCreateNestedOneWithoutMessageAnalyticsInput
  }

  export type MessageAnalyticsUncheckedCreateInput = {
    id?: string
    campaignId: string
    date: Date | string
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    respondedCount?: number
    failedCount?: number
  }

  export type MessageAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    respondedCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    campaign?: CampaignUpdateOneRequiredWithoutMessageAnalyticsNestedInput
  }

  export type MessageAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    respondedCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
  }

  export type MessageAnalyticsCreateManyInput = {
    id?: string
    campaignId: string
    date: Date | string
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    respondedCount?: number
    failedCount?: number
  }

  export type MessageAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    respondedCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
  }

  export type MessageAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    respondedCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
  }

  export type ContactCreateInput = {
    id?: string
    phone: string
    name?: string | null
    email?: string | null
    company?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    lastInteractionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    source?: string | null
    user: UserCreateNestedOneWithoutContactsInput
    campaigns?: CampaignCreateNestedManyWithoutContactsInput
    conversations?: ConversationCreateNestedManyWithoutContactInput
    contactNotes?: ContactNoteCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    phone: string
    name?: string | null
    email?: string | null
    company?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    userId: string
    lastInteractionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    source?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutContactsInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
    campaigns?: CampaignUpdateManyWithoutContactsNestedInput
    conversations?: ConversationUpdateManyWithoutContactNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutContactsNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    phone: string
    name?: string | null
    email?: string | null
    company?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    userId: string
    lastInteractionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    source?: string | null
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationCreateInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    contact?: ContactCreateNestedOneWithoutConversationsInput
    user: UserCreateNestedOneWithoutConversationInput
    MessageReaction?: MessageReactionCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    contactId?: string | null
    userId: string
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    MessageReaction?: MessageReactionUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    contact?: ContactUpdateOneWithoutConversationsNestedInput
    user?: UserUpdateOneRequiredWithoutConversationNestedInput
    MessageReaction?: MessageReactionUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    MessageReaction?: MessageReactionUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    contactId?: string | null
    userId: string
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    messageId: string
    content: string
    type?: string
    sender: string
    status?: $Enums.MessageStatus
    timestamp: Date | string
    mediaUrl?: string | null
    mediaType?: string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    messageId: string
    content: string
    type?: string
    sender: string
    status?: $Enums.MessageStatus
    timestamp: Date | string
    mediaUrl?: string | null
    mediaType?: string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    failureReason?: string | null
    createdAt?: Date | string
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    messageId: string
    content: string
    type?: string
    sender: string
    status?: $Enums.MessageStatus
    timestamp: Date | string
    mediaUrl?: string | null
    mediaType?: string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateInput = {
    id?: string
    type: string
    url: string
    name?: string | null
    mimeType?: string | null
    filename?: string | null
    size?: number | null
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutAttachmentsInput
  }

  export type MessageAttachmentUncheckedCreateInput = {
    id?: string
    messageId: string
    type: string
    url: string
    name?: string | null
    mimeType?: string | null
    filename?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type MessageAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type MessageAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateManyInput = {
    id?: string
    messageId: string
    type: string
    url: string
    name?: string | null
    mimeType?: string | null
    filename?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type MessageAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignErrorLogCreateInput = {
    id?: string
    errorMessage: string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutCampaignErrorLogInput
  }

  export type CampaignErrorLogUncheckedCreateInput = {
    id?: string
    campaignId: string
    errorMessage: string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignErrorLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutCampaignErrorLogNestedInput
  }

  export type CampaignErrorLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignErrorLogCreateManyInput = {
    id?: string
    campaignId: string
    errorMessage: string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignErrorLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignErrorLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutContactNotesInput
    user: UserCreateNestedOneWithoutContactNotesInput
  }

  export type ContactNoteUncheckedCreateInput = {
    id?: string
    contactId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ContactNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutContactNotesNestedInput
    user?: UserUpdateOneRequiredWithoutContactNotesNestedInput
  }

  export type ContactNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactNoteCreateManyInput = {
    id?: string
    contactId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ContactNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageReactionCreateInput = {
    id?: string
    messageId: string
    reaction: string
    userId: string
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessageReactionInput
  }

  export type MessageReactionUncheckedCreateInput = {
    id?: string
    messageId: string
    conversationId: string
    reaction: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessageReactionNestedInput
  }

  export type MessageReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionCreateManyInput = {
    id?: string
    messageId: string
    conversationId: string
    reaction: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type CompaniesUnitesListRelationFilter = {
    every?: CompaniesUnitesWhereInput
    some?: CompaniesUnitesWhereInput
    none?: CompaniesUnitesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompaniesUnitesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type InstanceListRelationFilter = {
    every?: InstanceWhereInput
    some?: InstanceWhereInput
    none?: InstanceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type WarmupStatsListRelationFilter = {
    every?: WarmupStatsWhereInput
    some?: WarmupStatsWhereInput
    none?: WarmupStatsWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type CampaignLeadListRelationFilter = {
    every?: CampaignLeadWhereInput
    some?: CampaignLeadWhereInput
    none?: CampaignLeadWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type ContactNoteListRelationFilter = {
    every?: ContactNoteWhereInput
    some?: ContactNoteWhereInput
    none?: ContactNoteWhereInput
  }

  export type InstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarmupStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignLeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    profile?: SortOrder
    phone?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeSubscriptionStatus?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatleadCompanyId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
    features?: SortOrder
    support?: SortOrder
    trialEndDate?: SortOrder
    referredBy?: SortOrder
    role?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    profile?: SortOrder
    phone?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeSubscriptionStatus?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatleadCompanyId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
    support?: SortOrder
    trialEndDate?: SortOrder
    referredBy?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    profile?: SortOrder
    phone?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeSubscriptionStatus?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatleadCompanyId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
    support?: SortOrder
    trialEndDate?: SortOrder
    referredBy?: SortOrder
    role?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    maxInstances?: SortOrder
    messagesPerDay?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableListFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompaniesUnitesCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    productdefault?: SortOrder
    campaignstatus?: SortOrder
    enablecuration?: SortOrder
    enabletosendustolead?: SortOrder
    enabled?: SortOrder
    isconversationia?: SortOrder
    campaignnumberbusiness?: SortOrder
    whatsappprovider?: SortOrder
    enabletosendprovider?: SortOrder
    enabletosecondcallprovider?: SortOrder
    integrationconfiguration?: SortOrder
    integrationname?: SortOrder
    templatelistvars?: SortOrder
    metaconfiguration?: SortOrder
    messageperruns?: SortOrder
    notifyconfiguration?: SortOrder
    updatedAt?: SortOrder
    whitelabel_config?: SortOrder
    whatleadCompanyId?: SortOrder
  }

  export type CompaniesUnitesMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    productdefault?: SortOrder
    campaignstatus?: SortOrder
    enablecuration?: SortOrder
    enabletosendustolead?: SortOrder
    enabled?: SortOrder
    isconversationia?: SortOrder
    campaignnumberbusiness?: SortOrder
    whatsappprovider?: SortOrder
    enabletosendprovider?: SortOrder
    enabletosecondcallprovider?: SortOrder
    integrationname?: SortOrder
    updatedAt?: SortOrder
    whitelabel_config?: SortOrder
    whatleadCompanyId?: SortOrder
  }

  export type CompaniesUnitesMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    productdefault?: SortOrder
    campaignstatus?: SortOrder
    enablecuration?: SortOrder
    enabletosendustolead?: SortOrder
    enabled?: SortOrder
    isconversationia?: SortOrder
    campaignnumberbusiness?: SortOrder
    whatsappprovider?: SortOrder
    enabletosendprovider?: SortOrder
    enabletosecondcallprovider?: SortOrder
    integrationname?: SortOrder
    updatedAt?: SortOrder
    whitelabel_config?: SortOrder
    whatleadCompanyId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MessageLogListRelationFilter = {
    every?: MessageLogWhereInput
    some?: MessageLogWhereInput
    none?: MessageLogWhereInput
  }

  export type CompaniesUnitesScalarRelationFilter = {
    is?: CompaniesUnitesWhereInput
    isNot?: CompaniesUnitesWhereInput
  }

  export type MessageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    externalid?: SortOrder
    sourceid?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    lastmessagesent?: SortOrder
    stepsecondcalltemplate?: SortOrder
    stepnointeraction?: SortOrder
    nointeractionquantity?: SortOrder
    accepttemplate?: SortOrder
    acceptsecondtemplate?: SortOrder
    status?: SortOrder
    dialog?: SortOrder
    configid?: SortOrder
    whitelabelconfig?: SortOrder
    lastintent?: SortOrder
    broker?: SortOrder
    origin?: SortOrder
    send?: SortOrder
    sendAt?: SortOrder
    isBusinessAutoResponder?: SortOrder
    startmessage?: SortOrder
    schedulingdata?: SortOrder
    productchoosebyclient?: SortOrder
    productid?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
    curation?: SortOrder
  }

  export type LeadAvgOrderByAggregateInput = {
    stepsecondcalltemplate?: SortOrder
    stepnointeraction?: SortOrder
    nointeractionquantity?: SortOrder
    productid?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    externalid?: SortOrder
    sourceid?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    lastmessagesent?: SortOrder
    stepsecondcalltemplate?: SortOrder
    stepnointeraction?: SortOrder
    nointeractionquantity?: SortOrder
    accepttemplate?: SortOrder
    acceptsecondtemplate?: SortOrder
    status?: SortOrder
    configid?: SortOrder
    whitelabelconfig?: SortOrder
    lastintent?: SortOrder
    broker?: SortOrder
    origin?: SortOrder
    send?: SortOrder
    sendAt?: SortOrder
    isBusinessAutoResponder?: SortOrder
    startmessage?: SortOrder
    schedulingdata?: SortOrder
    productchoosebyclient?: SortOrder
    productid?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    externalid?: SortOrder
    sourceid?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    lastmessagesent?: SortOrder
    stepsecondcalltemplate?: SortOrder
    stepnointeraction?: SortOrder
    nointeractionquantity?: SortOrder
    accepttemplate?: SortOrder
    acceptsecondtemplate?: SortOrder
    status?: SortOrder
    configid?: SortOrder
    whitelabelconfig?: SortOrder
    lastintent?: SortOrder
    broker?: SortOrder
    origin?: SortOrder
    send?: SortOrder
    sendAt?: SortOrder
    isBusinessAutoResponder?: SortOrder
    startmessage?: SortOrder
    schedulingdata?: SortOrder
    productchoosebyclient?: SortOrder
    productid?: SortOrder
    createdat?: SortOrder
    updatedat?: SortOrder
  }

  export type LeadSumOrderByAggregateInput = {
    stepsecondcalltemplate?: SortOrder
    stepnointeraction?: SortOrder
    nointeractionquantity?: SortOrder
    productid?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    customerId?: SortOrder
    metadata?: SortOrder
    disputeStatus?: SortOrder
    disputeReason?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    customerId?: SortOrder
    disputeStatus?: SortOrder
    disputeReason?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    stripePaymentId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    customerId?: SortOrder
    disputeStatus?: SortOrder
    disputeReason?: SortOrder
    cancelReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumInstanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstanceStatus | EnumInstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstanceStatus[] | ListEnumInstanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstanceStatus[] | ListEnumInstanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstanceStatusFilter<$PrismaModel> | $Enums.InstanceStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CampaignScheduleListRelationFilter = {
    every?: CampaignScheduleWhereInput
    some?: CampaignScheduleWhereInput
    none?: CampaignScheduleWhereInput
  }

  export type CampaignDispatchListRelationFilter = {
    every?: CampaignDispatchWhereInput
    some?: CampaignDispatchWhereInput
    none?: CampaignDispatchWhereInput
  }

  export type MediaStatsListRelationFilter = {
    every?: MediaStatsWhereInput
    some?: MediaStatsWhereInput
    none?: MediaStatsWhereInput
  }

  export type CampaignScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignDispatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstanceCountOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    connectionStatus?: SortOrder
    number?: SortOrder
    ownerJid?: SortOrder
    profilePicUrl?: SortOrder
    integration?: SortOrder
    token?: SortOrder
    clientName?: SortOrder
    profileName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disconnectedAt?: SortOrder
    disconnectionObject?: SortOrder
    disconnectionReasonCode?: SortOrder
    proxyConfig?: SortOrder
    typebot?: SortOrder
  }

  export type InstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    connectionStatus?: SortOrder
    number?: SortOrder
    ownerJid?: SortOrder
    profilePicUrl?: SortOrder
    integration?: SortOrder
    token?: SortOrder
    clientName?: SortOrder
    profileName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disconnectedAt?: SortOrder
    disconnectionReasonCode?: SortOrder
  }

  export type InstanceMinOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    connectionStatus?: SortOrder
    number?: SortOrder
    ownerJid?: SortOrder
    profilePicUrl?: SortOrder
    integration?: SortOrder
    token?: SortOrder
    clientName?: SortOrder
    profileName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disconnectedAt?: SortOrder
    disconnectionReasonCode?: SortOrder
  }

  export type EnumInstanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstanceStatus | EnumInstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstanceStatus[] | ListEnumInstanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstanceStatus[] | ListEnumInstanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstanceStatusFilter<$PrismaModel>
    _max?: NestedEnumInstanceStatusFilter<$PrismaModel>
  }

  export type InstanceScalarRelationFilter = {
    is?: InstanceWhereInput
    isNot?: InstanceWhereInput
  }

  export type MediaStatsCountOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    date?: SortOrder
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    isReceived?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaStatsAvgOrderByAggregateInput = {
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
  }

  export type MediaStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    date?: SortOrder
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    isReceived?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaStatsMinOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    date?: SortOrder
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    isReceived?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaStatsSumOrderByAggregateInput = {
    text?: SortOrder
    image?: SortOrder
    video?: SortOrder
    audio?: SortOrder
    sticker?: SortOrder
    reaction?: SortOrder
    totalDaily?: SortOrder
    totalAllTime?: SortOrder
    totalSent?: SortOrder
    totalReceived?: SortOrder
  }

  export type MediaStatsNullableScalarRelationFilter = {
    is?: MediaStatsWhereInput | null
    isNot?: MediaStatsWhereInput | null
  }

  export type WarmupStatsCountOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    lastActive?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrder
    progress?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaStatsId?: SortOrder
    mediaReceivedId?: SortOrder
  }

  export type WarmupStatsAvgOrderByAggregateInput = {
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    progress?: SortOrder
  }

  export type WarmupStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    lastActive?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrder
    progress?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaStatsId?: SortOrder
    mediaReceivedId?: SortOrder
  }

  export type WarmupStatsMinOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    lastActive?: SortOrder
    startTime?: SortOrder
    pauseTime?: SortOrder
    progress?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaStatsId?: SortOrder
    mediaReceivedId?: SortOrder
  }

  export type WarmupStatsSumOrderByAggregateInput = {
    messagesSent?: SortOrder
    messagesReceived?: SortOrder
    warmupTime?: SortOrder
    progress?: SortOrder
  }

  export type CampaignMessageListRelationFilter = {
    every?: CampaignMessageWhereInput
    some?: CampaignMessageWhereInput
    none?: CampaignMessageWhereInput
  }

  export type CampaignStatisticsNullableScalarRelationFilter = {
    is?: CampaignStatisticsWhereInput | null
    isNot?: CampaignStatisticsWhereInput | null
  }

  export type InstanceNullableScalarRelationFilter = {
    is?: InstanceWhereInput | null
    isNot?: InstanceWhereInput | null
  }

  export type CampaignErrorLogListRelationFilter = {
    every?: CampaignErrorLogWhereInput
    some?: CampaignErrorLogWhereInput
    none?: CampaignErrorLogWhereInput
  }

  export type MessageAnalyticsListRelationFilter = {
    every?: MessageAnalyticsWhereInput
    some?: MessageAnalyticsWhereInput
    none?: MessageAnalyticsWhereInput
  }

  export type CampaignMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignErrorLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    mediaCaption?: SortOrder
    scheduledDate?: SortOrder
    scheduledStatus?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    pausedAt?: SortOrder
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    userId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isAiResponder?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    mediaCaption?: SortOrder
    scheduledDate?: SortOrder
    scheduledStatus?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    pausedAt?: SortOrder
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    userId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    type?: SortOrder
    message?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    mediaCaption?: SortOrder
    scheduledDate?: SortOrder
    scheduledStatus?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    pausedAt?: SortOrder
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    userId?: SortOrder
    instanceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    progress?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
  }

  export type CampaignScalarRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignDispatchCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignDispatchMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignDispatchMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    instanceName?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMessageCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMessageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CampaignMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMessageMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    order?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMessageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CampaignLeadUnique_campaign_phoneCompoundUniqueInput = {
    campaignId: string
    phone: string
  }

  export type CampaignLeadCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    messageId?: SortOrder
    segment?: SortOrder
    engagement?: SortOrder
    syncedWithCRM?: SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignLeadMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    messageId?: SortOrder
    segment?: SortOrder
    engagement?: SortOrder
    syncedWithCRM?: SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignLeadMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    messageId?: SortOrder
    segment?: SortOrder
    engagement?: SortOrder
    syncedWithCRM?: SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    instanceName?: SortOrder
    scheduledDate?: SortOrder
    status?: SortOrder
    message?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    mediaCaption?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CampaignScheduleAvgOrderByAggregateInput = {
    minDelay?: SortOrder
    maxDelay?: SortOrder
  }

  export type CampaignScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    instanceName?: SortOrder
    scheduledDate?: SortOrder
    status?: SortOrder
    message?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    mediaCaption?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CampaignScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    instanceName?: SortOrder
    scheduledDate?: SortOrder
    status?: SortOrder
    message?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    mediaCaption?: SortOrder
    minDelay?: SortOrder
    maxDelay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CampaignScheduleSumOrderByAggregateInput = {
    minDelay?: SortOrder
    maxDelay?: SortOrder
  }

  export type CampaignStatisticsCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignStatisticsAvgOrderByAggregateInput = {
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
  }

  export type CampaignStatisticsMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignStatisticsMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignStatisticsSumOrderByAggregateInput = {
    totalLeads?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    failedCount?: SortOrder
  }

  export type CampaignLeadScalarRelationFilter = {
    is?: CampaignLeadWhereInput
    isNot?: CampaignLeadWhereInput
  }

  export type LeadNullableScalarRelationFilter = {
    is?: LeadWhereInput | null
    isNot?: LeadWhereInput | null
  }

  export type MessageLogMessageIdMessageDateCompoundUniqueInput = {
    messageId: string
    messageDate: Date | string
  }

  export type MessageLogCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    campaignLeadId?: SortOrder
    leadId?: SortOrder
    messageId?: SortOrder
    messageDate?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    status?: SortOrder
    statusHistory?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    campaignLeadId?: SortOrder
    leadId?: SortOrder
    messageId?: SortOrder
    messageDate?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageLogMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    campaignLeadId?: SortOrder
    leadId?: SortOrder
    messageId?: SortOrder
    messageDate?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    deliveredAt?: SortOrder
    readAt?: SortOrder
    failedAt?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageAnalyticsCampaignIdDateCompoundUniqueInput = {
    campaignId: string
    date: Date | string
  }

  export type MessageAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    respondedCount?: SortOrder
    failedCount?: SortOrder
  }

  export type MessageAnalyticsAvgOrderByAggregateInput = {
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    respondedCount?: SortOrder
    failedCount?: SortOrder
  }

  export type MessageAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    respondedCount?: SortOrder
    failedCount?: SortOrder
  }

  export type MessageAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    respondedCount?: SortOrder
    failedCount?: SortOrder
  }

  export type MessageAnalyticsSumOrderByAggregateInput = {
    sentCount?: SortOrder
    deliveredCount?: SortOrder
    readCount?: SortOrder
    respondedCount?: SortOrder
    failedCount?: SortOrder
  }

  export type ContactPhoneUserIdCompoundUniqueInput = {
    phone: string
    userId: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    email?: SortOrder
    company?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    userId?: SortOrder
    lastInteractionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    email?: SortOrder
    company?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    lastInteractionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    name?: SortOrder
    email?: SortOrder
    company?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    lastInteractionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type MessageReactionListRelationFilter = {
    every?: MessageReactionWhereInput
    some?: MessageReactionWhereInput
    none?: MessageReactionWhereInput
  }

  export type MessageReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationInstanceNameContactPhoneCompoundUniqueInput = {
    instanceName: string
    contactPhone: string
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    contactPhone?: SortOrder
    contactName?: SortOrder
    contactAvatar?: SortOrder
    lastMessageAt?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    contactId?: SortOrder
    userId?: SortOrder
    isGroup?: SortOrder
    groupMetadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    contactPhone?: SortOrder
    contactName?: SortOrder
    contactAvatar?: SortOrder
    lastMessageAt?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    contactId?: SortOrder
    userId?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    instanceName?: SortOrder
    contactPhone?: SortOrder
    contactName?: SortOrder
    contactAvatar?: SortOrder
    lastMessageAt?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    contactId?: SortOrder
    userId?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageAttachmentListRelationFilter = {
    every?: MessageAttachmentWhereInput
    some?: MessageAttachmentWhereInput
    none?: MessageAttachmentWhereInput
  }

  export type MessageAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    sender?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    replyTo?: SortOrder
    userId?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    sender?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    userId?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    sender?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    userId?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrder
    mimeType?: SortOrder
    filename?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAttachmentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type MessageAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrder
    mimeType?: SortOrder
    filename?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    name?: SortOrder
    mimeType?: SortOrder
    filename?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageAttachmentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type CampaignErrorLogCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    errorMessage?: SortOrder
    errorDetails?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignErrorLogMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignErrorLogMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type ContactNoteCountOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ContactNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ContactNoteMinOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type MessageReactionCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    conversationId?: SortOrder
    reaction?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    conversationId?: SortOrder
    reaction?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageReactionMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    conversationId?: SortOrder
    reaction?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CompaniesUnitesCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompaniesUnitesCreateWithoutCompanyInput, CompaniesUnitesUncheckedCreateWithoutCompanyInput> | CompaniesUnitesCreateWithoutCompanyInput[] | CompaniesUnitesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompaniesUnitesCreateOrConnectWithoutCompanyInput | CompaniesUnitesCreateOrConnectWithoutCompanyInput[]
    createMany?: CompaniesUnitesCreateManyCompanyInputEnvelope
    connect?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CompaniesUnitesUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompaniesUnitesCreateWithoutCompanyInput, CompaniesUnitesUncheckedCreateWithoutCompanyInput> | CompaniesUnitesCreateWithoutCompanyInput[] | CompaniesUnitesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompaniesUnitesCreateOrConnectWithoutCompanyInput | CompaniesUnitesCreateOrConnectWithoutCompanyInput[]
    createMany?: CompaniesUnitesCreateManyCompanyInputEnvelope
    connect?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CompaniesUnitesUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompaniesUnitesCreateWithoutCompanyInput, CompaniesUnitesUncheckedCreateWithoutCompanyInput> | CompaniesUnitesCreateWithoutCompanyInput[] | CompaniesUnitesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompaniesUnitesCreateOrConnectWithoutCompanyInput | CompaniesUnitesCreateOrConnectWithoutCompanyInput[]
    upsert?: CompaniesUnitesUpsertWithWhereUniqueWithoutCompanyInput | CompaniesUnitesUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompaniesUnitesCreateManyCompanyInputEnvelope
    set?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    disconnect?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    delete?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    connect?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    update?: CompaniesUnitesUpdateWithWhereUniqueWithoutCompanyInput | CompaniesUnitesUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompaniesUnitesUpdateManyWithWhereWithoutCompanyInput | CompaniesUnitesUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompaniesUnitesScalarWhereInput | CompaniesUnitesScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CompaniesUnitesUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompaniesUnitesCreateWithoutCompanyInput, CompaniesUnitesUncheckedCreateWithoutCompanyInput> | CompaniesUnitesCreateWithoutCompanyInput[] | CompaniesUnitesUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompaniesUnitesCreateOrConnectWithoutCompanyInput | CompaniesUnitesCreateOrConnectWithoutCompanyInput[]
    upsert?: CompaniesUnitesUpsertWithWhereUniqueWithoutCompanyInput | CompaniesUnitesUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompaniesUnitesCreateManyCompanyInputEnvelope
    set?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    disconnect?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    delete?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    connect?: CompaniesUnitesWhereUniqueInput | CompaniesUnitesWhereUniqueInput[]
    update?: CompaniesUnitesUpdateWithWhereUniqueWithoutCompanyInput | CompaniesUnitesUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompaniesUnitesUpdateManyWithWhereWithoutCompanyInput | CompaniesUnitesUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompaniesUnitesScalarWhereInput | CompaniesUnitesScalarWhereInput[]
  }

  export type UserCreatefeaturesInput = {
    set: string[]
  }

  export type InstanceCreateNestedManyWithoutUserInput = {
    create?: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput> | InstanceCreateWithoutUserInput[] | InstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutUserInput | InstanceCreateOrConnectWithoutUserInput[]
    createMany?: InstanceCreateManyUserInputEnvelope
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type WarmupStatsCreateNestedManyWithoutUserInput = {
    create?: XOR<WarmupStatsCreateWithoutUserInput, WarmupStatsUncheckedCreateWithoutUserInput> | WarmupStatsCreateWithoutUserInput[] | WarmupStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutUserInput | WarmupStatsCreateOrConnectWithoutUserInput[]
    createMany?: WarmupStatsCreateManyUserInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutWhatleadUserInput = {
    create?: XOR<CompanyCreateWithoutWhatleadUserInput, CompanyUncheckedCreateWithoutWhatleadUserInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWhatleadUserInput
    connect?: CompanyWhereUniqueInput
  }

  export type CampaignLeadCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignLeadCreateWithoutUserInput, CampaignLeadUncheckedCreateWithoutUserInput> | CampaignLeadCreateWithoutUserInput[] | CampaignLeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutUserInput | CampaignLeadCreateOrConnectWithoutUserInput[]
    createMany?: CampaignLeadCreateManyUserInputEnvelope
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutAffiliatesInput = {
    create?: XOR<UserCreateWithoutAffiliatesInput, UserUncheckedCreateWithoutAffiliatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAffiliatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<UserCreateWithoutAffiliateInput, UserUncheckedCreateWithoutAffiliateInput> | UserCreateWithoutAffiliateInput[] | UserUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAffiliateInput | UserCreateOrConnectWithoutAffiliateInput[]
    createMany?: UserCreateManyAffiliateInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ContactNoteCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactNoteCreateWithoutUserInput, ContactNoteUncheckedCreateWithoutUserInput> | ContactNoteCreateWithoutUserInput[] | ContactNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutUserInput | ContactNoteCreateOrConnectWithoutUserInput[]
    createMany?: ContactNoteCreateManyUserInputEnvelope
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
  }

  export type InstanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput> | InstanceCreateWithoutUserInput[] | InstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutUserInput | InstanceCreateOrConnectWithoutUserInput[]
    createMany?: InstanceCreateManyUserInputEnvelope
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type WarmupStatsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WarmupStatsCreateWithoutUserInput, WarmupStatsUncheckedCreateWithoutUserInput> | WarmupStatsCreateWithoutUserInput[] | WarmupStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutUserInput | WarmupStatsCreateOrConnectWithoutUserInput[]
    createMany?: WarmupStatsCreateManyUserInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignLeadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignLeadCreateWithoutUserInput, CampaignLeadUncheckedCreateWithoutUserInput> | CampaignLeadCreateWithoutUserInput[] | CampaignLeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutUserInput | CampaignLeadCreateOrConnectWithoutUserInput[]
    createMany?: CampaignLeadCreateManyUserInputEnvelope
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<UserCreateWithoutAffiliateInput, UserUncheckedCreateWithoutAffiliateInput> | UserCreateWithoutAffiliateInput[] | UserUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAffiliateInput | UserCreateOrConnectWithoutAffiliateInput[]
    createMany?: UserCreateManyAffiliateInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ContactNoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactNoteCreateWithoutUserInput, ContactNoteUncheckedCreateWithoutUserInput> | ContactNoteCreateWithoutUserInput[] | ContactNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutUserInput | ContactNoteCreateOrConnectWithoutUserInput[]
    createMany?: ContactNoteCreateManyUserInputEnvelope
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type InstanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput> | InstanceCreateWithoutUserInput[] | InstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutUserInput | InstanceCreateOrConnectWithoutUserInput[]
    upsert?: InstanceUpsertWithWhereUniqueWithoutUserInput | InstanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstanceCreateManyUserInputEnvelope
    set?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    disconnect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    delete?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    update?: InstanceUpdateWithWhereUniqueWithoutUserInput | InstanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstanceUpdateManyWithWhereWithoutUserInput | InstanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type WarmupStatsUpdateManyWithoutUserNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutUserInput, WarmupStatsUncheckedCreateWithoutUserInput> | WarmupStatsCreateWithoutUserInput[] | WarmupStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutUserInput | WarmupStatsCreateOrConnectWithoutUserInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutUserInput | WarmupStatsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WarmupStatsCreateManyUserInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutUserInput | WarmupStatsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutUserInput | WarmupStatsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput = {
    create?: XOR<CompanyCreateWithoutWhatleadUserInput, CompanyUncheckedCreateWithoutWhatleadUserInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWhatleadUserInput
    upsert?: CompanyUpsertWithoutWhatleadUserInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutWhatleadUserInput, CompanyUpdateWithoutWhatleadUserInput>, CompanyUncheckedUpdateWithoutWhatleadUserInput>
  }

  export type CampaignLeadUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutUserInput, CampaignLeadUncheckedCreateWithoutUserInput> | CampaignLeadCreateWithoutUserInput[] | CampaignLeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutUserInput | CampaignLeadCreateOrConnectWithoutUserInput[]
    upsert?: CampaignLeadUpsertWithWhereUniqueWithoutUserInput | CampaignLeadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignLeadCreateManyUserInputEnvelope
    set?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    disconnect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    delete?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    update?: CampaignLeadUpdateWithWhereUniqueWithoutUserInput | CampaignLeadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignLeadUpdateManyWithWhereWithoutUserInput | CampaignLeadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
  }

  export type UserUpdateOneWithoutAffiliatesNestedInput = {
    create?: XOR<UserCreateWithoutAffiliatesInput, UserUncheckedCreateWithoutAffiliatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAffiliatesInput
    upsert?: UserUpsertWithoutAffiliatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAffiliatesInput, UserUpdateWithoutAffiliatesInput>, UserUncheckedUpdateWithoutAffiliatesInput>
  }

  export type UserUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<UserCreateWithoutAffiliateInput, UserUncheckedCreateWithoutAffiliateInput> | UserCreateWithoutAffiliateInput[] | UserUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAffiliateInput | UserCreateOrConnectWithoutAffiliateInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAffiliateInput | UserUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: UserCreateManyAffiliateInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAffiliateInput | UserUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAffiliateInput | UserUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUserInput | ContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUserInput | ContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUserInput | ContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ContactNoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactNoteCreateWithoutUserInput, ContactNoteUncheckedCreateWithoutUserInput> | ContactNoteCreateWithoutUserInput[] | ContactNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutUserInput | ContactNoteCreateOrConnectWithoutUserInput[]
    upsert?: ContactNoteUpsertWithWhereUniqueWithoutUserInput | ContactNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactNoteCreateManyUserInputEnvelope
    set?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    disconnect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    delete?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    update?: ContactNoteUpdateWithWhereUniqueWithoutUserInput | ContactNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactNoteUpdateManyWithWhereWithoutUserInput | ContactNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
  }

  export type InstanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput> | InstanceCreateWithoutUserInput[] | InstanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstanceCreateOrConnectWithoutUserInput | InstanceCreateOrConnectWithoutUserInput[]
    upsert?: InstanceUpsertWithWhereUniqueWithoutUserInput | InstanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstanceCreateManyUserInputEnvelope
    set?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    disconnect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    delete?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    connect?: InstanceWhereUniqueInput | InstanceWhereUniqueInput[]
    update?: InstanceUpdateWithWhereUniqueWithoutUserInput | InstanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstanceUpdateManyWithWhereWithoutUserInput | InstanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type WarmupStatsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutUserInput, WarmupStatsUncheckedCreateWithoutUserInput> | WarmupStatsCreateWithoutUserInput[] | WarmupStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutUserInput | WarmupStatsCreateOrConnectWithoutUserInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutUserInput | WarmupStatsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WarmupStatsCreateManyUserInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutUserInput | WarmupStatsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutUserInput | WarmupStatsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignLeadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutUserInput, CampaignLeadUncheckedCreateWithoutUserInput> | CampaignLeadCreateWithoutUserInput[] | CampaignLeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutUserInput | CampaignLeadCreateOrConnectWithoutUserInput[]
    upsert?: CampaignLeadUpsertWithWhereUniqueWithoutUserInput | CampaignLeadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignLeadCreateManyUserInputEnvelope
    set?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    disconnect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    delete?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    update?: CampaignLeadUpdateWithWhereUniqueWithoutUserInput | CampaignLeadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignLeadUpdateManyWithWhereWithoutUserInput | CampaignLeadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<UserCreateWithoutAffiliateInput, UserUncheckedCreateWithoutAffiliateInput> | UserCreateWithoutAffiliateInput[] | UserUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAffiliateInput | UserCreateOrConnectWithoutAffiliateInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAffiliateInput | UserUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: UserCreateManyAffiliateInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAffiliateInput | UserUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAffiliateInput | UserUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUserInput | ContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUserInput | ContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUserInput | ContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ContactNoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactNoteCreateWithoutUserInput, ContactNoteUncheckedCreateWithoutUserInput> | ContactNoteCreateWithoutUserInput[] | ContactNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutUserInput | ContactNoteCreateOrConnectWithoutUserInput[]
    upsert?: ContactNoteUpsertWithWhereUniqueWithoutUserInput | ContactNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactNoteCreateManyUserInputEnvelope
    set?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    disconnect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    delete?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    update?: ContactNoteUpdateWithWhereUniqueWithoutUserInput | ContactNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactNoteUpdateManyWithWhereWithoutUserInput | ContactNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
  }

  export type CompaniesUnitesCreatetemplatelistvarsInput = {
    set: InputJsonValue[]
  }

  export type CompaniesUnitesCreatemessageperrunsInput = {
    set: InputJsonValue[]
  }

  export type LeadCreateNestedManyWithoutConfigInput = {
    create?: XOR<LeadCreateWithoutConfigInput, LeadUncheckedCreateWithoutConfigInput> | LeadCreateWithoutConfigInput[] | LeadUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutConfigInput | LeadCreateOrConnectWithoutConfigInput[]
    createMany?: LeadCreateManyConfigInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutWhatleadparceiroconfigsInput = {
    create?: XOR<CompanyCreateWithoutWhatleadparceiroconfigsInput, CompanyUncheckedCreateWithoutWhatleadparceiroconfigsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWhatleadparceiroconfigsInput
    connect?: CompanyWhereUniqueInput
  }

  export type LeadUncheckedCreateNestedManyWithoutConfigInput = {
    create?: XOR<LeadCreateWithoutConfigInput, LeadUncheckedCreateWithoutConfigInput> | LeadCreateWithoutConfigInput[] | LeadUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutConfigInput | LeadCreateOrConnectWithoutConfigInput[]
    createMany?: LeadCreateManyConfigInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type CompaniesUnitesUpdatetemplatelistvarsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type CompaniesUnitesUpdatemessageperrunsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type LeadUpdateManyWithoutConfigNestedInput = {
    create?: XOR<LeadCreateWithoutConfigInput, LeadUncheckedCreateWithoutConfigInput> | LeadCreateWithoutConfigInput[] | LeadUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutConfigInput | LeadCreateOrConnectWithoutConfigInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutConfigInput | LeadUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: LeadCreateManyConfigInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutConfigInput | LeadUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutConfigInput | LeadUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutWhatleadparceiroconfigsNestedInput = {
    create?: XOR<CompanyCreateWithoutWhatleadparceiroconfigsInput, CompanyUncheckedCreateWithoutWhatleadparceiroconfigsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutWhatleadparceiroconfigsInput
    upsert?: CompanyUpsertWithoutWhatleadparceiroconfigsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutWhatleadparceiroconfigsInput, CompanyUpdateWithoutWhatleadparceiroconfigsInput>, CompanyUncheckedUpdateWithoutWhatleadparceiroconfigsInput>
  }

  export type LeadUncheckedUpdateManyWithoutConfigNestedInput = {
    create?: XOR<LeadCreateWithoutConfigInput, LeadUncheckedCreateWithoutConfigInput> | LeadCreateWithoutConfigInput[] | LeadUncheckedCreateWithoutConfigInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutConfigInput | LeadCreateOrConnectWithoutConfigInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutConfigInput | LeadUpsertWithWhereUniqueWithoutConfigInput[]
    createMany?: LeadCreateManyConfigInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutConfigInput | LeadUpdateWithWhereUniqueWithoutConfigInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutConfigInput | LeadUpdateManyWithWhereWithoutConfigInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type LeadCreatedialogInput = {
    set: InputJsonValue[]
  }

  export type MessageLogCreateNestedManyWithoutLeadInput = {
    create?: XOR<MessageLogCreateWithoutLeadInput, MessageLogUncheckedCreateWithoutLeadInput> | MessageLogCreateWithoutLeadInput[] | MessageLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutLeadInput | MessageLogCreateOrConnectWithoutLeadInput[]
    createMany?: MessageLogCreateManyLeadInputEnvelope
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
  }

  export type CompaniesUnitesCreateNestedOneWithoutLeadsInput = {
    create?: XOR<CompaniesUnitesCreateWithoutLeadsInput, CompaniesUnitesUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: CompaniesUnitesCreateOrConnectWithoutLeadsInput
    connect?: CompaniesUnitesWhereUniqueInput
  }

  export type MessageLogUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<MessageLogCreateWithoutLeadInput, MessageLogUncheckedCreateWithoutLeadInput> | MessageLogCreateWithoutLeadInput[] | MessageLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutLeadInput | MessageLogCreateOrConnectWithoutLeadInput[]
    createMany?: MessageLogCreateManyLeadInputEnvelope
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LeadUpdatedialogInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type MessageLogUpdateManyWithoutLeadNestedInput = {
    create?: XOR<MessageLogCreateWithoutLeadInput, MessageLogUncheckedCreateWithoutLeadInput> | MessageLogCreateWithoutLeadInput[] | MessageLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutLeadInput | MessageLogCreateOrConnectWithoutLeadInput[]
    upsert?: MessageLogUpsertWithWhereUniqueWithoutLeadInput | MessageLogUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: MessageLogCreateManyLeadInputEnvelope
    set?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    disconnect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    delete?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    update?: MessageLogUpdateWithWhereUniqueWithoutLeadInput | MessageLogUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: MessageLogUpdateManyWithWhereWithoutLeadInput | MessageLogUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
  }

  export type CompaniesUnitesUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<CompaniesUnitesCreateWithoutLeadsInput, CompaniesUnitesUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: CompaniesUnitesCreateOrConnectWithoutLeadsInput
    upsert?: CompaniesUnitesUpsertWithoutLeadsInput
    connect?: CompaniesUnitesWhereUniqueInput
    update?: XOR<XOR<CompaniesUnitesUpdateToOneWithWhereWithoutLeadsInput, CompaniesUnitesUpdateWithoutLeadsInput>, CompaniesUnitesUncheckedUpdateWithoutLeadsInput>
  }

  export type MessageLogUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<MessageLogCreateWithoutLeadInput, MessageLogUncheckedCreateWithoutLeadInput> | MessageLogCreateWithoutLeadInput[] | MessageLogUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutLeadInput | MessageLogCreateOrConnectWithoutLeadInput[]
    upsert?: MessageLogUpsertWithWhereUniqueWithoutLeadInput | MessageLogUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: MessageLogCreateManyLeadInputEnvelope
    set?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    disconnect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    delete?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    update?: MessageLogUpdateWithWhereUniqueWithoutLeadInput | MessageLogUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: MessageLogUpdateManyWithWhereWithoutLeadInput | MessageLogUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutInstancesInput = {
    create?: XOR<UserCreateWithoutInstancesInput, UserUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstancesInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutInstanceInput = {
    create?: XOR<CampaignCreateWithoutInstanceInput, CampaignUncheckedCreateWithoutInstanceInput> | CampaignCreateWithoutInstanceInput[] | CampaignUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutInstanceInput | CampaignCreateOrConnectWithoutInstanceInput[]
    createMany?: CampaignCreateManyInstanceInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignScheduleCreateNestedManyWithoutInstanceInput = {
    create?: XOR<CampaignScheduleCreateWithoutInstanceInput, CampaignScheduleUncheckedCreateWithoutInstanceInput> | CampaignScheduleCreateWithoutInstanceInput[] | CampaignScheduleUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignScheduleCreateOrConnectWithoutInstanceInput | CampaignScheduleCreateOrConnectWithoutInstanceInput[]
    createMany?: CampaignScheduleCreateManyInstanceInputEnvelope
    connect?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
  }

  export type CampaignDispatchCreateNestedManyWithoutInstanceInput = {
    create?: XOR<CampaignDispatchCreateWithoutInstanceInput, CampaignDispatchUncheckedCreateWithoutInstanceInput> | CampaignDispatchCreateWithoutInstanceInput[] | CampaignDispatchUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignDispatchCreateOrConnectWithoutInstanceInput | CampaignDispatchCreateOrConnectWithoutInstanceInput[]
    createMany?: CampaignDispatchCreateManyInstanceInputEnvelope
    connect?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
  }

  export type WarmupStatsCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WarmupStatsCreateWithoutInstanceInput, WarmupStatsUncheckedCreateWithoutInstanceInput> | WarmupStatsCreateWithoutInstanceInput[] | WarmupStatsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutInstanceInput | WarmupStatsCreateOrConnectWithoutInstanceInput[]
    createMany?: WarmupStatsCreateManyInstanceInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type MediaStatsCreateNestedManyWithoutInstanceInput = {
    create?: XOR<MediaStatsCreateWithoutInstanceInput, MediaStatsUncheckedCreateWithoutInstanceInput> | MediaStatsCreateWithoutInstanceInput[] | MediaStatsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MediaStatsCreateOrConnectWithoutInstanceInput | MediaStatsCreateOrConnectWithoutInstanceInput[]
    createMany?: MediaStatsCreateManyInstanceInputEnvelope
    connect?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<CampaignCreateWithoutInstanceInput, CampaignUncheckedCreateWithoutInstanceInput> | CampaignCreateWithoutInstanceInput[] | CampaignUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutInstanceInput | CampaignCreateOrConnectWithoutInstanceInput[]
    createMany?: CampaignCreateManyInstanceInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignScheduleUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<CampaignScheduleCreateWithoutInstanceInput, CampaignScheduleUncheckedCreateWithoutInstanceInput> | CampaignScheduleCreateWithoutInstanceInput[] | CampaignScheduleUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignScheduleCreateOrConnectWithoutInstanceInput | CampaignScheduleCreateOrConnectWithoutInstanceInput[]
    createMany?: CampaignScheduleCreateManyInstanceInputEnvelope
    connect?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
  }

  export type CampaignDispatchUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<CampaignDispatchCreateWithoutInstanceInput, CampaignDispatchUncheckedCreateWithoutInstanceInput> | CampaignDispatchCreateWithoutInstanceInput[] | CampaignDispatchUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignDispatchCreateOrConnectWithoutInstanceInput | CampaignDispatchCreateOrConnectWithoutInstanceInput[]
    createMany?: CampaignDispatchCreateManyInstanceInputEnvelope
    connect?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
  }

  export type WarmupStatsUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<WarmupStatsCreateWithoutInstanceInput, WarmupStatsUncheckedCreateWithoutInstanceInput> | WarmupStatsCreateWithoutInstanceInput[] | WarmupStatsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutInstanceInput | WarmupStatsCreateOrConnectWithoutInstanceInput[]
    createMany?: WarmupStatsCreateManyInstanceInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type MediaStatsUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<MediaStatsCreateWithoutInstanceInput, MediaStatsUncheckedCreateWithoutInstanceInput> | MediaStatsCreateWithoutInstanceInput[] | MediaStatsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MediaStatsCreateOrConnectWithoutInstanceInput | MediaStatsCreateOrConnectWithoutInstanceInput[]
    createMany?: MediaStatsCreateManyInstanceInputEnvelope
    connect?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
  }

  export type EnumInstanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InstanceStatus
  }

  export type UserUpdateOneRequiredWithoutInstancesNestedInput = {
    create?: XOR<UserCreateWithoutInstancesInput, UserUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstancesInput
    upsert?: UserUpsertWithoutInstancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInstancesInput, UserUpdateWithoutInstancesInput>, UserUncheckedUpdateWithoutInstancesInput>
  }

  export type CampaignUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<CampaignCreateWithoutInstanceInput, CampaignUncheckedCreateWithoutInstanceInput> | CampaignCreateWithoutInstanceInput[] | CampaignUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutInstanceInput | CampaignCreateOrConnectWithoutInstanceInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutInstanceInput | CampaignUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: CampaignCreateManyInstanceInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutInstanceInput | CampaignUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutInstanceInput | CampaignUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignScheduleUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<CampaignScheduleCreateWithoutInstanceInput, CampaignScheduleUncheckedCreateWithoutInstanceInput> | CampaignScheduleCreateWithoutInstanceInput[] | CampaignScheduleUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignScheduleCreateOrConnectWithoutInstanceInput | CampaignScheduleCreateOrConnectWithoutInstanceInput[]
    upsert?: CampaignScheduleUpsertWithWhereUniqueWithoutInstanceInput | CampaignScheduleUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: CampaignScheduleCreateManyInstanceInputEnvelope
    set?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    disconnect?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    delete?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    connect?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    update?: CampaignScheduleUpdateWithWhereUniqueWithoutInstanceInput | CampaignScheduleUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: CampaignScheduleUpdateManyWithWhereWithoutInstanceInput | CampaignScheduleUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: CampaignScheduleScalarWhereInput | CampaignScheduleScalarWhereInput[]
  }

  export type CampaignDispatchUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<CampaignDispatchCreateWithoutInstanceInput, CampaignDispatchUncheckedCreateWithoutInstanceInput> | CampaignDispatchCreateWithoutInstanceInput[] | CampaignDispatchUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignDispatchCreateOrConnectWithoutInstanceInput | CampaignDispatchCreateOrConnectWithoutInstanceInput[]
    upsert?: CampaignDispatchUpsertWithWhereUniqueWithoutInstanceInput | CampaignDispatchUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: CampaignDispatchCreateManyInstanceInputEnvelope
    set?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    disconnect?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    delete?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    connect?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    update?: CampaignDispatchUpdateWithWhereUniqueWithoutInstanceInput | CampaignDispatchUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: CampaignDispatchUpdateManyWithWhereWithoutInstanceInput | CampaignDispatchUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: CampaignDispatchScalarWhereInput | CampaignDispatchScalarWhereInput[]
  }

  export type WarmupStatsUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutInstanceInput, WarmupStatsUncheckedCreateWithoutInstanceInput> | WarmupStatsCreateWithoutInstanceInput[] | WarmupStatsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutInstanceInput | WarmupStatsCreateOrConnectWithoutInstanceInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutInstanceInput | WarmupStatsUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WarmupStatsCreateManyInstanceInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutInstanceInput | WarmupStatsUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutInstanceInput | WarmupStatsUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type MediaStatsUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<MediaStatsCreateWithoutInstanceInput, MediaStatsUncheckedCreateWithoutInstanceInput> | MediaStatsCreateWithoutInstanceInput[] | MediaStatsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MediaStatsCreateOrConnectWithoutInstanceInput | MediaStatsCreateOrConnectWithoutInstanceInput[]
    upsert?: MediaStatsUpsertWithWhereUniqueWithoutInstanceInput | MediaStatsUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: MediaStatsCreateManyInstanceInputEnvelope
    set?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    disconnect?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    delete?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    connect?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    update?: MediaStatsUpdateWithWhereUniqueWithoutInstanceInput | MediaStatsUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: MediaStatsUpdateManyWithWhereWithoutInstanceInput | MediaStatsUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: MediaStatsScalarWhereInput | MediaStatsScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<CampaignCreateWithoutInstanceInput, CampaignUncheckedCreateWithoutInstanceInput> | CampaignCreateWithoutInstanceInput[] | CampaignUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutInstanceInput | CampaignCreateOrConnectWithoutInstanceInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutInstanceInput | CampaignUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: CampaignCreateManyInstanceInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutInstanceInput | CampaignUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutInstanceInput | CampaignUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignScheduleUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<CampaignScheduleCreateWithoutInstanceInput, CampaignScheduleUncheckedCreateWithoutInstanceInput> | CampaignScheduleCreateWithoutInstanceInput[] | CampaignScheduleUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignScheduleCreateOrConnectWithoutInstanceInput | CampaignScheduleCreateOrConnectWithoutInstanceInput[]
    upsert?: CampaignScheduleUpsertWithWhereUniqueWithoutInstanceInput | CampaignScheduleUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: CampaignScheduleCreateManyInstanceInputEnvelope
    set?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    disconnect?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    delete?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    connect?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    update?: CampaignScheduleUpdateWithWhereUniqueWithoutInstanceInput | CampaignScheduleUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: CampaignScheduleUpdateManyWithWhereWithoutInstanceInput | CampaignScheduleUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: CampaignScheduleScalarWhereInput | CampaignScheduleScalarWhereInput[]
  }

  export type CampaignDispatchUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<CampaignDispatchCreateWithoutInstanceInput, CampaignDispatchUncheckedCreateWithoutInstanceInput> | CampaignDispatchCreateWithoutInstanceInput[] | CampaignDispatchUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: CampaignDispatchCreateOrConnectWithoutInstanceInput | CampaignDispatchCreateOrConnectWithoutInstanceInput[]
    upsert?: CampaignDispatchUpsertWithWhereUniqueWithoutInstanceInput | CampaignDispatchUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: CampaignDispatchCreateManyInstanceInputEnvelope
    set?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    disconnect?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    delete?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    connect?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    update?: CampaignDispatchUpdateWithWhereUniqueWithoutInstanceInput | CampaignDispatchUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: CampaignDispatchUpdateManyWithWhereWithoutInstanceInput | CampaignDispatchUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: CampaignDispatchScalarWhereInput | CampaignDispatchScalarWhereInput[]
  }

  export type WarmupStatsUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutInstanceInput, WarmupStatsUncheckedCreateWithoutInstanceInput> | WarmupStatsCreateWithoutInstanceInput[] | WarmupStatsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutInstanceInput | WarmupStatsCreateOrConnectWithoutInstanceInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutInstanceInput | WarmupStatsUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: WarmupStatsCreateManyInstanceInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutInstanceInput | WarmupStatsUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutInstanceInput | WarmupStatsUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type MediaStatsUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<MediaStatsCreateWithoutInstanceInput, MediaStatsUncheckedCreateWithoutInstanceInput> | MediaStatsCreateWithoutInstanceInput[] | MediaStatsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MediaStatsCreateOrConnectWithoutInstanceInput | MediaStatsCreateOrConnectWithoutInstanceInput[]
    upsert?: MediaStatsUpsertWithWhereUniqueWithoutInstanceInput | MediaStatsUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: MediaStatsCreateManyInstanceInputEnvelope
    set?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    disconnect?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    delete?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    connect?: MediaStatsWhereUniqueInput | MediaStatsWhereUniqueInput[]
    update?: MediaStatsUpdateWithWhereUniqueWithoutInstanceInput | MediaStatsUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: MediaStatsUpdateManyWithWhereWithoutInstanceInput | MediaStatsUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: MediaStatsScalarWhereInput | MediaStatsScalarWhereInput[]
  }

  export type InstanceCreateNestedOneWithoutMediaStatsInput = {
    create?: XOR<InstanceCreateWithoutMediaStatsInput, InstanceUncheckedCreateWithoutMediaStatsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutMediaStatsInput
    connect?: InstanceWhereUniqueInput
  }

  export type WarmupStatsCreateNestedManyWithoutMediaReceivedInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaReceivedInput, WarmupStatsUncheckedCreateWithoutMediaReceivedInput> | WarmupStatsCreateWithoutMediaReceivedInput[] | WarmupStatsUncheckedCreateWithoutMediaReceivedInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaReceivedInput | WarmupStatsCreateOrConnectWithoutMediaReceivedInput[]
    createMany?: WarmupStatsCreateManyMediaReceivedInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type WarmupStatsCreateNestedManyWithoutMediaStatsInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaStatsInput, WarmupStatsUncheckedCreateWithoutMediaStatsInput> | WarmupStatsCreateWithoutMediaStatsInput[] | WarmupStatsUncheckedCreateWithoutMediaStatsInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaStatsInput | WarmupStatsCreateOrConnectWithoutMediaStatsInput[]
    createMany?: WarmupStatsCreateManyMediaStatsInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type WarmupStatsUncheckedCreateNestedManyWithoutMediaReceivedInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaReceivedInput, WarmupStatsUncheckedCreateWithoutMediaReceivedInput> | WarmupStatsCreateWithoutMediaReceivedInput[] | WarmupStatsUncheckedCreateWithoutMediaReceivedInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaReceivedInput | WarmupStatsCreateOrConnectWithoutMediaReceivedInput[]
    createMany?: WarmupStatsCreateManyMediaReceivedInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type WarmupStatsUncheckedCreateNestedManyWithoutMediaStatsInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaStatsInput, WarmupStatsUncheckedCreateWithoutMediaStatsInput> | WarmupStatsCreateWithoutMediaStatsInput[] | WarmupStatsUncheckedCreateWithoutMediaStatsInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaStatsInput | WarmupStatsCreateOrConnectWithoutMediaStatsInput[]
    createMany?: WarmupStatsCreateManyMediaStatsInputEnvelope
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
  }

  export type InstanceUpdateOneRequiredWithoutMediaStatsNestedInput = {
    create?: XOR<InstanceCreateWithoutMediaStatsInput, InstanceUncheckedCreateWithoutMediaStatsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutMediaStatsInput
    upsert?: InstanceUpsertWithoutMediaStatsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutMediaStatsInput, InstanceUpdateWithoutMediaStatsInput>, InstanceUncheckedUpdateWithoutMediaStatsInput>
  }

  export type WarmupStatsUpdateManyWithoutMediaReceivedNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaReceivedInput, WarmupStatsUncheckedCreateWithoutMediaReceivedInput> | WarmupStatsCreateWithoutMediaReceivedInput[] | WarmupStatsUncheckedCreateWithoutMediaReceivedInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaReceivedInput | WarmupStatsCreateOrConnectWithoutMediaReceivedInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutMediaReceivedInput | WarmupStatsUpsertWithWhereUniqueWithoutMediaReceivedInput[]
    createMany?: WarmupStatsCreateManyMediaReceivedInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutMediaReceivedInput | WarmupStatsUpdateWithWhereUniqueWithoutMediaReceivedInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutMediaReceivedInput | WarmupStatsUpdateManyWithWhereWithoutMediaReceivedInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type WarmupStatsUpdateManyWithoutMediaStatsNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaStatsInput, WarmupStatsUncheckedCreateWithoutMediaStatsInput> | WarmupStatsCreateWithoutMediaStatsInput[] | WarmupStatsUncheckedCreateWithoutMediaStatsInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaStatsInput | WarmupStatsCreateOrConnectWithoutMediaStatsInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutMediaStatsInput | WarmupStatsUpsertWithWhereUniqueWithoutMediaStatsInput[]
    createMany?: WarmupStatsCreateManyMediaStatsInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutMediaStatsInput | WarmupStatsUpdateWithWhereUniqueWithoutMediaStatsInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutMediaStatsInput | WarmupStatsUpdateManyWithWhereWithoutMediaStatsInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type WarmupStatsUncheckedUpdateManyWithoutMediaReceivedNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaReceivedInput, WarmupStatsUncheckedCreateWithoutMediaReceivedInput> | WarmupStatsCreateWithoutMediaReceivedInput[] | WarmupStatsUncheckedCreateWithoutMediaReceivedInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaReceivedInput | WarmupStatsCreateOrConnectWithoutMediaReceivedInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutMediaReceivedInput | WarmupStatsUpsertWithWhereUniqueWithoutMediaReceivedInput[]
    createMany?: WarmupStatsCreateManyMediaReceivedInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutMediaReceivedInput | WarmupStatsUpdateWithWhereUniqueWithoutMediaReceivedInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutMediaReceivedInput | WarmupStatsUpdateManyWithWhereWithoutMediaReceivedInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type WarmupStatsUncheckedUpdateManyWithoutMediaStatsNestedInput = {
    create?: XOR<WarmupStatsCreateWithoutMediaStatsInput, WarmupStatsUncheckedCreateWithoutMediaStatsInput> | WarmupStatsCreateWithoutMediaStatsInput[] | WarmupStatsUncheckedCreateWithoutMediaStatsInput[]
    connectOrCreate?: WarmupStatsCreateOrConnectWithoutMediaStatsInput | WarmupStatsCreateOrConnectWithoutMediaStatsInput[]
    upsert?: WarmupStatsUpsertWithWhereUniqueWithoutMediaStatsInput | WarmupStatsUpsertWithWhereUniqueWithoutMediaStatsInput[]
    createMany?: WarmupStatsCreateManyMediaStatsInputEnvelope
    set?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    disconnect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    delete?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    connect?: WarmupStatsWhereUniqueInput | WarmupStatsWhereUniqueInput[]
    update?: WarmupStatsUpdateWithWhereUniqueWithoutMediaStatsInput | WarmupStatsUpdateWithWhereUniqueWithoutMediaStatsInput[]
    updateMany?: WarmupStatsUpdateManyWithWhereWithoutMediaStatsInput | WarmupStatsUpdateManyWithWhereWithoutMediaStatsInput[]
    deleteMany?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
  }

  export type InstanceCreateNestedOneWithoutWarmupStatsInput = {
    create?: XOR<InstanceCreateWithoutWarmupStatsInput, InstanceUncheckedCreateWithoutWarmupStatsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutWarmupStatsInput
    connect?: InstanceWhereUniqueInput
  }

  export type MediaStatsCreateNestedOneWithoutWarmupStatsReceivedInput = {
    create?: XOR<MediaStatsCreateWithoutWarmupStatsReceivedInput, MediaStatsUncheckedCreateWithoutWarmupStatsReceivedInput>
    connectOrCreate?: MediaStatsCreateOrConnectWithoutWarmupStatsReceivedInput
    connect?: MediaStatsWhereUniqueInput
  }

  export type MediaStatsCreateNestedOneWithoutWarmupStatsSentInput = {
    create?: XOR<MediaStatsCreateWithoutWarmupStatsSentInput, MediaStatsUncheckedCreateWithoutWarmupStatsSentInput>
    connectOrCreate?: MediaStatsCreateOrConnectWithoutWarmupStatsSentInput
    connect?: MediaStatsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWarmupStatsInput = {
    create?: XOR<UserCreateWithoutWarmupStatsInput, UserUncheckedCreateWithoutWarmupStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWarmupStatsInput
    connect?: UserWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutWarmupStatsNestedInput = {
    create?: XOR<InstanceCreateWithoutWarmupStatsInput, InstanceUncheckedCreateWithoutWarmupStatsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutWarmupStatsInput
    upsert?: InstanceUpsertWithoutWarmupStatsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutWarmupStatsInput, InstanceUpdateWithoutWarmupStatsInput>, InstanceUncheckedUpdateWithoutWarmupStatsInput>
  }

  export type MediaStatsUpdateOneWithoutWarmupStatsReceivedNestedInput = {
    create?: XOR<MediaStatsCreateWithoutWarmupStatsReceivedInput, MediaStatsUncheckedCreateWithoutWarmupStatsReceivedInput>
    connectOrCreate?: MediaStatsCreateOrConnectWithoutWarmupStatsReceivedInput
    upsert?: MediaStatsUpsertWithoutWarmupStatsReceivedInput
    disconnect?: MediaStatsWhereInput | boolean
    delete?: MediaStatsWhereInput | boolean
    connect?: MediaStatsWhereUniqueInput
    update?: XOR<XOR<MediaStatsUpdateToOneWithWhereWithoutWarmupStatsReceivedInput, MediaStatsUpdateWithoutWarmupStatsReceivedInput>, MediaStatsUncheckedUpdateWithoutWarmupStatsReceivedInput>
  }

  export type MediaStatsUpdateOneWithoutWarmupStatsSentNestedInput = {
    create?: XOR<MediaStatsCreateWithoutWarmupStatsSentInput, MediaStatsUncheckedCreateWithoutWarmupStatsSentInput>
    connectOrCreate?: MediaStatsCreateOrConnectWithoutWarmupStatsSentInput
    upsert?: MediaStatsUpsertWithoutWarmupStatsSentInput
    disconnect?: MediaStatsWhereInput | boolean
    delete?: MediaStatsWhereInput | boolean
    connect?: MediaStatsWhereUniqueInput
    update?: XOR<XOR<MediaStatsUpdateToOneWithWhereWithoutWarmupStatsSentInput, MediaStatsUpdateWithoutWarmupStatsSentInput>, MediaStatsUncheckedUpdateWithoutWarmupStatsSentInput>
  }

  export type UserUpdateOneRequiredWithoutWarmupStatsNestedInput = {
    create?: XOR<UserCreateWithoutWarmupStatsInput, UserUncheckedCreateWithoutWarmupStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWarmupStatsInput
    upsert?: UserUpsertWithoutWarmupStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWarmupStatsInput, UserUpdateWithoutWarmupStatsInput>, UserUncheckedUpdateWithoutWarmupStatsInput>
  }

  export type MessageLogCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MessageLogCreateWithoutCampaignInput, MessageLogUncheckedCreateWithoutCampaignInput> | MessageLogCreateWithoutCampaignInput[] | MessageLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignInput | MessageLogCreateOrConnectWithoutCampaignInput[]
    createMany?: MessageLogCreateManyCampaignInputEnvelope
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
  }

  export type CampaignLeadCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput> | CampaignLeadCreateWithoutCampaignInput[] | CampaignLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutCampaignInput | CampaignLeadCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignLeadCreateManyCampaignInputEnvelope
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
  }

  export type CampaignMessageCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput> | CampaignMessageCreateWithoutCampaignInput[] | CampaignMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutCampaignInput | CampaignMessageCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignMessageCreateManyCampaignInputEnvelope
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
  }

  export type CampaignStatisticsCreateNestedOneWithoutCampaignInput = {
    create?: XOR<CampaignStatisticsCreateWithoutCampaignInput, CampaignStatisticsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignStatisticsCreateOrConnectWithoutCampaignInput
    connect?: CampaignStatisticsWhereUniqueInput
  }

  export type CampaignDispatchCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignDispatchCreateWithoutCampaignInput, CampaignDispatchUncheckedCreateWithoutCampaignInput> | CampaignDispatchCreateWithoutCampaignInput[] | CampaignDispatchUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignDispatchCreateOrConnectWithoutCampaignInput | CampaignDispatchCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignDispatchCreateManyCampaignInputEnvelope
    connect?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCampaignInput = {
    create?: XOR<UserCreateWithoutCampaignInput, UserUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignInput
    connect?: UserWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<InstanceCreateWithoutCampaignsInput, InstanceUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutCampaignsInput
    connect?: InstanceWhereUniqueInput
  }

  export type CampaignErrorLogCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignErrorLogCreateWithoutCampaignInput, CampaignErrorLogUncheckedCreateWithoutCampaignInput> | CampaignErrorLogCreateWithoutCampaignInput[] | CampaignErrorLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignErrorLogCreateOrConnectWithoutCampaignInput | CampaignErrorLogCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignErrorLogCreateManyCampaignInputEnvelope
    connect?: CampaignErrorLogWhereUniqueInput | CampaignErrorLogWhereUniqueInput[]
  }

  export type CampaignScheduleCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignScheduleCreateWithoutCampaignInput, CampaignScheduleUncheckedCreateWithoutCampaignInput> | CampaignScheduleCreateWithoutCampaignInput[] | CampaignScheduleUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignScheduleCreateOrConnectWithoutCampaignInput | CampaignScheduleCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignScheduleCreateManyCampaignInputEnvelope
    connect?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
  }

  export type MessageAnalyticsCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MessageAnalyticsCreateWithoutCampaignInput, MessageAnalyticsUncheckedCreateWithoutCampaignInput> | MessageAnalyticsCreateWithoutCampaignInput[] | MessageAnalyticsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MessageAnalyticsCreateOrConnectWithoutCampaignInput | MessageAnalyticsCreateOrConnectWithoutCampaignInput[]
    createMany?: MessageAnalyticsCreateManyCampaignInputEnvelope
    connect?: MessageAnalyticsWhereUniqueInput | MessageAnalyticsWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<ContactCreateWithoutCampaignsInput, ContactUncheckedCreateWithoutCampaignsInput> | ContactCreateWithoutCampaignsInput[] | ContactUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCampaignsInput | ContactCreateOrConnectWithoutCampaignsInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type MessageLogUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MessageLogCreateWithoutCampaignInput, MessageLogUncheckedCreateWithoutCampaignInput> | MessageLogCreateWithoutCampaignInput[] | MessageLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignInput | MessageLogCreateOrConnectWithoutCampaignInput[]
    createMany?: MessageLogCreateManyCampaignInputEnvelope
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
  }

  export type CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput> | CampaignLeadCreateWithoutCampaignInput[] | CampaignLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutCampaignInput | CampaignLeadCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignLeadCreateManyCampaignInputEnvelope
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
  }

  export type CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput> | CampaignMessageCreateWithoutCampaignInput[] | CampaignMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutCampaignInput | CampaignMessageCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignMessageCreateManyCampaignInputEnvelope
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
  }

  export type CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput = {
    create?: XOR<CampaignStatisticsCreateWithoutCampaignInput, CampaignStatisticsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignStatisticsCreateOrConnectWithoutCampaignInput
    connect?: CampaignStatisticsWhereUniqueInput
  }

  export type CampaignDispatchUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignDispatchCreateWithoutCampaignInput, CampaignDispatchUncheckedCreateWithoutCampaignInput> | CampaignDispatchCreateWithoutCampaignInput[] | CampaignDispatchUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignDispatchCreateOrConnectWithoutCampaignInput | CampaignDispatchCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignDispatchCreateManyCampaignInputEnvelope
    connect?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
  }

  export type CampaignErrorLogUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignErrorLogCreateWithoutCampaignInput, CampaignErrorLogUncheckedCreateWithoutCampaignInput> | CampaignErrorLogCreateWithoutCampaignInput[] | CampaignErrorLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignErrorLogCreateOrConnectWithoutCampaignInput | CampaignErrorLogCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignErrorLogCreateManyCampaignInputEnvelope
    connect?: CampaignErrorLogWhereUniqueInput | CampaignErrorLogWhereUniqueInput[]
  }

  export type CampaignScheduleUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignScheduleCreateWithoutCampaignInput, CampaignScheduleUncheckedCreateWithoutCampaignInput> | CampaignScheduleCreateWithoutCampaignInput[] | CampaignScheduleUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignScheduleCreateOrConnectWithoutCampaignInput | CampaignScheduleCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignScheduleCreateManyCampaignInputEnvelope
    connect?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
  }

  export type MessageAnalyticsUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MessageAnalyticsCreateWithoutCampaignInput, MessageAnalyticsUncheckedCreateWithoutCampaignInput> | MessageAnalyticsCreateWithoutCampaignInput[] | MessageAnalyticsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MessageAnalyticsCreateOrConnectWithoutCampaignInput | MessageAnalyticsCreateOrConnectWithoutCampaignInput[]
    createMany?: MessageAnalyticsCreateManyCampaignInputEnvelope
    connect?: MessageAnalyticsWhereUniqueInput | MessageAnalyticsWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<ContactCreateWithoutCampaignsInput, ContactUncheckedCreateWithoutCampaignsInput> | ContactCreateWithoutCampaignsInput[] | ContactUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCampaignsInput | ContactCreateOrConnectWithoutCampaignsInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type MessageLogUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MessageLogCreateWithoutCampaignInput, MessageLogUncheckedCreateWithoutCampaignInput> | MessageLogCreateWithoutCampaignInput[] | MessageLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignInput | MessageLogCreateOrConnectWithoutCampaignInput[]
    upsert?: MessageLogUpsertWithWhereUniqueWithoutCampaignInput | MessageLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MessageLogCreateManyCampaignInputEnvelope
    set?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    disconnect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    delete?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    update?: MessageLogUpdateWithWhereUniqueWithoutCampaignInput | MessageLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MessageLogUpdateManyWithWhereWithoutCampaignInput | MessageLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
  }

  export type CampaignLeadUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput> | CampaignLeadCreateWithoutCampaignInput[] | CampaignLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutCampaignInput | CampaignLeadCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput | CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignLeadCreateManyCampaignInputEnvelope
    set?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    disconnect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    delete?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    update?: CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput | CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignLeadUpdateManyWithWhereWithoutCampaignInput | CampaignLeadUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
  }

  export type CampaignMessageUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput> | CampaignMessageCreateWithoutCampaignInput[] | CampaignMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutCampaignInput | CampaignMessageCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput | CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignMessageCreateManyCampaignInputEnvelope
    set?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    disconnect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    delete?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    update?: CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput | CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignMessageUpdateManyWithWhereWithoutCampaignInput | CampaignMessageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
  }

  export type CampaignStatisticsUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<CampaignStatisticsCreateWithoutCampaignInput, CampaignStatisticsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignStatisticsCreateOrConnectWithoutCampaignInput
    upsert?: CampaignStatisticsUpsertWithoutCampaignInput
    disconnect?: CampaignStatisticsWhereInput | boolean
    delete?: CampaignStatisticsWhereInput | boolean
    connect?: CampaignStatisticsWhereUniqueInput
    update?: XOR<XOR<CampaignStatisticsUpdateToOneWithWhereWithoutCampaignInput, CampaignStatisticsUpdateWithoutCampaignInput>, CampaignStatisticsUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignDispatchUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignDispatchCreateWithoutCampaignInput, CampaignDispatchUncheckedCreateWithoutCampaignInput> | CampaignDispatchCreateWithoutCampaignInput[] | CampaignDispatchUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignDispatchCreateOrConnectWithoutCampaignInput | CampaignDispatchCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignDispatchUpsertWithWhereUniqueWithoutCampaignInput | CampaignDispatchUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignDispatchCreateManyCampaignInputEnvelope
    set?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    disconnect?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    delete?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    connect?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    update?: CampaignDispatchUpdateWithWhereUniqueWithoutCampaignInput | CampaignDispatchUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignDispatchUpdateManyWithWhereWithoutCampaignInput | CampaignDispatchUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignDispatchScalarWhereInput | CampaignDispatchScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCampaignNestedInput = {
    create?: XOR<UserCreateWithoutCampaignInput, UserUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignInput
    upsert?: UserUpsertWithoutCampaignInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignInput, UserUpdateWithoutCampaignInput>, UserUncheckedUpdateWithoutCampaignInput>
  }

  export type InstanceUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<InstanceCreateWithoutCampaignsInput, InstanceUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutCampaignsInput
    upsert?: InstanceUpsertWithoutCampaignsInput
    disconnect?: InstanceWhereInput | boolean
    delete?: InstanceWhereInput | boolean
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutCampaignsInput, InstanceUpdateWithoutCampaignsInput>, InstanceUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignErrorLogUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignErrorLogCreateWithoutCampaignInput, CampaignErrorLogUncheckedCreateWithoutCampaignInput> | CampaignErrorLogCreateWithoutCampaignInput[] | CampaignErrorLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignErrorLogCreateOrConnectWithoutCampaignInput | CampaignErrorLogCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignErrorLogUpsertWithWhereUniqueWithoutCampaignInput | CampaignErrorLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignErrorLogCreateManyCampaignInputEnvelope
    set?: CampaignErrorLogWhereUniqueInput | CampaignErrorLogWhereUniqueInput[]
    disconnect?: CampaignErrorLogWhereUniqueInput | CampaignErrorLogWhereUniqueInput[]
    delete?: CampaignErrorLogWhereUniqueInput | CampaignErrorLogWhereUniqueInput[]
    connect?: CampaignErrorLogWhereUniqueInput | CampaignErrorLogWhereUniqueInput[]
    update?: CampaignErrorLogUpdateWithWhereUniqueWithoutCampaignInput | CampaignErrorLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignErrorLogUpdateManyWithWhereWithoutCampaignInput | CampaignErrorLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignErrorLogScalarWhereInput | CampaignErrorLogScalarWhereInput[]
  }

  export type CampaignScheduleUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignScheduleCreateWithoutCampaignInput, CampaignScheduleUncheckedCreateWithoutCampaignInput> | CampaignScheduleCreateWithoutCampaignInput[] | CampaignScheduleUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignScheduleCreateOrConnectWithoutCampaignInput | CampaignScheduleCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignScheduleUpsertWithWhereUniqueWithoutCampaignInput | CampaignScheduleUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignScheduleCreateManyCampaignInputEnvelope
    set?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    disconnect?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    delete?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    connect?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    update?: CampaignScheduleUpdateWithWhereUniqueWithoutCampaignInput | CampaignScheduleUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignScheduleUpdateManyWithWhereWithoutCampaignInput | CampaignScheduleUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignScheduleScalarWhereInput | CampaignScheduleScalarWhereInput[]
  }

  export type MessageAnalyticsUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MessageAnalyticsCreateWithoutCampaignInput, MessageAnalyticsUncheckedCreateWithoutCampaignInput> | MessageAnalyticsCreateWithoutCampaignInput[] | MessageAnalyticsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MessageAnalyticsCreateOrConnectWithoutCampaignInput | MessageAnalyticsCreateOrConnectWithoutCampaignInput[]
    upsert?: MessageAnalyticsUpsertWithWhereUniqueWithoutCampaignInput | MessageAnalyticsUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MessageAnalyticsCreateManyCampaignInputEnvelope
    set?: MessageAnalyticsWhereUniqueInput | MessageAnalyticsWhereUniqueInput[]
    disconnect?: MessageAnalyticsWhereUniqueInput | MessageAnalyticsWhereUniqueInput[]
    delete?: MessageAnalyticsWhereUniqueInput | MessageAnalyticsWhereUniqueInput[]
    connect?: MessageAnalyticsWhereUniqueInput | MessageAnalyticsWhereUniqueInput[]
    update?: MessageAnalyticsUpdateWithWhereUniqueWithoutCampaignInput | MessageAnalyticsUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MessageAnalyticsUpdateManyWithWhereWithoutCampaignInput | MessageAnalyticsUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MessageAnalyticsScalarWhereInput | MessageAnalyticsScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<ContactCreateWithoutCampaignsInput, ContactUncheckedCreateWithoutCampaignsInput> | ContactCreateWithoutCampaignsInput[] | ContactUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCampaignsInput | ContactCreateOrConnectWithoutCampaignsInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCampaignsInput | ContactUpsertWithWhereUniqueWithoutCampaignsInput[]
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCampaignsInput | ContactUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCampaignsInput | ContactUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type MessageLogUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MessageLogCreateWithoutCampaignInput, MessageLogUncheckedCreateWithoutCampaignInput> | MessageLogCreateWithoutCampaignInput[] | MessageLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignInput | MessageLogCreateOrConnectWithoutCampaignInput[]
    upsert?: MessageLogUpsertWithWhereUniqueWithoutCampaignInput | MessageLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MessageLogCreateManyCampaignInputEnvelope
    set?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    disconnect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    delete?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    update?: MessageLogUpdateWithWhereUniqueWithoutCampaignInput | MessageLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MessageLogUpdateManyWithWhereWithoutCampaignInput | MessageLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
  }

  export type CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput> | CampaignLeadCreateWithoutCampaignInput[] | CampaignLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutCampaignInput | CampaignLeadCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput | CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignLeadCreateManyCampaignInputEnvelope
    set?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    disconnect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    delete?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    connect?: CampaignLeadWhereUniqueInput | CampaignLeadWhereUniqueInput[]
    update?: CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput | CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignLeadUpdateManyWithWhereWithoutCampaignInput | CampaignLeadUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
  }

  export type CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput> | CampaignMessageCreateWithoutCampaignInput[] | CampaignMessageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMessageCreateOrConnectWithoutCampaignInput | CampaignMessageCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput | CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignMessageCreateManyCampaignInputEnvelope
    set?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    disconnect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    delete?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    connect?: CampaignMessageWhereUniqueInput | CampaignMessageWhereUniqueInput[]
    update?: CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput | CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignMessageUpdateManyWithWhereWithoutCampaignInput | CampaignMessageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
  }

  export type CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<CampaignStatisticsCreateWithoutCampaignInput, CampaignStatisticsUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignStatisticsCreateOrConnectWithoutCampaignInput
    upsert?: CampaignStatisticsUpsertWithoutCampaignInput
    disconnect?: CampaignStatisticsWhereInput | boolean
    delete?: CampaignStatisticsWhereInput | boolean
    connect?: CampaignStatisticsWhereUniqueInput
    update?: XOR<XOR<CampaignStatisticsUpdateToOneWithWhereWithoutCampaignInput, CampaignStatisticsUpdateWithoutCampaignInput>, CampaignStatisticsUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignDispatchUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignDispatchCreateWithoutCampaignInput, CampaignDispatchUncheckedCreateWithoutCampaignInput> | CampaignDispatchCreateWithoutCampaignInput[] | CampaignDispatchUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignDispatchCreateOrConnectWithoutCampaignInput | CampaignDispatchCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignDispatchUpsertWithWhereUniqueWithoutCampaignInput | CampaignDispatchUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignDispatchCreateManyCampaignInputEnvelope
    set?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    disconnect?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    delete?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    connect?: CampaignDispatchWhereUniqueInput | CampaignDispatchWhereUniqueInput[]
    update?: CampaignDispatchUpdateWithWhereUniqueWithoutCampaignInput | CampaignDispatchUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignDispatchUpdateManyWithWhereWithoutCampaignInput | CampaignDispatchUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignDispatchScalarWhereInput | CampaignDispatchScalarWhereInput[]
  }

  export type CampaignErrorLogUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignErrorLogCreateWithoutCampaignInput, CampaignErrorLogUncheckedCreateWithoutCampaignInput> | CampaignErrorLogCreateWithoutCampaignInput[] | CampaignErrorLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignErrorLogCreateOrConnectWithoutCampaignInput | CampaignErrorLogCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignErrorLogUpsertWithWhereUniqueWithoutCampaignInput | CampaignErrorLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignErrorLogCreateManyCampaignInputEnvelope
    set?: CampaignErrorLogWhereUniqueInput | CampaignErrorLogWhereUniqueInput[]
    disconnect?: CampaignErrorLogWhereUniqueInput | CampaignErrorLogWhereUniqueInput[]
    delete?: CampaignErrorLogWhereUniqueInput | CampaignErrorLogWhereUniqueInput[]
    connect?: CampaignErrorLogWhereUniqueInput | CampaignErrorLogWhereUniqueInput[]
    update?: CampaignErrorLogUpdateWithWhereUniqueWithoutCampaignInput | CampaignErrorLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignErrorLogUpdateManyWithWhereWithoutCampaignInput | CampaignErrorLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignErrorLogScalarWhereInput | CampaignErrorLogScalarWhereInput[]
  }

  export type CampaignScheduleUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignScheduleCreateWithoutCampaignInput, CampaignScheduleUncheckedCreateWithoutCampaignInput> | CampaignScheduleCreateWithoutCampaignInput[] | CampaignScheduleUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignScheduleCreateOrConnectWithoutCampaignInput | CampaignScheduleCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignScheduleUpsertWithWhereUniqueWithoutCampaignInput | CampaignScheduleUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignScheduleCreateManyCampaignInputEnvelope
    set?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    disconnect?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    delete?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    connect?: CampaignScheduleWhereUniqueInput | CampaignScheduleWhereUniqueInput[]
    update?: CampaignScheduleUpdateWithWhereUniqueWithoutCampaignInput | CampaignScheduleUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignScheduleUpdateManyWithWhereWithoutCampaignInput | CampaignScheduleUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignScheduleScalarWhereInput | CampaignScheduleScalarWhereInput[]
  }

  export type MessageAnalyticsUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MessageAnalyticsCreateWithoutCampaignInput, MessageAnalyticsUncheckedCreateWithoutCampaignInput> | MessageAnalyticsCreateWithoutCampaignInput[] | MessageAnalyticsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MessageAnalyticsCreateOrConnectWithoutCampaignInput | MessageAnalyticsCreateOrConnectWithoutCampaignInput[]
    upsert?: MessageAnalyticsUpsertWithWhereUniqueWithoutCampaignInput | MessageAnalyticsUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MessageAnalyticsCreateManyCampaignInputEnvelope
    set?: MessageAnalyticsWhereUniqueInput | MessageAnalyticsWhereUniqueInput[]
    disconnect?: MessageAnalyticsWhereUniqueInput | MessageAnalyticsWhereUniqueInput[]
    delete?: MessageAnalyticsWhereUniqueInput | MessageAnalyticsWhereUniqueInput[]
    connect?: MessageAnalyticsWhereUniqueInput | MessageAnalyticsWhereUniqueInput[]
    update?: MessageAnalyticsUpdateWithWhereUniqueWithoutCampaignInput | MessageAnalyticsUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MessageAnalyticsUpdateManyWithWhereWithoutCampaignInput | MessageAnalyticsUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MessageAnalyticsScalarWhereInput | MessageAnalyticsScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<ContactCreateWithoutCampaignsInput, ContactUncheckedCreateWithoutCampaignsInput> | ContactCreateWithoutCampaignsInput[] | ContactUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCampaignsInput | ContactCreateOrConnectWithoutCampaignsInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCampaignsInput | ContactUpsertWithWhereUniqueWithoutCampaignsInput[]
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCampaignsInput | ContactUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCampaignsInput | ContactUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutDispatchesInput = {
    create?: XOR<CampaignCreateWithoutDispatchesInput, CampaignUncheckedCreateWithoutDispatchesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutDispatchesInput
    connect?: CampaignWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutCampaignDispatchesInput = {
    create?: XOR<InstanceCreateWithoutCampaignDispatchesInput, InstanceUncheckedCreateWithoutCampaignDispatchesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutCampaignDispatchesInput
    connect?: InstanceWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutDispatchesNestedInput = {
    create?: XOR<CampaignCreateWithoutDispatchesInput, CampaignUncheckedCreateWithoutDispatchesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutDispatchesInput
    upsert?: CampaignUpsertWithoutDispatchesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutDispatchesInput, CampaignUpdateWithoutDispatchesInput>, CampaignUncheckedUpdateWithoutDispatchesInput>
  }

  export type InstanceUpdateOneRequiredWithoutCampaignDispatchesNestedInput = {
    create?: XOR<InstanceCreateWithoutCampaignDispatchesInput, InstanceUncheckedCreateWithoutCampaignDispatchesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutCampaignDispatchesInput
    upsert?: InstanceUpsertWithoutCampaignDispatchesInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutCampaignDispatchesInput, InstanceUpdateWithoutCampaignDispatchesInput>, InstanceUncheckedUpdateWithoutCampaignDispatchesInput>
  }

  export type CampaignCreateNestedOneWithoutMessagesInput = {
    create?: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessagesInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessagesInput
    upsert?: CampaignUpsertWithoutMessagesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMessagesInput, CampaignUpdateWithoutMessagesInput>, CampaignUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutCampaignLeadInput = {
    create?: XOR<UserCreateWithoutCampaignLeadInput, UserUncheckedCreateWithoutCampaignLeadInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignLeadInput
    connect?: UserWhereUniqueInput
  }

  export type MessageLogCreateNestedManyWithoutCampaignLeadInput = {
    create?: XOR<MessageLogCreateWithoutCampaignLeadInput, MessageLogUncheckedCreateWithoutCampaignLeadInput> | MessageLogCreateWithoutCampaignLeadInput[] | MessageLogUncheckedCreateWithoutCampaignLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignLeadInput | MessageLogCreateOrConnectWithoutCampaignLeadInput[]
    createMany?: MessageLogCreateManyCampaignLeadInputEnvelope
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
  }

  export type CampaignCreateNestedOneWithoutLeadsInput = {
    create?: XOR<CampaignCreateWithoutLeadsInput, CampaignUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLeadsInput
    connect?: CampaignWhereUniqueInput
  }

  export type MessageLogUncheckedCreateNestedManyWithoutCampaignLeadInput = {
    create?: XOR<MessageLogCreateWithoutCampaignLeadInput, MessageLogUncheckedCreateWithoutCampaignLeadInput> | MessageLogCreateWithoutCampaignLeadInput[] | MessageLogUncheckedCreateWithoutCampaignLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignLeadInput | MessageLogCreateOrConnectWithoutCampaignLeadInput[]
    createMany?: MessageLogCreateManyCampaignLeadInputEnvelope
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCampaignLeadNestedInput = {
    create?: XOR<UserCreateWithoutCampaignLeadInput, UserUncheckedCreateWithoutCampaignLeadInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignLeadInput
    upsert?: UserUpsertWithoutCampaignLeadInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignLeadInput, UserUpdateWithoutCampaignLeadInput>, UserUncheckedUpdateWithoutCampaignLeadInput>
  }

  export type MessageLogUpdateManyWithoutCampaignLeadNestedInput = {
    create?: XOR<MessageLogCreateWithoutCampaignLeadInput, MessageLogUncheckedCreateWithoutCampaignLeadInput> | MessageLogCreateWithoutCampaignLeadInput[] | MessageLogUncheckedCreateWithoutCampaignLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignLeadInput | MessageLogCreateOrConnectWithoutCampaignLeadInput[]
    upsert?: MessageLogUpsertWithWhereUniqueWithoutCampaignLeadInput | MessageLogUpsertWithWhereUniqueWithoutCampaignLeadInput[]
    createMany?: MessageLogCreateManyCampaignLeadInputEnvelope
    set?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    disconnect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    delete?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    update?: MessageLogUpdateWithWhereUniqueWithoutCampaignLeadInput | MessageLogUpdateWithWhereUniqueWithoutCampaignLeadInput[]
    updateMany?: MessageLogUpdateManyWithWhereWithoutCampaignLeadInput | MessageLogUpdateManyWithWhereWithoutCampaignLeadInput[]
    deleteMany?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
  }

  export type CampaignUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<CampaignCreateWithoutLeadsInput, CampaignUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLeadsInput
    upsert?: CampaignUpsertWithoutLeadsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutLeadsInput, CampaignUpdateWithoutLeadsInput>, CampaignUncheckedUpdateWithoutLeadsInput>
  }

  export type MessageLogUncheckedUpdateManyWithoutCampaignLeadNestedInput = {
    create?: XOR<MessageLogCreateWithoutCampaignLeadInput, MessageLogUncheckedCreateWithoutCampaignLeadInput> | MessageLogCreateWithoutCampaignLeadInput[] | MessageLogUncheckedCreateWithoutCampaignLeadInput[]
    connectOrCreate?: MessageLogCreateOrConnectWithoutCampaignLeadInput | MessageLogCreateOrConnectWithoutCampaignLeadInput[]
    upsert?: MessageLogUpsertWithWhereUniqueWithoutCampaignLeadInput | MessageLogUpsertWithWhereUniqueWithoutCampaignLeadInput[]
    createMany?: MessageLogCreateManyCampaignLeadInputEnvelope
    set?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    disconnect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    delete?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    connect?: MessageLogWhereUniqueInput | MessageLogWhereUniqueInput[]
    update?: MessageLogUpdateWithWhereUniqueWithoutCampaignLeadInput | MessageLogUpdateWithWhereUniqueWithoutCampaignLeadInput[]
    updateMany?: MessageLogUpdateManyWithWhereWithoutCampaignLeadInput | MessageLogUpdateManyWithWhereWithoutCampaignLeadInput[]
    deleteMany?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutCampaignScheduleInput = {
    create?: XOR<CampaignCreateWithoutCampaignScheduleInput, CampaignUncheckedCreateWithoutCampaignScheduleInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaignScheduleInput
    connect?: CampaignWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutCampaignSchedulesInput = {
    create?: XOR<InstanceCreateWithoutCampaignSchedulesInput, InstanceUncheckedCreateWithoutCampaignSchedulesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutCampaignSchedulesInput
    connect?: InstanceWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutCampaignScheduleNestedInput = {
    create?: XOR<CampaignCreateWithoutCampaignScheduleInput, CampaignUncheckedCreateWithoutCampaignScheduleInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaignScheduleInput
    upsert?: CampaignUpsertWithoutCampaignScheduleInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCampaignScheduleInput, CampaignUpdateWithoutCampaignScheduleInput>, CampaignUncheckedUpdateWithoutCampaignScheduleInput>
  }

  export type InstanceUpdateOneRequiredWithoutCampaignSchedulesNestedInput = {
    create?: XOR<InstanceCreateWithoutCampaignSchedulesInput, InstanceUncheckedCreateWithoutCampaignSchedulesInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutCampaignSchedulesInput
    upsert?: InstanceUpsertWithoutCampaignSchedulesInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutCampaignSchedulesInput, InstanceUpdateWithoutCampaignSchedulesInput>, InstanceUncheckedUpdateWithoutCampaignSchedulesInput>
  }

  export type CampaignCreateNestedOneWithoutStatisticsInput = {
    create?: XOR<CampaignCreateWithoutStatisticsInput, CampaignUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutStatisticsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutStatisticsNestedInput = {
    create?: XOR<CampaignCreateWithoutStatisticsInput, CampaignUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutStatisticsInput
    upsert?: CampaignUpsertWithoutStatisticsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutStatisticsInput, CampaignUpdateWithoutStatisticsInput>, CampaignUncheckedUpdateWithoutStatisticsInput>
  }

  export type MessageLogCreatestatusHistoryInput = {
    set: InputJsonValue[]
  }

  export type CampaignCreateNestedOneWithoutMessageLogInput = {
    create?: XOR<CampaignCreateWithoutMessageLogInput, CampaignUncheckedCreateWithoutMessageLogInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessageLogInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignLeadCreateNestedOneWithoutMessageLogsInput = {
    create?: XOR<CampaignLeadCreateWithoutMessageLogsInput, CampaignLeadUncheckedCreateWithoutMessageLogsInput>
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutMessageLogsInput
    connect?: CampaignLeadWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutMessageLogInput = {
    create?: XOR<LeadCreateWithoutMessageLogInput, LeadUncheckedCreateWithoutMessageLogInput>
    connectOrCreate?: LeadCreateOrConnectWithoutMessageLogInput
    connect?: LeadWhereUniqueInput
  }

  export type MessageLogUpdatestatusHistoryInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type CampaignUpdateOneRequiredWithoutMessageLogNestedInput = {
    create?: XOR<CampaignCreateWithoutMessageLogInput, CampaignUncheckedCreateWithoutMessageLogInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessageLogInput
    upsert?: CampaignUpsertWithoutMessageLogInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMessageLogInput, CampaignUpdateWithoutMessageLogInput>, CampaignUncheckedUpdateWithoutMessageLogInput>
  }

  export type CampaignLeadUpdateOneRequiredWithoutMessageLogsNestedInput = {
    create?: XOR<CampaignLeadCreateWithoutMessageLogsInput, CampaignLeadUncheckedCreateWithoutMessageLogsInput>
    connectOrCreate?: CampaignLeadCreateOrConnectWithoutMessageLogsInput
    upsert?: CampaignLeadUpsertWithoutMessageLogsInput
    connect?: CampaignLeadWhereUniqueInput
    update?: XOR<XOR<CampaignLeadUpdateToOneWithWhereWithoutMessageLogsInput, CampaignLeadUpdateWithoutMessageLogsInput>, CampaignLeadUncheckedUpdateWithoutMessageLogsInput>
  }

  export type LeadUpdateOneWithoutMessageLogNestedInput = {
    create?: XOR<LeadCreateWithoutMessageLogInput, LeadUncheckedCreateWithoutMessageLogInput>
    connectOrCreate?: LeadCreateOrConnectWithoutMessageLogInput
    upsert?: LeadUpsertWithoutMessageLogInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutMessageLogInput, LeadUpdateWithoutMessageLogInput>, LeadUncheckedUpdateWithoutMessageLogInput>
  }

  export type CampaignCreateNestedOneWithoutMessageAnalyticsInput = {
    create?: XOR<CampaignCreateWithoutMessageAnalyticsInput, CampaignUncheckedCreateWithoutMessageAnalyticsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessageAnalyticsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutMessageAnalyticsNestedInput = {
    create?: XOR<CampaignCreateWithoutMessageAnalyticsInput, CampaignUncheckedCreateWithoutMessageAnalyticsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMessageAnalyticsInput
    upsert?: CampaignUpsertWithoutMessageAnalyticsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMessageAnalyticsInput, CampaignUpdateWithoutMessageAnalyticsInput>, CampaignUncheckedUpdateWithoutMessageAnalyticsInput>
  }

  export type ContactCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutContactsInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutContactsInput = {
    create?: XOR<CampaignCreateWithoutContactsInput, CampaignUncheckedCreateWithoutContactsInput> | CampaignCreateWithoutContactsInput[] | CampaignUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutContactsInput | CampaignCreateOrConnectWithoutContactsInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutContactInput = {
    create?: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput> | ConversationCreateWithoutContactInput[] | ConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutContactInput | ConversationCreateOrConnectWithoutContactInput[]
    createMany?: ConversationCreateManyContactInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ContactNoteCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactNoteCreateWithoutContactInput, ContactNoteUncheckedCreateWithoutContactInput> | ContactNoteCreateWithoutContactInput[] | ContactNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutContactInput | ContactNoteCreateOrConnectWithoutContactInput[]
    createMany?: ContactNoteCreateManyContactInputEnvelope
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutContactsInput = {
    create?: XOR<CampaignCreateWithoutContactsInput, CampaignUncheckedCreateWithoutContactsInput> | CampaignCreateWithoutContactsInput[] | CampaignUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutContactsInput | CampaignCreateOrConnectWithoutContactsInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput> | ConversationCreateWithoutContactInput[] | ConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutContactInput | ConversationCreateOrConnectWithoutContactInput[]
    createMany?: ConversationCreateManyContactInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ContactNoteUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactNoteCreateWithoutContactInput, ContactNoteUncheckedCreateWithoutContactInput> | ContactNoteCreateWithoutContactInput[] | ContactNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutContactInput | ContactNoteCreateOrConnectWithoutContactInput[]
    createMany?: ContactNoteCreateManyContactInputEnvelope
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
  }

  export type ContactUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    upsert?: UserUpsertWithoutContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactsInput, UserUpdateWithoutContactsInput>, UserUncheckedUpdateWithoutContactsInput>
  }

  export type CampaignUpdateManyWithoutContactsNestedInput = {
    create?: XOR<CampaignCreateWithoutContactsInput, CampaignUncheckedCreateWithoutContactsInput> | CampaignCreateWithoutContactsInput[] | CampaignUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutContactsInput | CampaignCreateOrConnectWithoutContactsInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutContactsInput | CampaignUpsertWithWhereUniqueWithoutContactsInput[]
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutContactsInput | CampaignUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutContactsInput | CampaignUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutContactNestedInput = {
    create?: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput> | ConversationCreateWithoutContactInput[] | ConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutContactInput | ConversationCreateOrConnectWithoutContactInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutContactInput | ConversationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ConversationCreateManyContactInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutContactInput | ConversationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutContactInput | ConversationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ContactNoteUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactNoteCreateWithoutContactInput, ContactNoteUncheckedCreateWithoutContactInput> | ContactNoteCreateWithoutContactInput[] | ContactNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutContactInput | ContactNoteCreateOrConnectWithoutContactInput[]
    upsert?: ContactNoteUpsertWithWhereUniqueWithoutContactInput | ContactNoteUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactNoteCreateManyContactInputEnvelope
    set?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    disconnect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    delete?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    update?: ContactNoteUpdateWithWhereUniqueWithoutContactInput | ContactNoteUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactNoteUpdateManyWithWhereWithoutContactInput | ContactNoteUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutContactsNestedInput = {
    create?: XOR<CampaignCreateWithoutContactsInput, CampaignUncheckedCreateWithoutContactsInput> | CampaignCreateWithoutContactsInput[] | CampaignUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutContactsInput | CampaignCreateOrConnectWithoutContactsInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutContactsInput | CampaignUpsertWithWhereUniqueWithoutContactsInput[]
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutContactsInput | CampaignUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutContactsInput | CampaignUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput> | ConversationCreateWithoutContactInput[] | ConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutContactInput | ConversationCreateOrConnectWithoutContactInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutContactInput | ConversationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ConversationCreateManyContactInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutContactInput | ConversationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutContactInput | ConversationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ContactNoteUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactNoteCreateWithoutContactInput, ContactNoteUncheckedCreateWithoutContactInput> | ContactNoteCreateWithoutContactInput[] | ContactNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactNoteCreateOrConnectWithoutContactInput | ContactNoteCreateOrConnectWithoutContactInput[]
    upsert?: ContactNoteUpsertWithWhereUniqueWithoutContactInput | ContactNoteUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactNoteCreateManyContactInputEnvelope
    set?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    disconnect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    delete?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    connect?: ContactNoteWhereUniqueInput | ContactNoteWhereUniqueInput[]
    update?: ContactNoteUpdateWithWhereUniqueWithoutContactInput | ContactNoteUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactNoteUpdateManyWithWhereWithoutContactInput | ContactNoteUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ContactCreateNestedOneWithoutConversationsInput = {
    create?: XOR<ContactCreateWithoutConversationsInput, ContactUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutConversationsInput
    connect?: ContactWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationInput = {
    create?: XOR<UserCreateWithoutConversationInput, UserUncheckedCreateWithoutConversationInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationInput
    connect?: UserWhereUniqueInput
  }

  export type MessageReactionCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageReactionCreateWithoutConversationInput, MessageReactionUncheckedCreateWithoutConversationInput> | MessageReactionCreateWithoutConversationInput[] | MessageReactionUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutConversationInput | MessageReactionCreateOrConnectWithoutConversationInput[]
    createMany?: MessageReactionCreateManyConversationInputEnvelope
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageReactionUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageReactionCreateWithoutConversationInput, MessageReactionUncheckedCreateWithoutConversationInput> | MessageReactionCreateWithoutConversationInput[] | MessageReactionUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutConversationInput | MessageReactionCreateOrConnectWithoutConversationInput[]
    createMany?: MessageReactionCreateManyConversationInputEnvelope
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ContactUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<ContactCreateWithoutConversationsInput, ContactUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutConversationsInput
    upsert?: ContactUpsertWithoutConversationsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutConversationsInput, ContactUpdateWithoutConversationsInput>, ContactUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateOneRequiredWithoutConversationNestedInput = {
    create?: XOR<UserCreateWithoutConversationInput, UserUncheckedCreateWithoutConversationInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationInput
    upsert?: UserUpsertWithoutConversationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationInput, UserUpdateWithoutConversationInput>, UserUncheckedUpdateWithoutConversationInput>
  }

  export type MessageReactionUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageReactionCreateWithoutConversationInput, MessageReactionUncheckedCreateWithoutConversationInput> | MessageReactionCreateWithoutConversationInput[] | MessageReactionUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutConversationInput | MessageReactionCreateOrConnectWithoutConversationInput[]
    upsert?: MessageReactionUpsertWithWhereUniqueWithoutConversationInput | MessageReactionUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageReactionCreateManyConversationInputEnvelope
    set?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    disconnect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    delete?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    update?: MessageReactionUpdateWithWhereUniqueWithoutConversationInput | MessageReactionUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageReactionUpdateManyWithWhereWithoutConversationInput | MessageReactionUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageReactionUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageReactionCreateWithoutConversationInput, MessageReactionUncheckedCreateWithoutConversationInput> | MessageReactionCreateWithoutConversationInput[] | MessageReactionUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutConversationInput | MessageReactionCreateOrConnectWithoutConversationInput[]
    upsert?: MessageReactionUpsertWithWhereUniqueWithoutConversationInput | MessageReactionUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageReactionCreateManyConversationInputEnvelope
    set?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    disconnect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    delete?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    update?: MessageReactionUpdateWithWhereUniqueWithoutConversationInput | MessageReactionUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageReactionUpdateManyWithWhereWithoutConversationInput | MessageReactionUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageInput = {
    create?: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageInput
    connect?: UserWhereUniqueInput
  }

  export type MessageAttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type EnumMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.MessageStatus
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessageNestedInput = {
    create?: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageInput
    upsert?: UserUpsertWithoutMessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageInput, UserUpdateWithoutMessageInput>, UserUncheckedUpdateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    upsert?: MessageUpsertWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAttachmentsInput, MessageUpdateWithoutAttachmentsInput>, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CampaignCreateNestedOneWithoutCampaignErrorLogInput = {
    create?: XOR<CampaignCreateWithoutCampaignErrorLogInput, CampaignUncheckedCreateWithoutCampaignErrorLogInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaignErrorLogInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutCampaignErrorLogNestedInput = {
    create?: XOR<CampaignCreateWithoutCampaignErrorLogInput, CampaignUncheckedCreateWithoutCampaignErrorLogInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaignErrorLogInput
    upsert?: CampaignUpsertWithoutCampaignErrorLogInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCampaignErrorLogInput, CampaignUpdateWithoutCampaignErrorLogInput>, CampaignUncheckedUpdateWithoutCampaignErrorLogInput>
  }

  export type ContactCreateNestedOneWithoutContactNotesInput = {
    create?: XOR<ContactCreateWithoutContactNotesInput, ContactUncheckedCreateWithoutContactNotesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutContactNotesInput
    connect?: ContactWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutContactNotesInput = {
    create?: XOR<UserCreateWithoutContactNotesInput, UserUncheckedCreateWithoutContactNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactNotesInput
    connect?: UserWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutContactNotesNestedInput = {
    create?: XOR<ContactCreateWithoutContactNotesInput, ContactUncheckedCreateWithoutContactNotesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutContactNotesInput
    upsert?: ContactUpsertWithoutContactNotesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutContactNotesInput, ContactUpdateWithoutContactNotesInput>, ContactUncheckedUpdateWithoutContactNotesInput>
  }

  export type UserUpdateOneRequiredWithoutContactNotesNestedInput = {
    create?: XOR<UserCreateWithoutContactNotesInput, UserUncheckedCreateWithoutContactNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactNotesInput
    upsert?: UserUpsertWithoutContactNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactNotesInput, UserUpdateWithoutContactNotesInput>, UserUncheckedUpdateWithoutContactNotesInput>
  }

  export type ConversationCreateNestedOneWithoutMessageReactionInput = {
    create?: XOR<ConversationCreateWithoutMessageReactionInput, ConversationUncheckedCreateWithoutMessageReactionInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessageReactionInput
    connect?: ConversationWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessageReactionNestedInput = {
    create?: XOR<ConversationCreateWithoutMessageReactionInput, ConversationUncheckedCreateWithoutMessageReactionInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessageReactionInput
    upsert?: ConversationUpsertWithoutMessageReactionInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessageReactionInput, ConversationUpdateWithoutMessageReactionInput>, ConversationUncheckedUpdateWithoutMessageReactionInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumInstanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstanceStatus | EnumInstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstanceStatus[] | ListEnumInstanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstanceStatus[] | ListEnumInstanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstanceStatusFilter<$PrismaModel> | $Enums.InstanceStatus
  }

  export type NestedEnumInstanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstanceStatus | EnumInstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstanceStatus[] | ListEnumInstanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstanceStatus[] | ListEnumInstanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstanceStatusFilter<$PrismaModel>
    _max?: NestedEnumInstanceStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutUserInput
    affiliate?: UserCreateNestedOneWithoutAffiliatesInput
    affiliates?: UserCreateNestedManyWithoutAffiliateInput
    Message?: MessageCreateNestedManyWithoutUserInput
    Conversation?: ConversationCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutUserInput
    affiliates?: UserUncheckedCreateNestedManyWithoutAffiliateInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    Conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompaniesUnitesCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    leads?: LeadCreateNestedManyWithoutConfigInput
  }

  export type CompaniesUnitesUncheckedCreateWithoutCompanyInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    leads?: LeadUncheckedCreateNestedManyWithoutConfigInput
  }

  export type CompaniesUnitesCreateOrConnectWithoutCompanyInput = {
    where: CompaniesUnitesWhereUniqueInput
    create: XOR<CompaniesUnitesCreateWithoutCompanyInput, CompaniesUnitesUncheckedCreateWithoutCompanyInput>
  }

  export type CompaniesUnitesCreateManyCompanyInputEnvelope = {
    data: CompaniesUnitesCreateManyCompanyInput | CompaniesUnitesCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    profile?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionStatus?: StringNullableFilter<"User"> | string | null
    active?: BoolNullableFilter<"User"> | boolean | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    whatleadCompanyId?: StringFilter<"User"> | string
    plan?: StringFilter<"User"> | string
    status?: BoolFilter<"User"> | boolean
    maxInstances?: IntFilter<"User"> | number
    messagesPerDay?: IntFilter<"User"> | number
    features?: StringNullableListFilter<"User">
    support?: StringFilter<"User"> | string
    trialEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    referredBy?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
  }

  export type CompaniesUnitesUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompaniesUnitesWhereUniqueInput
    update: XOR<CompaniesUnitesUpdateWithoutCompanyInput, CompaniesUnitesUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompaniesUnitesCreateWithoutCompanyInput, CompaniesUnitesUncheckedCreateWithoutCompanyInput>
  }

  export type CompaniesUnitesUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompaniesUnitesWhereUniqueInput
    data: XOR<CompaniesUnitesUpdateWithoutCompanyInput, CompaniesUnitesUncheckedUpdateWithoutCompanyInput>
  }

  export type CompaniesUnitesUpdateManyWithWhereWithoutCompanyInput = {
    where: CompaniesUnitesScalarWhereInput
    data: XOR<CompaniesUnitesUpdateManyMutationInput, CompaniesUnitesUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompaniesUnitesScalarWhereInput = {
    AND?: CompaniesUnitesScalarWhereInput | CompaniesUnitesScalarWhereInput[]
    OR?: CompaniesUnitesScalarWhereInput[]
    NOT?: CompaniesUnitesScalarWhereInput | CompaniesUnitesScalarWhereInput[]
    id?: StringFilter<"CompaniesUnites"> | string
    createdAt?: DateTimeNullableFilter<"CompaniesUnites"> | Date | string | null
    name?: StringNullableFilter<"CompaniesUnites"> | string | null
    productdefault?: StringNullableFilter<"CompaniesUnites"> | string | null
    campaignstatus?: StringNullableFilter<"CompaniesUnites"> | string | null
    enablecuration?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabletosendustolead?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabled?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    isconversationia?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    campaignnumberbusiness?: StringNullableFilter<"CompaniesUnites"> | string | null
    whatsappprovider?: StringNullableFilter<"CompaniesUnites"> | string | null
    enabletosendprovider?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    enabletosecondcallprovider?: BoolNullableFilter<"CompaniesUnites"> | boolean | null
    integrationconfiguration?: JsonNullableFilter<"CompaniesUnites">
    integrationname?: StringNullableFilter<"CompaniesUnites"> | string | null
    templatelistvars?: JsonNullableListFilter<"CompaniesUnites">
    metaconfiguration?: JsonNullableFilter<"CompaniesUnites">
    messageperruns?: JsonNullableListFilter<"CompaniesUnites">
    notifyconfiguration?: JsonNullableFilter<"CompaniesUnites">
    updatedAt?: DateTimeNullableFilter<"CompaniesUnites"> | Date | string | null
    whitelabel_config?: StringFilter<"CompaniesUnites"> | string
    whatleadCompanyId?: StringNullableFilter<"CompaniesUnites"> | string | null
  }

  export type InstanceCreateWithoutUserInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignCreateNestedManyWithoutInstanceInput
    campaignSchedules?: CampaignScheduleCreateNestedManyWithoutInstanceInput
    campaignDispatches?: CampaignDispatchCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutInstanceInput
    mediaStats?: MediaStatsCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutUserInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedCreateNestedManyWithoutInstanceInput
    campaignSchedules?: CampaignScheduleUncheckedCreateNestedManyWithoutInstanceInput
    campaignDispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutInstanceInput
    mediaStats?: MediaStatsUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutUserInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput>
  }

  export type InstanceCreateManyUserInputEnvelope = {
    data: InstanceCreateManyUserInput | InstanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    dueDate: Date | string
    customerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: string | null
    disputeReason?: string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    dueDate: Date | string
    customerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: string | null
    disputeReason?: string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WarmupStatsCreateWithoutUserInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutWarmupStatsInput
    mediaReceived?: MediaStatsCreateNestedOneWithoutWarmupStatsReceivedInput
    mediaStats?: MediaStatsCreateNestedOneWithoutWarmupStatsSentInput
  }

  export type WarmupStatsUncheckedCreateWithoutUserInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
    mediaReceivedId?: string | null
  }

  export type WarmupStatsCreateOrConnectWithoutUserInput = {
    where: WarmupStatsWhereUniqueInput
    create: XOR<WarmupStatsCreateWithoutUserInput, WarmupStatsUncheckedCreateWithoutUserInput>
  }

  export type WarmupStatsCreateManyUserInputEnvelope = {
    data: WarmupStatsCreateManyUserInput | WarmupStatsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchCreateNestedManyWithoutCampaignInput
    instance?: InstanceCreateNestedOneWithoutCampaignsInput
    CampaignErrorLog?: CampaignErrorLogCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsCreateNestedManyWithoutCampaignInput
    contacts?: ContactCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutCampaignInput
    CampaignErrorLog?: CampaignErrorLogUncheckedCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleUncheckedCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsUncheckedCreateNestedManyWithoutCampaignInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignCreateOrConnectWithoutUserInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignCreateManyUserInputEnvelope = {
    data: CampaignCreateManyUserInput | CampaignCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutWhatleadUserInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadparceiroconfigs?: CompaniesUnitesCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutWhatleadUserInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadparceiroconfigs?: CompaniesUnitesUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutWhatleadUserInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutWhatleadUserInput, CompanyUncheckedCreateWithoutWhatleadUserInput>
  }

  export type CampaignLeadCreateWithoutUserInput = {
    id?: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    segment?: string | null
    engagement?: string | null
    syncedWithCRM?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messageLogs?: MessageLogCreateNestedManyWithoutCampaignLeadInput
    campaign: CampaignCreateNestedOneWithoutLeadsInput
  }

  export type CampaignLeadUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    segment?: string | null
    engagement?: string | null
    syncedWithCRM?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messageLogs?: MessageLogUncheckedCreateNestedManyWithoutCampaignLeadInput
  }

  export type CampaignLeadCreateOrConnectWithoutUserInput = {
    where: CampaignLeadWhereUniqueInput
    create: XOR<CampaignLeadCreateWithoutUserInput, CampaignLeadUncheckedCreateWithoutUserInput>
  }

  export type CampaignLeadCreateManyUserInputEnvelope = {
    data: CampaignLeadCreateManyUserInput | CampaignLeadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAffiliatesInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutUserInput
    affiliate?: UserCreateNestedOneWithoutAffiliatesInput
    Message?: MessageCreateNestedManyWithoutUserInput
    Conversation?: ConversationCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAffiliatesInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    Conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAffiliatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAffiliatesInput, UserUncheckedCreateWithoutAffiliatesInput>
  }

  export type UserCreateWithoutAffiliateInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutUserInput
    affiliates?: UserCreateNestedManyWithoutAffiliateInput
    Message?: MessageCreateNestedManyWithoutUserInput
    Conversation?: ConversationCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAffiliateInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutUserInput
    affiliates?: UserUncheckedCreateNestedManyWithoutAffiliateInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    Conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAffiliateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAffiliateInput, UserUncheckedCreateWithoutAffiliateInput>
  }

  export type UserCreateManyAffiliateInputEnvelope = {
    data: UserCreateManyAffiliateInput | UserCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUserInput = {
    id?: string
    messageId: string
    content: string
    type?: string
    sender: string
    status?: $Enums.MessageStatus
    timestamp: Date | string
    mediaUrl?: string | null
    mediaType?: string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId: string
    messageId: string
    content: string
    type?: string
    sender: string
    status?: $Enums.MessageStatus
    timestamp: Date | string
    mediaUrl?: string | null
    mediaType?: string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateManyUserInputEnvelope = {
    data: MessageCreateManyUserInput | MessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUserInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    contact?: ContactCreateNestedOneWithoutConversationsInput
    MessageReaction?: MessageReactionCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUserInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    contactId?: string | null
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    MessageReaction?: MessageReactionUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUserInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationCreateManyUserInputEnvelope = {
    data: ConversationCreateManyUserInput | ConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutUserInput = {
    id?: string
    phone: string
    name?: string | null
    email?: string | null
    company?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    lastInteractionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    source?: string | null
    campaigns?: CampaignCreateNestedManyWithoutContactsInput
    conversations?: ConversationCreateNestedManyWithoutContactInput
    contactNotes?: ContactNoteCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutUserInput = {
    id?: string
    phone: string
    name?: string | null
    email?: string | null
    company?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    lastInteractionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    source?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutContactsInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutUserInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput>
  }

  export type ContactCreateManyUserInputEnvelope = {
    data: ContactCreateManyUserInput | ContactCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactNoteCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutContactNotesInput
  }

  export type ContactNoteUncheckedCreateWithoutUserInput = {
    id?: string
    contactId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactNoteCreateOrConnectWithoutUserInput = {
    where: ContactNoteWhereUniqueInput
    create: XOR<ContactNoteCreateWithoutUserInput, ContactNoteUncheckedCreateWithoutUserInput>
  }

  export type ContactNoteCreateManyUserInputEnvelope = {
    data: ContactNoteCreateManyUserInput | ContactNoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InstanceUpsertWithWhereUniqueWithoutUserInput = {
    where: InstanceWhereUniqueInput
    update: XOR<InstanceUpdateWithoutUserInput, InstanceUncheckedUpdateWithoutUserInput>
    create: XOR<InstanceCreateWithoutUserInput, InstanceUncheckedCreateWithoutUserInput>
  }

  export type InstanceUpdateWithWhereUniqueWithoutUserInput = {
    where: InstanceWhereUniqueInput
    data: XOR<InstanceUpdateWithoutUserInput, InstanceUncheckedUpdateWithoutUserInput>
  }

  export type InstanceUpdateManyWithWhereWithoutUserInput = {
    where: InstanceScalarWhereInput
    data: XOR<InstanceUpdateManyMutationInput, InstanceUncheckedUpdateManyWithoutUserInput>
  }

  export type InstanceScalarWhereInput = {
    AND?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
    OR?: InstanceScalarWhereInput[]
    NOT?: InstanceScalarWhereInput | InstanceScalarWhereInput[]
    id?: StringFilter<"Instance"> | string
    instanceName?: StringFilter<"Instance"> | string
    connectionStatus?: EnumInstanceStatusFilter<"Instance"> | $Enums.InstanceStatus
    number?: StringNullableFilter<"Instance"> | string | null
    ownerJid?: StringNullableFilter<"Instance"> | string | null
    profilePicUrl?: StringNullableFilter<"Instance"> | string | null
    integration?: StringFilter<"Instance"> | string
    token?: StringNullableFilter<"Instance"> | string | null
    clientName?: StringNullableFilter<"Instance"> | string | null
    profileName?: StringNullableFilter<"Instance"> | string | null
    userId?: StringFilter<"Instance"> | string
    createdAt?: DateTimeFilter<"Instance"> | Date | string
    updatedAt?: DateTimeFilter<"Instance"> | Date | string
    disconnectedAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    disconnectionObject?: JsonNullableFilter<"Instance">
    disconnectionReasonCode?: StringNullableFilter<"Instance"> | string | null
    proxyConfig?: JsonNullableFilter<"Instance">
    typebot?: JsonNullableFilter<"Instance">
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    stripePaymentId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    dueDate?: DateTimeFilter<"Payment"> | Date | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    disputeStatus?: StringNullableFilter<"Payment"> | string | null
    disputeReason?: StringNullableFilter<"Payment"> | string | null
    cancelReason?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    userId?: StringNullableFilter<"Payment"> | string | null
  }

  export type WarmupStatsUpsertWithWhereUniqueWithoutUserInput = {
    where: WarmupStatsWhereUniqueInput
    update: XOR<WarmupStatsUpdateWithoutUserInput, WarmupStatsUncheckedUpdateWithoutUserInput>
    create: XOR<WarmupStatsCreateWithoutUserInput, WarmupStatsUncheckedCreateWithoutUserInput>
  }

  export type WarmupStatsUpdateWithWhereUniqueWithoutUserInput = {
    where: WarmupStatsWhereUniqueInput
    data: XOR<WarmupStatsUpdateWithoutUserInput, WarmupStatsUncheckedUpdateWithoutUserInput>
  }

  export type WarmupStatsUpdateManyWithWhereWithoutUserInput = {
    where: WarmupStatsScalarWhereInput
    data: XOR<WarmupStatsUpdateManyMutationInput, WarmupStatsUncheckedUpdateManyWithoutUserInput>
  }

  export type WarmupStatsScalarWhereInput = {
    AND?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
    OR?: WarmupStatsScalarWhereInput[]
    NOT?: WarmupStatsScalarWhereInput | WarmupStatsScalarWhereInput[]
    id?: StringFilter<"WarmupStats"> | string
    instanceName?: StringFilter<"WarmupStats"> | string
    status?: StringFilter<"WarmupStats"> | string
    messagesSent?: IntFilter<"WarmupStats"> | number
    messagesReceived?: IntFilter<"WarmupStats"> | number
    warmupTime?: IntFilter<"WarmupStats"> | number
    lastActive?: DateTimeFilter<"WarmupStats"> | Date | string
    startTime?: DateTimeNullableFilter<"WarmupStats"> | Date | string | null
    pauseTime?: DateTimeNullableFilter<"WarmupStats"> | Date | string | null
    progress?: IntFilter<"WarmupStats"> | number
    userId?: StringFilter<"WarmupStats"> | string
    createdAt?: DateTimeFilter<"WarmupStats"> | Date | string
    updatedAt?: DateTimeFilter<"WarmupStats"> | Date | string
    mediaStatsId?: StringNullableFilter<"WarmupStats"> | string | null
    mediaReceivedId?: StringNullableFilter<"WarmupStats"> | string | null
  }

  export type CampaignUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
  }

  export type CampaignUpdateManyWithWhereWithoutUserInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    status?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    message?: StringNullableFilter<"Campaign"> | string | null
    mediaUrl?: StringNullableFilter<"Campaign"> | string | null
    mediaType?: StringNullableFilter<"Campaign"> | string | null
    mediaCaption?: StringNullableFilter<"Campaign"> | string | null
    scheduledDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    scheduledStatus?: StringNullableFilter<"Campaign"> | string | null
    startedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    progress?: IntFilter<"Campaign"> | number
    minDelay?: IntFilter<"Campaign"> | number
    maxDelay?: IntFilter<"Campaign"> | number
    userId?: StringFilter<"Campaign"> | string
    instanceId?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    isAiResponder?: JsonNullableFilter<"Campaign">
  }

  export type CompanyUpsertWithoutWhatleadUserInput = {
    update: XOR<CompanyUpdateWithoutWhatleadUserInput, CompanyUncheckedUpdateWithoutWhatleadUserInput>
    create: XOR<CompanyCreateWithoutWhatleadUserInput, CompanyUncheckedCreateWithoutWhatleadUserInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutWhatleadUserInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutWhatleadUserInput, CompanyUncheckedUpdateWithoutWhatleadUserInput>
  }

  export type CompanyUpdateWithoutWhatleadUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadparceiroconfigs?: CompaniesUnitesUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutWhatleadUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadparceiroconfigs?: CompaniesUnitesUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CampaignLeadUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignLeadWhereUniqueInput
    update: XOR<CampaignLeadUpdateWithoutUserInput, CampaignLeadUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignLeadCreateWithoutUserInput, CampaignLeadUncheckedCreateWithoutUserInput>
  }

  export type CampaignLeadUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignLeadWhereUniqueInput
    data: XOR<CampaignLeadUpdateWithoutUserInput, CampaignLeadUncheckedUpdateWithoutUserInput>
  }

  export type CampaignLeadUpdateManyWithWhereWithoutUserInput = {
    where: CampaignLeadScalarWhereInput
    data: XOR<CampaignLeadUpdateManyMutationInput, CampaignLeadUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignLeadScalarWhereInput = {
    AND?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
    OR?: CampaignLeadScalarWhereInput[]
    NOT?: CampaignLeadScalarWhereInput | CampaignLeadScalarWhereInput[]
    id?: StringFilter<"CampaignLead"> | string
    userId?: StringFilter<"CampaignLead"> | string
    campaignId?: StringFilter<"CampaignLead"> | string
    name?: StringNullableFilter<"CampaignLead"> | string | null
    phone?: StringFilter<"CampaignLead"> | string
    status?: StringFilter<"CampaignLead"> | string
    sentAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    readAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    failureReason?: StringNullableFilter<"CampaignLead"> | string | null
    messageId?: StringNullableFilter<"CampaignLead"> | string | null
    segment?: StringNullableFilter<"CampaignLead"> | string | null
    engagement?: StringNullableFilter<"CampaignLead"> | string | null
    syncedWithCRM?: BoolFilter<"CampaignLead"> | boolean
    syncedAt?: DateTimeNullableFilter<"CampaignLead"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignLead"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignLead"> | Date | string
  }

  export type UserUpsertWithoutAffiliatesInput = {
    update: XOR<UserUpdateWithoutAffiliatesInput, UserUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<UserCreateWithoutAffiliatesInput, UserUncheckedCreateWithoutAffiliatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAffiliatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAffiliatesInput, UserUncheckedUpdateWithoutAffiliatesInput>
  }

  export type UserUpdateWithoutAffiliatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutUserNestedInput
    affiliate?: UserUpdateOneWithoutAffiliatesNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAffiliatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAffiliateInput, UserUncheckedUpdateWithoutAffiliateInput>
    create: XOR<UserCreateWithoutAffiliateInput, UserUncheckedCreateWithoutAffiliateInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAffiliateInput, UserUncheckedUpdateWithoutAffiliateInput>
  }

  export type UserUpdateManyWithWhereWithoutAffiliateInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    messageId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    sender?: StringFilter<"Message"> | string
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    timestamp?: DateTimeFilter<"Message"> | Date | string
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    mediaType?: StringNullableFilter<"Message"> | string | null
    replyTo?: JsonNullableFilter<"Message">
    userId?: StringFilter<"Message"> | string
    failureReason?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
  }

  export type ConversationUpdateManyWithWhereWithoutUserInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    instanceName?: StringFilter<"Conversation"> | string
    contactPhone?: StringFilter<"Conversation"> | string
    contactName?: StringNullableFilter<"Conversation"> | string | null
    contactAvatar?: StringNullableFilter<"Conversation"> | string | null
    lastMessageAt?: DateTimeFilter<"Conversation"> | Date | string
    status?: StringFilter<"Conversation"> | string
    tags?: JsonFilter<"Conversation">
    isActive?: BoolFilter<"Conversation"> | boolean
    contactId?: StringNullableFilter<"Conversation"> | string | null
    userId?: StringFilter<"Conversation"> | string
    isGroup?: BoolFilter<"Conversation"> | boolean
    groupMetadata?: JsonNullableFilter<"Conversation">
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutUserInput, ContactUncheckedUpdateWithoutUserInput>
    create: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutUserInput, ContactUncheckedUpdateWithoutUserInput>
  }

  export type ContactUpdateManyWithWhereWithoutUserInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutUserInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    phone?: StringFilter<"Contact"> | string
    name?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    tags?: StringNullableListFilter<"Contact">
    userId?: StringFilter<"Contact"> | string
    lastInteractionAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    source?: StringNullableFilter<"Contact"> | string | null
  }

  export type ContactNoteUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactNoteWhereUniqueInput
    update: XOR<ContactNoteUpdateWithoutUserInput, ContactNoteUncheckedUpdateWithoutUserInput>
    create: XOR<ContactNoteCreateWithoutUserInput, ContactNoteUncheckedCreateWithoutUserInput>
  }

  export type ContactNoteUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactNoteWhereUniqueInput
    data: XOR<ContactNoteUpdateWithoutUserInput, ContactNoteUncheckedUpdateWithoutUserInput>
  }

  export type ContactNoteUpdateManyWithWhereWithoutUserInput = {
    where: ContactNoteScalarWhereInput
    data: XOR<ContactNoteUpdateManyMutationInput, ContactNoteUncheckedUpdateManyWithoutUserInput>
  }

  export type ContactNoteScalarWhereInput = {
    AND?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
    OR?: ContactNoteScalarWhereInput[]
    NOT?: ContactNoteScalarWhereInput | ContactNoteScalarWhereInput[]
    id?: StringFilter<"ContactNote"> | string
    contactId?: StringFilter<"ContactNote"> | string
    content?: StringFilter<"ContactNote"> | string
    createdAt?: DateTimeFilter<"ContactNote"> | Date | string
    updatedAt?: DateTimeFilter<"ContactNote"> | Date | string
    userId?: StringFilter<"ContactNote"> | string
  }

  export type LeadCreateWithoutConfigInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string
    updatedat?: Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutConfigInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string
    updatedat?: Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutConfigInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutConfigInput, LeadUncheckedCreateWithoutConfigInput>
  }

  export type LeadCreateManyConfigInputEnvelope = {
    data: LeadCreateManyConfigInput | LeadCreateManyConfigInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutWhatleadparceiroconfigsInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    WhatleadUser?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutWhatleadparceiroconfigsInput = {
    id?: string
    name: string
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    WhatleadUser?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutWhatleadparceiroconfigsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutWhatleadparceiroconfigsInput, CompanyUncheckedCreateWithoutWhatleadparceiroconfigsInput>
  }

  export type LeadUpsertWithWhereUniqueWithoutConfigInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutConfigInput, LeadUncheckedUpdateWithoutConfigInput>
    create: XOR<LeadCreateWithoutConfigInput, LeadUncheckedCreateWithoutConfigInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutConfigInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutConfigInput, LeadUncheckedUpdateWithoutConfigInput>
  }

  export type LeadUpdateManyWithWhereWithoutConfigInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutConfigInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    externalid?: StringNullableFilter<"Lead"> | string | null
    sourceid?: StringNullableFilter<"Lead"> | string | null
    name?: StringFilter<"Lead"> | string
    phone?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    lastmessagesent?: DateTimeNullableFilter<"Lead"> | Date | string | null
    stepsecondcalltemplate?: IntNullableFilter<"Lead"> | number | null
    stepnointeraction?: IntNullableFilter<"Lead"> | number | null
    nointeractionquantity?: IntNullableFilter<"Lead"> | number | null
    accepttemplate?: BoolNullableFilter<"Lead"> | boolean | null
    acceptsecondtemplate?: BoolNullableFilter<"Lead"> | boolean | null
    status?: StringNullableFilter<"Lead"> | string | null
    dialog?: JsonNullableListFilter<"Lead">
    configid?: StringFilter<"Lead"> | string
    whitelabelconfig?: StringFilter<"Lead"> | string
    lastintent?: StringNullableFilter<"Lead"> | string | null
    broker?: StringNullableFilter<"Lead"> | string | null
    origin?: StringNullableFilter<"Lead"> | string | null
    send?: BoolNullableFilter<"Lead"> | boolean | null
    sendAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    isBusinessAutoResponder?: BoolNullableFilter<"Lead"> | boolean | null
    startmessage?: DateTimeNullableFilter<"Lead"> | Date | string | null
    schedulingdata?: StringNullableFilter<"Lead"> | string | null
    productchoosebyclient?: StringNullableFilter<"Lead"> | string | null
    productid?: IntNullableFilter<"Lead"> | number | null
    createdat?: DateTimeFilter<"Lead"> | Date | string
    updatedat?: DateTimeFilter<"Lead"> | Date | string
    curation?: JsonNullableFilter<"Lead">
  }

  export type CompanyUpsertWithoutWhatleadparceiroconfigsInput = {
    update: XOR<CompanyUpdateWithoutWhatleadparceiroconfigsInput, CompanyUncheckedUpdateWithoutWhatleadparceiroconfigsInput>
    create: XOR<CompanyCreateWithoutWhatleadparceiroconfigsInput, CompanyUncheckedCreateWithoutWhatleadparceiroconfigsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutWhatleadparceiroconfigsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutWhatleadparceiroconfigsInput, CompanyUncheckedUpdateWithoutWhatleadparceiroconfigsInput>
  }

  export type CompanyUpdateWithoutWhatleadparceiroconfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WhatleadUser?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutWhatleadparceiroconfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WhatleadUser?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type MessageLogCreateWithoutLeadInput = {
    id?: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMessageLogInput
    campaignLead: CampaignLeadCreateNestedOneWithoutMessageLogsInput
  }

  export type MessageLogUncheckedCreateWithoutLeadInput = {
    id?: string
    campaignId: string
    campaignLeadId: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageLogCreateOrConnectWithoutLeadInput = {
    where: MessageLogWhereUniqueInput
    create: XOR<MessageLogCreateWithoutLeadInput, MessageLogUncheckedCreateWithoutLeadInput>
  }

  export type MessageLogCreateManyLeadInputEnvelope = {
    data: MessageLogCreateManyLeadInput | MessageLogCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type CompaniesUnitesCreateWithoutLeadsInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    company?: CompanyCreateNestedOneWithoutWhatleadparceiroconfigsInput
  }

  export type CompaniesUnitesUncheckedCreateWithoutLeadsInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
    whatleadCompanyId?: string | null
  }

  export type CompaniesUnitesCreateOrConnectWithoutLeadsInput = {
    where: CompaniesUnitesWhereUniqueInput
    create: XOR<CompaniesUnitesCreateWithoutLeadsInput, CompaniesUnitesUncheckedCreateWithoutLeadsInput>
  }

  export type MessageLogUpsertWithWhereUniqueWithoutLeadInput = {
    where: MessageLogWhereUniqueInput
    update: XOR<MessageLogUpdateWithoutLeadInput, MessageLogUncheckedUpdateWithoutLeadInput>
    create: XOR<MessageLogCreateWithoutLeadInput, MessageLogUncheckedCreateWithoutLeadInput>
  }

  export type MessageLogUpdateWithWhereUniqueWithoutLeadInput = {
    where: MessageLogWhereUniqueInput
    data: XOR<MessageLogUpdateWithoutLeadInput, MessageLogUncheckedUpdateWithoutLeadInput>
  }

  export type MessageLogUpdateManyWithWhereWithoutLeadInput = {
    where: MessageLogScalarWhereInput
    data: XOR<MessageLogUpdateManyMutationInput, MessageLogUncheckedUpdateManyWithoutLeadInput>
  }

  export type MessageLogScalarWhereInput = {
    AND?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
    OR?: MessageLogScalarWhereInput[]
    NOT?: MessageLogScalarWhereInput | MessageLogScalarWhereInput[]
    id?: StringFilter<"MessageLog"> | string
    campaignId?: StringFilter<"MessageLog"> | string
    campaignLeadId?: StringFilter<"MessageLog"> | string
    leadId?: StringNullableFilter<"MessageLog"> | string | null
    messageId?: StringFilter<"MessageLog"> | string
    messageDate?: DateTimeFilter<"MessageLog"> | Date | string
    messageType?: StringFilter<"MessageLog"> | string
    content?: StringFilter<"MessageLog"> | string
    status?: StringFilter<"MessageLog"> | string
    statusHistory?: JsonNullableListFilter<"MessageLog">
    sentAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    readAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"MessageLog"> | Date | string | null
    failureReason?: StringNullableFilter<"MessageLog"> | string | null
    createdAt?: DateTimeFilter<"MessageLog"> | Date | string
    updatedAt?: DateTimeFilter<"MessageLog"> | Date | string
  }

  export type CompaniesUnitesUpsertWithoutLeadsInput = {
    update: XOR<CompaniesUnitesUpdateWithoutLeadsInput, CompaniesUnitesUncheckedUpdateWithoutLeadsInput>
    create: XOR<CompaniesUnitesCreateWithoutLeadsInput, CompaniesUnitesUncheckedCreateWithoutLeadsInput>
    where?: CompaniesUnitesWhereInput
  }

  export type CompaniesUnitesUpdateToOneWithWhereWithoutLeadsInput = {
    where?: CompaniesUnitesWhereInput
    data: XOR<CompaniesUnitesUpdateWithoutLeadsInput, CompaniesUnitesUncheckedUpdateWithoutLeadsInput>
  }

  export type CompaniesUnitesUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    company?: CompanyUpdateOneWithoutWhatleadparceiroconfigsNestedInput
  }

  export type CompaniesUnitesUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    whatleadCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutUserInput
    affiliate?: UserCreateNestedOneWithoutAffiliatesInput
    affiliates?: UserCreateNestedManyWithoutAffiliateInput
    Message?: MessageCreateNestedManyWithoutUserInput
    Conversation?: ConversationCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutUserInput
    affiliates?: UserUncheckedCreateNestedManyWithoutAffiliateInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    Conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutUserNestedInput
    affiliate?: UserUpdateOneWithoutAffiliatesNestedInput
    affiliates?: UserUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutUserNestedInput
    affiliates?: UserUncheckedUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInstancesInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutUserInput
    affiliate?: UserCreateNestedOneWithoutAffiliatesInput
    affiliates?: UserCreateNestedManyWithoutAffiliateInput
    Message?: MessageCreateNestedManyWithoutUserInput
    Conversation?: ConversationCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInstancesInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutUserInput
    affiliates?: UserUncheckedCreateNestedManyWithoutAffiliateInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    Conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInstancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstancesInput, UserUncheckedCreateWithoutInstancesInput>
  }

  export type CampaignCreateWithoutInstanceInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchCreateNestedManyWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
    CampaignErrorLog?: CampaignErrorLogCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsCreateNestedManyWithoutCampaignInput
    contacts?: ContactCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutInstanceInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutCampaignInput
    CampaignErrorLog?: CampaignErrorLogUncheckedCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleUncheckedCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsUncheckedCreateNestedManyWithoutCampaignInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignCreateOrConnectWithoutInstanceInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutInstanceInput, CampaignUncheckedCreateWithoutInstanceInput>
  }

  export type CampaignCreateManyInstanceInputEnvelope = {
    data: CampaignCreateManyInstanceInput | CampaignCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type CampaignScheduleCreateWithoutInstanceInput = {
    id?: string
    scheduledDate: Date | string
    status?: string
    message?: string | null
    mediaType?: string | null
    mediaUrl?: string | null
    mediaCaption?: string | null
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    campaign: CampaignCreateNestedOneWithoutCampaignScheduleInput
  }

  export type CampaignScheduleUncheckedCreateWithoutInstanceInput = {
    id?: string
    campaignId: string
    scheduledDate: Date | string
    status?: string
    message?: string | null
    mediaType?: string | null
    mediaUrl?: string | null
    mediaCaption?: string | null
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type CampaignScheduleCreateOrConnectWithoutInstanceInput = {
    where: CampaignScheduleWhereUniqueInput
    create: XOR<CampaignScheduleCreateWithoutInstanceInput, CampaignScheduleUncheckedCreateWithoutInstanceInput>
  }

  export type CampaignScheduleCreateManyInstanceInputEnvelope = {
    data: CampaignScheduleCreateManyInstanceInput | CampaignScheduleCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type CampaignDispatchCreateWithoutInstanceInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutDispatchesInput
  }

  export type CampaignDispatchUncheckedCreateWithoutInstanceInput = {
    id?: string
    campaignId: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignDispatchCreateOrConnectWithoutInstanceInput = {
    where: CampaignDispatchWhereUniqueInput
    create: XOR<CampaignDispatchCreateWithoutInstanceInput, CampaignDispatchUncheckedCreateWithoutInstanceInput>
  }

  export type CampaignDispatchCreateManyInstanceInputEnvelope = {
    data: CampaignDispatchCreateManyInstanceInput | CampaignDispatchCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type WarmupStatsCreateWithoutInstanceInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaReceived?: MediaStatsCreateNestedOneWithoutWarmupStatsReceivedInput
    mediaStats?: MediaStatsCreateNestedOneWithoutWarmupStatsSentInput
    user: UserCreateNestedOneWithoutWarmupStatsInput
  }

  export type WarmupStatsUncheckedCreateWithoutInstanceInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
    mediaReceivedId?: string | null
  }

  export type WarmupStatsCreateOrConnectWithoutInstanceInput = {
    where: WarmupStatsWhereUniqueInput
    create: XOR<WarmupStatsCreateWithoutInstanceInput, WarmupStatsUncheckedCreateWithoutInstanceInput>
  }

  export type WarmupStatsCreateManyInstanceInputEnvelope = {
    data: WarmupStatsCreateManyInstanceInput | WarmupStatsCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type MediaStatsCreateWithoutInstanceInput = {
    id?: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warmupStatsReceived?: WarmupStatsCreateNestedManyWithoutMediaReceivedInput
    warmupStatsSent?: WarmupStatsCreateNestedManyWithoutMediaStatsInput
  }

  export type MediaStatsUncheckedCreateWithoutInstanceInput = {
    id?: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warmupStatsReceived?: WarmupStatsUncheckedCreateNestedManyWithoutMediaReceivedInput
    warmupStatsSent?: WarmupStatsUncheckedCreateNestedManyWithoutMediaStatsInput
  }

  export type MediaStatsCreateOrConnectWithoutInstanceInput = {
    where: MediaStatsWhereUniqueInput
    create: XOR<MediaStatsCreateWithoutInstanceInput, MediaStatsUncheckedCreateWithoutInstanceInput>
  }

  export type MediaStatsCreateManyInstanceInputEnvelope = {
    data: MediaStatsCreateManyInstanceInput | MediaStatsCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInstancesInput = {
    update: XOR<UserUpdateWithoutInstancesInput, UserUncheckedUpdateWithoutInstancesInput>
    create: XOR<UserCreateWithoutInstancesInput, UserUncheckedCreateWithoutInstancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInstancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInstancesInput, UserUncheckedUpdateWithoutInstancesInput>
  }

  export type UserUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutUserNestedInput
    affiliate?: UserUpdateOneWithoutAffiliatesNestedInput
    affiliates?: UserUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutUserNestedInput
    affiliates?: UserUncheckedUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutInstanceInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutInstanceInput, CampaignUncheckedUpdateWithoutInstanceInput>
    create: XOR<CampaignCreateWithoutInstanceInput, CampaignUncheckedCreateWithoutInstanceInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutInstanceInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutInstanceInput, CampaignUncheckedUpdateWithoutInstanceInput>
  }

  export type CampaignUpdateManyWithWhereWithoutInstanceInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutInstanceInput>
  }

  export type CampaignScheduleUpsertWithWhereUniqueWithoutInstanceInput = {
    where: CampaignScheduleWhereUniqueInput
    update: XOR<CampaignScheduleUpdateWithoutInstanceInput, CampaignScheduleUncheckedUpdateWithoutInstanceInput>
    create: XOR<CampaignScheduleCreateWithoutInstanceInput, CampaignScheduleUncheckedCreateWithoutInstanceInput>
  }

  export type CampaignScheduleUpdateWithWhereUniqueWithoutInstanceInput = {
    where: CampaignScheduleWhereUniqueInput
    data: XOR<CampaignScheduleUpdateWithoutInstanceInput, CampaignScheduleUncheckedUpdateWithoutInstanceInput>
  }

  export type CampaignScheduleUpdateManyWithWhereWithoutInstanceInput = {
    where: CampaignScheduleScalarWhereInput
    data: XOR<CampaignScheduleUpdateManyMutationInput, CampaignScheduleUncheckedUpdateManyWithoutInstanceInput>
  }

  export type CampaignScheduleScalarWhereInput = {
    AND?: CampaignScheduleScalarWhereInput | CampaignScheduleScalarWhereInput[]
    OR?: CampaignScheduleScalarWhereInput[]
    NOT?: CampaignScheduleScalarWhereInput | CampaignScheduleScalarWhereInput[]
    id?: StringFilter<"CampaignSchedule"> | string
    campaignId?: StringFilter<"CampaignSchedule"> | string
    instanceName?: StringFilter<"CampaignSchedule"> | string
    scheduledDate?: DateTimeFilter<"CampaignSchedule"> | Date | string
    status?: StringFilter<"CampaignSchedule"> | string
    message?: StringNullableFilter<"CampaignSchedule"> | string | null
    mediaType?: StringNullableFilter<"CampaignSchedule"> | string | null
    mediaUrl?: StringNullableFilter<"CampaignSchedule"> | string | null
    mediaCaption?: StringNullableFilter<"CampaignSchedule"> | string | null
    minDelay?: IntFilter<"CampaignSchedule"> | number
    maxDelay?: IntFilter<"CampaignSchedule"> | number
    createdAt?: DateTimeFilter<"CampaignSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignSchedule"> | Date | string
    startedAt?: DateTimeNullableFilter<"CampaignSchedule"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CampaignSchedule"> | Date | string | null
  }

  export type CampaignDispatchUpsertWithWhereUniqueWithoutInstanceInput = {
    where: CampaignDispatchWhereUniqueInput
    update: XOR<CampaignDispatchUpdateWithoutInstanceInput, CampaignDispatchUncheckedUpdateWithoutInstanceInput>
    create: XOR<CampaignDispatchCreateWithoutInstanceInput, CampaignDispatchUncheckedCreateWithoutInstanceInput>
  }

  export type CampaignDispatchUpdateWithWhereUniqueWithoutInstanceInput = {
    where: CampaignDispatchWhereUniqueInput
    data: XOR<CampaignDispatchUpdateWithoutInstanceInput, CampaignDispatchUncheckedUpdateWithoutInstanceInput>
  }

  export type CampaignDispatchUpdateManyWithWhereWithoutInstanceInput = {
    where: CampaignDispatchScalarWhereInput
    data: XOR<CampaignDispatchUpdateManyMutationInput, CampaignDispatchUncheckedUpdateManyWithoutInstanceInput>
  }

  export type CampaignDispatchScalarWhereInput = {
    AND?: CampaignDispatchScalarWhereInput | CampaignDispatchScalarWhereInput[]
    OR?: CampaignDispatchScalarWhereInput[]
    NOT?: CampaignDispatchScalarWhereInput | CampaignDispatchScalarWhereInput[]
    id?: StringFilter<"CampaignDispatch"> | string
    campaignId?: StringFilter<"CampaignDispatch"> | string
    instanceName?: StringFilter<"CampaignDispatch"> | string
    status?: StringFilter<"CampaignDispatch"> | string
    startedAt?: DateTimeNullableFilter<"CampaignDispatch"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CampaignDispatch"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignDispatch"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignDispatch"> | Date | string
  }

  export type WarmupStatsUpsertWithWhereUniqueWithoutInstanceInput = {
    where: WarmupStatsWhereUniqueInput
    update: XOR<WarmupStatsUpdateWithoutInstanceInput, WarmupStatsUncheckedUpdateWithoutInstanceInput>
    create: XOR<WarmupStatsCreateWithoutInstanceInput, WarmupStatsUncheckedCreateWithoutInstanceInput>
  }

  export type WarmupStatsUpdateWithWhereUniqueWithoutInstanceInput = {
    where: WarmupStatsWhereUniqueInput
    data: XOR<WarmupStatsUpdateWithoutInstanceInput, WarmupStatsUncheckedUpdateWithoutInstanceInput>
  }

  export type WarmupStatsUpdateManyWithWhereWithoutInstanceInput = {
    where: WarmupStatsScalarWhereInput
    data: XOR<WarmupStatsUpdateManyMutationInput, WarmupStatsUncheckedUpdateManyWithoutInstanceInput>
  }

  export type MediaStatsUpsertWithWhereUniqueWithoutInstanceInput = {
    where: MediaStatsWhereUniqueInput
    update: XOR<MediaStatsUpdateWithoutInstanceInput, MediaStatsUncheckedUpdateWithoutInstanceInput>
    create: XOR<MediaStatsCreateWithoutInstanceInput, MediaStatsUncheckedCreateWithoutInstanceInput>
  }

  export type MediaStatsUpdateWithWhereUniqueWithoutInstanceInput = {
    where: MediaStatsWhereUniqueInput
    data: XOR<MediaStatsUpdateWithoutInstanceInput, MediaStatsUncheckedUpdateWithoutInstanceInput>
  }

  export type MediaStatsUpdateManyWithWhereWithoutInstanceInput = {
    where: MediaStatsScalarWhereInput
    data: XOR<MediaStatsUpdateManyMutationInput, MediaStatsUncheckedUpdateManyWithoutInstanceInput>
  }

  export type MediaStatsScalarWhereInput = {
    AND?: MediaStatsScalarWhereInput | MediaStatsScalarWhereInput[]
    OR?: MediaStatsScalarWhereInput[]
    NOT?: MediaStatsScalarWhereInput | MediaStatsScalarWhereInput[]
    id?: StringFilter<"MediaStats"> | string
    instanceName?: StringFilter<"MediaStats"> | string
    date?: DateTimeFilter<"MediaStats"> | Date | string
    text?: IntFilter<"MediaStats"> | number
    image?: IntFilter<"MediaStats"> | number
    video?: IntFilter<"MediaStats"> | number
    audio?: IntFilter<"MediaStats"> | number
    sticker?: IntFilter<"MediaStats"> | number
    reaction?: IntFilter<"MediaStats"> | number
    isReceived?: BoolFilter<"MediaStats"> | boolean
    totalDaily?: IntFilter<"MediaStats"> | number
    totalAllTime?: IntFilter<"MediaStats"> | number
    totalSent?: IntFilter<"MediaStats"> | number
    totalReceived?: IntFilter<"MediaStats"> | number
    createdAt?: DateTimeFilter<"MediaStats"> | Date | string
    updatedAt?: DateTimeFilter<"MediaStats"> | Date | string
  }

  export type InstanceCreateWithoutMediaStatsInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutInstancesInput
    campaigns?: CampaignCreateNestedManyWithoutInstanceInput
    campaignSchedules?: CampaignScheduleCreateNestedManyWithoutInstanceInput
    campaignDispatches?: CampaignDispatchCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutMediaStatsInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedCreateNestedManyWithoutInstanceInput
    campaignSchedules?: CampaignScheduleUncheckedCreateNestedManyWithoutInstanceInput
    campaignDispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutMediaStatsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutMediaStatsInput, InstanceUncheckedCreateWithoutMediaStatsInput>
  }

  export type WarmupStatsCreateWithoutMediaReceivedInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutWarmupStatsInput
    mediaStats?: MediaStatsCreateNestedOneWithoutWarmupStatsSentInput
    user: UserCreateNestedOneWithoutWarmupStatsInput
  }

  export type WarmupStatsUncheckedCreateWithoutMediaReceivedInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
  }

  export type WarmupStatsCreateOrConnectWithoutMediaReceivedInput = {
    where: WarmupStatsWhereUniqueInput
    create: XOR<WarmupStatsCreateWithoutMediaReceivedInput, WarmupStatsUncheckedCreateWithoutMediaReceivedInput>
  }

  export type WarmupStatsCreateManyMediaReceivedInputEnvelope = {
    data: WarmupStatsCreateManyMediaReceivedInput | WarmupStatsCreateManyMediaReceivedInput[]
    skipDuplicates?: boolean
  }

  export type WarmupStatsCreateWithoutMediaStatsInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutWarmupStatsInput
    mediaReceived?: MediaStatsCreateNestedOneWithoutWarmupStatsReceivedInput
    user: UserCreateNestedOneWithoutWarmupStatsInput
  }

  export type WarmupStatsUncheckedCreateWithoutMediaStatsInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaReceivedId?: string | null
  }

  export type WarmupStatsCreateOrConnectWithoutMediaStatsInput = {
    where: WarmupStatsWhereUniqueInput
    create: XOR<WarmupStatsCreateWithoutMediaStatsInput, WarmupStatsUncheckedCreateWithoutMediaStatsInput>
  }

  export type WarmupStatsCreateManyMediaStatsInputEnvelope = {
    data: WarmupStatsCreateManyMediaStatsInput | WarmupStatsCreateManyMediaStatsInput[]
    skipDuplicates?: boolean
  }

  export type InstanceUpsertWithoutMediaStatsInput = {
    update: XOR<InstanceUpdateWithoutMediaStatsInput, InstanceUncheckedUpdateWithoutMediaStatsInput>
    create: XOR<InstanceCreateWithoutMediaStatsInput, InstanceUncheckedCreateWithoutMediaStatsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutMediaStatsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutMediaStatsInput, InstanceUncheckedUpdateWithoutMediaStatsInput>
  }

  export type InstanceUpdateWithoutMediaStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutInstancesNestedInput
    campaigns?: CampaignUpdateManyWithoutInstanceNestedInput
    campaignSchedules?: CampaignScheduleUpdateManyWithoutInstanceNestedInput
    campaignDispatches?: CampaignDispatchUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutMediaStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedUpdateManyWithoutInstanceNestedInput
    campaignSchedules?: CampaignScheduleUncheckedUpdateManyWithoutInstanceNestedInput
    campaignDispatches?: CampaignDispatchUncheckedUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type WarmupStatsUpsertWithWhereUniqueWithoutMediaReceivedInput = {
    where: WarmupStatsWhereUniqueInput
    update: XOR<WarmupStatsUpdateWithoutMediaReceivedInput, WarmupStatsUncheckedUpdateWithoutMediaReceivedInput>
    create: XOR<WarmupStatsCreateWithoutMediaReceivedInput, WarmupStatsUncheckedCreateWithoutMediaReceivedInput>
  }

  export type WarmupStatsUpdateWithWhereUniqueWithoutMediaReceivedInput = {
    where: WarmupStatsWhereUniqueInput
    data: XOR<WarmupStatsUpdateWithoutMediaReceivedInput, WarmupStatsUncheckedUpdateWithoutMediaReceivedInput>
  }

  export type WarmupStatsUpdateManyWithWhereWithoutMediaReceivedInput = {
    where: WarmupStatsScalarWhereInput
    data: XOR<WarmupStatsUpdateManyMutationInput, WarmupStatsUncheckedUpdateManyWithoutMediaReceivedInput>
  }

  export type WarmupStatsUpsertWithWhereUniqueWithoutMediaStatsInput = {
    where: WarmupStatsWhereUniqueInput
    update: XOR<WarmupStatsUpdateWithoutMediaStatsInput, WarmupStatsUncheckedUpdateWithoutMediaStatsInput>
    create: XOR<WarmupStatsCreateWithoutMediaStatsInput, WarmupStatsUncheckedCreateWithoutMediaStatsInput>
  }

  export type WarmupStatsUpdateWithWhereUniqueWithoutMediaStatsInput = {
    where: WarmupStatsWhereUniqueInput
    data: XOR<WarmupStatsUpdateWithoutMediaStatsInput, WarmupStatsUncheckedUpdateWithoutMediaStatsInput>
  }

  export type WarmupStatsUpdateManyWithWhereWithoutMediaStatsInput = {
    where: WarmupStatsScalarWhereInput
    data: XOR<WarmupStatsUpdateManyMutationInput, WarmupStatsUncheckedUpdateManyWithoutMediaStatsInput>
  }

  export type InstanceCreateWithoutWarmupStatsInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutInstancesInput
    campaigns?: CampaignCreateNestedManyWithoutInstanceInput
    campaignSchedules?: CampaignScheduleCreateNestedManyWithoutInstanceInput
    campaignDispatches?: CampaignDispatchCreateNestedManyWithoutInstanceInput
    mediaStats?: MediaStatsCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutWarmupStatsInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedCreateNestedManyWithoutInstanceInput
    campaignSchedules?: CampaignScheduleUncheckedCreateNestedManyWithoutInstanceInput
    campaignDispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutInstanceInput
    mediaStats?: MediaStatsUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutWarmupStatsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutWarmupStatsInput, InstanceUncheckedCreateWithoutWarmupStatsInput>
  }

  export type MediaStatsCreateWithoutWarmupStatsReceivedInput = {
    id?: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutMediaStatsInput
    warmupStatsSent?: WarmupStatsCreateNestedManyWithoutMediaStatsInput
  }

  export type MediaStatsUncheckedCreateWithoutWarmupStatsReceivedInput = {
    id?: string
    instanceName: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warmupStatsSent?: WarmupStatsUncheckedCreateNestedManyWithoutMediaStatsInput
  }

  export type MediaStatsCreateOrConnectWithoutWarmupStatsReceivedInput = {
    where: MediaStatsWhereUniqueInput
    create: XOR<MediaStatsCreateWithoutWarmupStatsReceivedInput, MediaStatsUncheckedCreateWithoutWarmupStatsReceivedInput>
  }

  export type MediaStatsCreateWithoutWarmupStatsSentInput = {
    id?: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutMediaStatsInput
    warmupStatsReceived?: WarmupStatsCreateNestedManyWithoutMediaReceivedInput
  }

  export type MediaStatsUncheckedCreateWithoutWarmupStatsSentInput = {
    id?: string
    instanceName: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warmupStatsReceived?: WarmupStatsUncheckedCreateNestedManyWithoutMediaReceivedInput
  }

  export type MediaStatsCreateOrConnectWithoutWarmupStatsSentInput = {
    where: MediaStatsWhereUniqueInput
    create: XOR<MediaStatsCreateWithoutWarmupStatsSentInput, MediaStatsUncheckedCreateWithoutWarmupStatsSentInput>
  }

  export type UserCreateWithoutWarmupStatsInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutUserInput
    affiliate?: UserCreateNestedOneWithoutAffiliatesInput
    affiliates?: UserCreateNestedManyWithoutAffiliateInput
    Message?: MessageCreateNestedManyWithoutUserInput
    Conversation?: ConversationCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWarmupStatsInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutUserInput
    affiliates?: UserUncheckedCreateNestedManyWithoutAffiliateInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    Conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWarmupStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWarmupStatsInput, UserUncheckedCreateWithoutWarmupStatsInput>
  }

  export type InstanceUpsertWithoutWarmupStatsInput = {
    update: XOR<InstanceUpdateWithoutWarmupStatsInput, InstanceUncheckedUpdateWithoutWarmupStatsInput>
    create: XOR<InstanceCreateWithoutWarmupStatsInput, InstanceUncheckedCreateWithoutWarmupStatsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutWarmupStatsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutWarmupStatsInput, InstanceUncheckedUpdateWithoutWarmupStatsInput>
  }

  export type InstanceUpdateWithoutWarmupStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutInstancesNestedInput
    campaigns?: CampaignUpdateManyWithoutInstanceNestedInput
    campaignSchedules?: CampaignScheduleUpdateManyWithoutInstanceNestedInput
    campaignDispatches?: CampaignDispatchUpdateManyWithoutInstanceNestedInput
    mediaStats?: MediaStatsUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutWarmupStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedUpdateManyWithoutInstanceNestedInput
    campaignSchedules?: CampaignScheduleUncheckedUpdateManyWithoutInstanceNestedInput
    campaignDispatches?: CampaignDispatchUncheckedUpdateManyWithoutInstanceNestedInput
    mediaStats?: MediaStatsUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type MediaStatsUpsertWithoutWarmupStatsReceivedInput = {
    update: XOR<MediaStatsUpdateWithoutWarmupStatsReceivedInput, MediaStatsUncheckedUpdateWithoutWarmupStatsReceivedInput>
    create: XOR<MediaStatsCreateWithoutWarmupStatsReceivedInput, MediaStatsUncheckedCreateWithoutWarmupStatsReceivedInput>
    where?: MediaStatsWhereInput
  }

  export type MediaStatsUpdateToOneWithWhereWithoutWarmupStatsReceivedInput = {
    where?: MediaStatsWhereInput
    data: XOR<MediaStatsUpdateWithoutWarmupStatsReceivedInput, MediaStatsUncheckedUpdateWithoutWarmupStatsReceivedInput>
  }

  export type MediaStatsUpdateWithoutWarmupStatsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutMediaStatsNestedInput
    warmupStatsSent?: WarmupStatsUpdateManyWithoutMediaStatsNestedInput
  }

  export type MediaStatsUncheckedUpdateWithoutWarmupStatsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warmupStatsSent?: WarmupStatsUncheckedUpdateManyWithoutMediaStatsNestedInput
  }

  export type MediaStatsUpsertWithoutWarmupStatsSentInput = {
    update: XOR<MediaStatsUpdateWithoutWarmupStatsSentInput, MediaStatsUncheckedUpdateWithoutWarmupStatsSentInput>
    create: XOR<MediaStatsCreateWithoutWarmupStatsSentInput, MediaStatsUncheckedCreateWithoutWarmupStatsSentInput>
    where?: MediaStatsWhereInput
  }

  export type MediaStatsUpdateToOneWithWhereWithoutWarmupStatsSentInput = {
    where?: MediaStatsWhereInput
    data: XOR<MediaStatsUpdateWithoutWarmupStatsSentInput, MediaStatsUncheckedUpdateWithoutWarmupStatsSentInput>
  }

  export type MediaStatsUpdateWithoutWarmupStatsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutMediaStatsNestedInput
    warmupStatsReceived?: WarmupStatsUpdateManyWithoutMediaReceivedNestedInput
  }

  export type MediaStatsUncheckedUpdateWithoutWarmupStatsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warmupStatsReceived?: WarmupStatsUncheckedUpdateManyWithoutMediaReceivedNestedInput
  }

  export type UserUpsertWithoutWarmupStatsInput = {
    update: XOR<UserUpdateWithoutWarmupStatsInput, UserUncheckedUpdateWithoutWarmupStatsInput>
    create: XOR<UserCreateWithoutWarmupStatsInput, UserUncheckedCreateWithoutWarmupStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWarmupStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWarmupStatsInput, UserUncheckedUpdateWithoutWarmupStatsInput>
  }

  export type UserUpdateWithoutWarmupStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutUserNestedInput
    affiliate?: UserUpdateOneWithoutAffiliatesNestedInput
    affiliates?: UserUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWarmupStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutUserNestedInput
    affiliates?: UserUncheckedUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageLogCreateWithoutCampaignInput = {
    id?: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignLead: CampaignLeadCreateNestedOneWithoutMessageLogsInput
    lead?: LeadCreateNestedOneWithoutMessageLogInput
  }

  export type MessageLogUncheckedCreateWithoutCampaignInput = {
    id?: string
    campaignLeadId: string
    leadId?: string | null
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageLogCreateOrConnectWithoutCampaignInput = {
    where: MessageLogWhereUniqueInput
    create: XOR<MessageLogCreateWithoutCampaignInput, MessageLogUncheckedCreateWithoutCampaignInput>
  }

  export type MessageLogCreateManyCampaignInputEnvelope = {
    data: MessageLogCreateManyCampaignInput | MessageLogCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignLeadCreateWithoutCampaignInput = {
    id?: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    segment?: string | null
    engagement?: string | null
    syncedWithCRM?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignLeadInput
    messageLogs?: MessageLogCreateNestedManyWithoutCampaignLeadInput
  }

  export type CampaignLeadUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    segment?: string | null
    engagement?: string | null
    syncedWithCRM?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messageLogs?: MessageLogUncheckedCreateNestedManyWithoutCampaignLeadInput
  }

  export type CampaignLeadCreateOrConnectWithoutCampaignInput = {
    where: CampaignLeadWhereUniqueInput
    create: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignLeadCreateManyCampaignInputEnvelope = {
    data: CampaignLeadCreateManyCampaignInput | CampaignLeadCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignMessageCreateWithoutCampaignInput = {
    id?: string
    type: string
    content: string
    order: number
    caption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignMessageUncheckedCreateWithoutCampaignInput = {
    id?: string
    type: string
    content: string
    order: number
    caption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignMessageCreateOrConnectWithoutCampaignInput = {
    where: CampaignMessageWhereUniqueInput
    create: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignMessageCreateManyCampaignInputEnvelope = {
    data: CampaignMessageCreateManyCampaignInput | CampaignMessageCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignStatisticsCreateWithoutCampaignInput = {
    id?: string
    totalLeads?: number
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignStatisticsUncheckedCreateWithoutCampaignInput = {
    id?: string
    totalLeads?: number
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    failedCount?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignStatisticsCreateOrConnectWithoutCampaignInput = {
    where: CampaignStatisticsWhereUniqueInput
    create: XOR<CampaignStatisticsCreateWithoutCampaignInput, CampaignStatisticsUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignDispatchCreateWithoutCampaignInput = {
    id?: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instance: InstanceCreateNestedOneWithoutCampaignDispatchesInput
  }

  export type CampaignDispatchUncheckedCreateWithoutCampaignInput = {
    id?: string
    instanceName: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignDispatchCreateOrConnectWithoutCampaignInput = {
    where: CampaignDispatchWhereUniqueInput
    create: XOR<CampaignDispatchCreateWithoutCampaignInput, CampaignDispatchUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignDispatchCreateManyCampaignInputEnvelope = {
    data: CampaignDispatchCreateManyCampaignInput | CampaignDispatchCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCampaignInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutUserInput
    affiliate?: UserCreateNestedOneWithoutAffiliatesInput
    affiliates?: UserCreateNestedManyWithoutAffiliateInput
    Message?: MessageCreateNestedManyWithoutUserInput
    Conversation?: ConversationCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCampaignInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutUserInput
    affiliates?: UserUncheckedCreateNestedManyWithoutAffiliateInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    Conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCampaignInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignInput, UserUncheckedCreateWithoutCampaignInput>
  }

  export type InstanceCreateWithoutCampaignsInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutInstancesInput
    campaignSchedules?: CampaignScheduleCreateNestedManyWithoutInstanceInput
    campaignDispatches?: CampaignDispatchCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutInstanceInput
    mediaStats?: MediaStatsCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutCampaignsInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaignSchedules?: CampaignScheduleUncheckedCreateNestedManyWithoutInstanceInput
    campaignDispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutInstanceInput
    mediaStats?: MediaStatsUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutCampaignsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutCampaignsInput, InstanceUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignErrorLogCreateWithoutCampaignInput = {
    id?: string
    errorMessage: string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignErrorLogUncheckedCreateWithoutCampaignInput = {
    id?: string
    errorMessage: string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignErrorLogCreateOrConnectWithoutCampaignInput = {
    where: CampaignErrorLogWhereUniqueInput
    create: XOR<CampaignErrorLogCreateWithoutCampaignInput, CampaignErrorLogUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignErrorLogCreateManyCampaignInputEnvelope = {
    data: CampaignErrorLogCreateManyCampaignInput | CampaignErrorLogCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignScheduleCreateWithoutCampaignInput = {
    id?: string
    scheduledDate: Date | string
    status?: string
    message?: string | null
    mediaType?: string | null
    mediaUrl?: string | null
    mediaCaption?: string | null
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    instance: InstanceCreateNestedOneWithoutCampaignSchedulesInput
  }

  export type CampaignScheduleUncheckedCreateWithoutCampaignInput = {
    id?: string
    instanceName: string
    scheduledDate: Date | string
    status?: string
    message?: string | null
    mediaType?: string | null
    mediaUrl?: string | null
    mediaCaption?: string | null
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type CampaignScheduleCreateOrConnectWithoutCampaignInput = {
    where: CampaignScheduleWhereUniqueInput
    create: XOR<CampaignScheduleCreateWithoutCampaignInput, CampaignScheduleUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignScheduleCreateManyCampaignInputEnvelope = {
    data: CampaignScheduleCreateManyCampaignInput | CampaignScheduleCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type MessageAnalyticsCreateWithoutCampaignInput = {
    id?: string
    date: Date | string
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    respondedCount?: number
    failedCount?: number
  }

  export type MessageAnalyticsUncheckedCreateWithoutCampaignInput = {
    id?: string
    date: Date | string
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    respondedCount?: number
    failedCount?: number
  }

  export type MessageAnalyticsCreateOrConnectWithoutCampaignInput = {
    where: MessageAnalyticsWhereUniqueInput
    create: XOR<MessageAnalyticsCreateWithoutCampaignInput, MessageAnalyticsUncheckedCreateWithoutCampaignInput>
  }

  export type MessageAnalyticsCreateManyCampaignInputEnvelope = {
    data: MessageAnalyticsCreateManyCampaignInput | MessageAnalyticsCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutCampaignsInput = {
    id?: string
    phone: string
    name?: string | null
    email?: string | null
    company?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    lastInteractionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    source?: string | null
    user: UserCreateNestedOneWithoutContactsInput
    conversations?: ConversationCreateNestedManyWithoutContactInput
    contactNotes?: ContactNoteCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCampaignsInput = {
    id?: string
    phone: string
    name?: string | null
    email?: string | null
    company?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    userId: string
    lastInteractionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    source?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCampaignsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCampaignsInput, ContactUncheckedCreateWithoutCampaignsInput>
  }

  export type MessageLogUpsertWithWhereUniqueWithoutCampaignInput = {
    where: MessageLogWhereUniqueInput
    update: XOR<MessageLogUpdateWithoutCampaignInput, MessageLogUncheckedUpdateWithoutCampaignInput>
    create: XOR<MessageLogCreateWithoutCampaignInput, MessageLogUncheckedCreateWithoutCampaignInput>
  }

  export type MessageLogUpdateWithWhereUniqueWithoutCampaignInput = {
    where: MessageLogWhereUniqueInput
    data: XOR<MessageLogUpdateWithoutCampaignInput, MessageLogUncheckedUpdateWithoutCampaignInput>
  }

  export type MessageLogUpdateManyWithWhereWithoutCampaignInput = {
    where: MessageLogScalarWhereInput
    data: XOR<MessageLogUpdateManyMutationInput, MessageLogUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignLeadUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignLeadWhereUniqueInput
    update: XOR<CampaignLeadUpdateWithoutCampaignInput, CampaignLeadUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignLeadCreateWithoutCampaignInput, CampaignLeadUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignLeadUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignLeadWhereUniqueInput
    data: XOR<CampaignLeadUpdateWithoutCampaignInput, CampaignLeadUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignLeadUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignLeadScalarWhereInput
    data: XOR<CampaignLeadUpdateManyMutationInput, CampaignLeadUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignMessageUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignMessageWhereUniqueInput
    update: XOR<CampaignMessageUpdateWithoutCampaignInput, CampaignMessageUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignMessageCreateWithoutCampaignInput, CampaignMessageUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignMessageUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignMessageWhereUniqueInput
    data: XOR<CampaignMessageUpdateWithoutCampaignInput, CampaignMessageUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignMessageUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignMessageScalarWhereInput
    data: XOR<CampaignMessageUpdateManyMutationInput, CampaignMessageUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignMessageScalarWhereInput = {
    AND?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
    OR?: CampaignMessageScalarWhereInput[]
    NOT?: CampaignMessageScalarWhereInput | CampaignMessageScalarWhereInput[]
    id?: StringFilter<"CampaignMessage"> | string
    campaignId?: StringFilter<"CampaignMessage"> | string
    type?: StringFilter<"CampaignMessage"> | string
    content?: StringFilter<"CampaignMessage"> | string
    order?: IntFilter<"CampaignMessage"> | number
    caption?: StringNullableFilter<"CampaignMessage"> | string | null
    createdAt?: DateTimeFilter<"CampaignMessage"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignMessage"> | Date | string
  }

  export type CampaignStatisticsUpsertWithoutCampaignInput = {
    update: XOR<CampaignStatisticsUpdateWithoutCampaignInput, CampaignStatisticsUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignStatisticsCreateWithoutCampaignInput, CampaignStatisticsUncheckedCreateWithoutCampaignInput>
    where?: CampaignStatisticsWhereInput
  }

  export type CampaignStatisticsUpdateToOneWithWhereWithoutCampaignInput = {
    where?: CampaignStatisticsWhereInput
    data: XOR<CampaignStatisticsUpdateWithoutCampaignInput, CampaignStatisticsUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignStatisticsUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignStatisticsUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalLeads?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignDispatchUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignDispatchWhereUniqueInput
    update: XOR<CampaignDispatchUpdateWithoutCampaignInput, CampaignDispatchUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignDispatchCreateWithoutCampaignInput, CampaignDispatchUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignDispatchUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignDispatchWhereUniqueInput
    data: XOR<CampaignDispatchUpdateWithoutCampaignInput, CampaignDispatchUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignDispatchUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignDispatchScalarWhereInput
    data: XOR<CampaignDispatchUpdateManyMutationInput, CampaignDispatchUncheckedUpdateManyWithoutCampaignInput>
  }

  export type UserUpsertWithoutCampaignInput = {
    update: XOR<UserUpdateWithoutCampaignInput, UserUncheckedUpdateWithoutCampaignInput>
    create: XOR<UserCreateWithoutCampaignInput, UserUncheckedCreateWithoutCampaignInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignInput, UserUncheckedUpdateWithoutCampaignInput>
  }

  export type UserUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutUserNestedInput
    affiliate?: UserUpdateOneWithoutAffiliatesNestedInput
    affiliates?: UserUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutUserNestedInput
    affiliates?: UserUncheckedUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InstanceUpsertWithoutCampaignsInput = {
    update: XOR<InstanceUpdateWithoutCampaignsInput, InstanceUncheckedUpdateWithoutCampaignsInput>
    create: XOR<InstanceCreateWithoutCampaignsInput, InstanceUncheckedCreateWithoutCampaignsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutCampaignsInput, InstanceUncheckedUpdateWithoutCampaignsInput>
  }

  export type InstanceUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutInstancesNestedInput
    campaignSchedules?: CampaignScheduleUpdateManyWithoutInstanceNestedInput
    campaignDispatches?: CampaignDispatchUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutInstanceNestedInput
    mediaStats?: MediaStatsUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaignSchedules?: CampaignScheduleUncheckedUpdateManyWithoutInstanceNestedInput
    campaignDispatches?: CampaignDispatchUncheckedUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutInstanceNestedInput
    mediaStats?: MediaStatsUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type CampaignErrorLogUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignErrorLogWhereUniqueInput
    update: XOR<CampaignErrorLogUpdateWithoutCampaignInput, CampaignErrorLogUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignErrorLogCreateWithoutCampaignInput, CampaignErrorLogUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignErrorLogUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignErrorLogWhereUniqueInput
    data: XOR<CampaignErrorLogUpdateWithoutCampaignInput, CampaignErrorLogUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignErrorLogUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignErrorLogScalarWhereInput
    data: XOR<CampaignErrorLogUpdateManyMutationInput, CampaignErrorLogUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignErrorLogScalarWhereInput = {
    AND?: CampaignErrorLogScalarWhereInput | CampaignErrorLogScalarWhereInput[]
    OR?: CampaignErrorLogScalarWhereInput[]
    NOT?: CampaignErrorLogScalarWhereInput | CampaignErrorLogScalarWhereInput[]
    id?: StringFilter<"CampaignErrorLog"> | string
    campaignId?: StringFilter<"CampaignErrorLog"> | string
    errorMessage?: StringFilter<"CampaignErrorLog"> | string
    errorDetails?: JsonNullableFilter<"CampaignErrorLog">
    createdAt?: DateTimeFilter<"CampaignErrorLog"> | Date | string
  }

  export type CampaignScheduleUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignScheduleWhereUniqueInput
    update: XOR<CampaignScheduleUpdateWithoutCampaignInput, CampaignScheduleUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignScheduleCreateWithoutCampaignInput, CampaignScheduleUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignScheduleUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignScheduleWhereUniqueInput
    data: XOR<CampaignScheduleUpdateWithoutCampaignInput, CampaignScheduleUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignScheduleUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignScheduleScalarWhereInput
    data: XOR<CampaignScheduleUpdateManyMutationInput, CampaignScheduleUncheckedUpdateManyWithoutCampaignInput>
  }

  export type MessageAnalyticsUpsertWithWhereUniqueWithoutCampaignInput = {
    where: MessageAnalyticsWhereUniqueInput
    update: XOR<MessageAnalyticsUpdateWithoutCampaignInput, MessageAnalyticsUncheckedUpdateWithoutCampaignInput>
    create: XOR<MessageAnalyticsCreateWithoutCampaignInput, MessageAnalyticsUncheckedCreateWithoutCampaignInput>
  }

  export type MessageAnalyticsUpdateWithWhereUniqueWithoutCampaignInput = {
    where: MessageAnalyticsWhereUniqueInput
    data: XOR<MessageAnalyticsUpdateWithoutCampaignInput, MessageAnalyticsUncheckedUpdateWithoutCampaignInput>
  }

  export type MessageAnalyticsUpdateManyWithWhereWithoutCampaignInput = {
    where: MessageAnalyticsScalarWhereInput
    data: XOR<MessageAnalyticsUpdateManyMutationInput, MessageAnalyticsUncheckedUpdateManyWithoutCampaignInput>
  }

  export type MessageAnalyticsScalarWhereInput = {
    AND?: MessageAnalyticsScalarWhereInput | MessageAnalyticsScalarWhereInput[]
    OR?: MessageAnalyticsScalarWhereInput[]
    NOT?: MessageAnalyticsScalarWhereInput | MessageAnalyticsScalarWhereInput[]
    id?: StringFilter<"MessageAnalytics"> | string
    campaignId?: StringFilter<"MessageAnalytics"> | string
    date?: DateTimeFilter<"MessageAnalytics"> | Date | string
    sentCount?: IntFilter<"MessageAnalytics"> | number
    deliveredCount?: IntFilter<"MessageAnalytics"> | number
    readCount?: IntFilter<"MessageAnalytics"> | number
    respondedCount?: IntFilter<"MessageAnalytics"> | number
    failedCount?: IntFilter<"MessageAnalytics"> | number
  }

  export type ContactUpsertWithWhereUniqueWithoutCampaignsInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutCampaignsInput, ContactUncheckedUpdateWithoutCampaignsInput>
    create: XOR<ContactCreateWithoutCampaignsInput, ContactUncheckedCreateWithoutCampaignsInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutCampaignsInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutCampaignsInput, ContactUncheckedUpdateWithoutCampaignsInput>
  }

  export type ContactUpdateManyWithWhereWithoutCampaignsInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type CampaignCreateWithoutDispatchesInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
    instance?: InstanceCreateNestedOneWithoutCampaignsInput
    CampaignErrorLog?: CampaignErrorLogCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsCreateNestedManyWithoutCampaignInput
    contacts?: ContactCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutDispatchesInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
    CampaignErrorLog?: CampaignErrorLogUncheckedCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleUncheckedCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsUncheckedCreateNestedManyWithoutCampaignInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignCreateOrConnectWithoutDispatchesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutDispatchesInput, CampaignUncheckedCreateWithoutDispatchesInput>
  }

  export type InstanceCreateWithoutCampaignDispatchesInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutInstancesInput
    campaigns?: CampaignCreateNestedManyWithoutInstanceInput
    campaignSchedules?: CampaignScheduleCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutInstanceInput
    mediaStats?: MediaStatsCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutCampaignDispatchesInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedCreateNestedManyWithoutInstanceInput
    campaignSchedules?: CampaignScheduleUncheckedCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutInstanceInput
    mediaStats?: MediaStatsUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutCampaignDispatchesInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutCampaignDispatchesInput, InstanceUncheckedCreateWithoutCampaignDispatchesInput>
  }

  export type CampaignUpsertWithoutDispatchesInput = {
    update: XOR<CampaignUpdateWithoutDispatchesInput, CampaignUncheckedUpdateWithoutDispatchesInput>
    create: XOR<CampaignCreateWithoutDispatchesInput, CampaignUncheckedCreateWithoutDispatchesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutDispatchesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutDispatchesInput, CampaignUncheckedUpdateWithoutDispatchesInput>
  }

  export type CampaignUpdateWithoutDispatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
    instance?: InstanceUpdateOneWithoutCampaignsNestedInput
    CampaignErrorLog?: CampaignErrorLogUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutDispatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
    CampaignErrorLog?: CampaignErrorLogUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUncheckedUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUncheckedUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type InstanceUpsertWithoutCampaignDispatchesInput = {
    update: XOR<InstanceUpdateWithoutCampaignDispatchesInput, InstanceUncheckedUpdateWithoutCampaignDispatchesInput>
    create: XOR<InstanceCreateWithoutCampaignDispatchesInput, InstanceUncheckedCreateWithoutCampaignDispatchesInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutCampaignDispatchesInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutCampaignDispatchesInput, InstanceUncheckedUpdateWithoutCampaignDispatchesInput>
  }

  export type InstanceUpdateWithoutCampaignDispatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutInstancesNestedInput
    campaigns?: CampaignUpdateManyWithoutInstanceNestedInput
    campaignSchedules?: CampaignScheduleUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutInstanceNestedInput
    mediaStats?: MediaStatsUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutCampaignDispatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedUpdateManyWithoutInstanceNestedInput
    campaignSchedules?: CampaignScheduleUncheckedUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutInstanceNestedInput
    mediaStats?: MediaStatsUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type CampaignCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchCreateNestedManyWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
    instance?: InstanceCreateNestedOneWithoutCampaignsInput
    CampaignErrorLog?: CampaignErrorLogCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsCreateNestedManyWithoutCampaignInput
    contacts?: ContactCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutCampaignInput
    CampaignErrorLog?: CampaignErrorLogUncheckedCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleUncheckedCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsUncheckedCreateNestedManyWithoutCampaignInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignCreateOrConnectWithoutMessagesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
  }

  export type CampaignUpsertWithoutMessagesInput = {
    update: XOR<CampaignUpdateWithoutMessagesInput, CampaignUncheckedUpdateWithoutMessagesInput>
    create: XOR<CampaignCreateWithoutMessagesInput, CampaignUncheckedCreateWithoutMessagesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMessagesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMessagesInput, CampaignUncheckedUpdateWithoutMessagesInput>
  }

  export type CampaignUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUpdateManyWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
    instance?: InstanceUpdateOneWithoutCampaignsNestedInput
    CampaignErrorLog?: CampaignErrorLogUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignErrorLog?: CampaignErrorLogUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUncheckedUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUncheckedUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type UserCreateWithoutCampaignLeadInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
    affiliate?: UserCreateNestedOneWithoutAffiliatesInput
    affiliates?: UserCreateNestedManyWithoutAffiliateInput
    Message?: MessageCreateNestedManyWithoutUserInput
    Conversation?: ConversationCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCampaignLeadInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
    affiliates?: UserUncheckedCreateNestedManyWithoutAffiliateInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    Conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCampaignLeadInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignLeadInput, UserUncheckedCreateWithoutCampaignLeadInput>
  }

  export type MessageLogCreateWithoutCampaignLeadInput = {
    id?: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMessageLogInput
    lead?: LeadCreateNestedOneWithoutMessageLogInput
  }

  export type MessageLogUncheckedCreateWithoutCampaignLeadInput = {
    id?: string
    campaignId: string
    leadId?: string | null
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageLogCreateOrConnectWithoutCampaignLeadInput = {
    where: MessageLogWhereUniqueInput
    create: XOR<MessageLogCreateWithoutCampaignLeadInput, MessageLogUncheckedCreateWithoutCampaignLeadInput>
  }

  export type MessageLogCreateManyCampaignLeadInputEnvelope = {
    data: MessageLogCreateManyCampaignLeadInput | MessageLogCreateManyCampaignLeadInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutLeadsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchCreateNestedManyWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
    instance?: InstanceCreateNestedOneWithoutCampaignsInput
    CampaignErrorLog?: CampaignErrorLogCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsCreateNestedManyWithoutCampaignInput
    contacts?: ContactCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutLeadsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutCampaignInput
    CampaignErrorLog?: CampaignErrorLogUncheckedCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleUncheckedCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsUncheckedCreateNestedManyWithoutCampaignInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignCreateOrConnectWithoutLeadsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutLeadsInput, CampaignUncheckedCreateWithoutLeadsInput>
  }

  export type UserUpsertWithoutCampaignLeadInput = {
    update: XOR<UserUpdateWithoutCampaignLeadInput, UserUncheckedUpdateWithoutCampaignLeadInput>
    create: XOR<UserCreateWithoutCampaignLeadInput, UserUncheckedCreateWithoutCampaignLeadInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignLeadInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignLeadInput, UserUncheckedUpdateWithoutCampaignLeadInput>
  }

  export type UserUpdateWithoutCampaignLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
    affiliate?: UserUpdateOneWithoutAffiliatesNestedInput
    affiliates?: UserUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    affiliates?: UserUncheckedUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageLogUpsertWithWhereUniqueWithoutCampaignLeadInput = {
    where: MessageLogWhereUniqueInput
    update: XOR<MessageLogUpdateWithoutCampaignLeadInput, MessageLogUncheckedUpdateWithoutCampaignLeadInput>
    create: XOR<MessageLogCreateWithoutCampaignLeadInput, MessageLogUncheckedCreateWithoutCampaignLeadInput>
  }

  export type MessageLogUpdateWithWhereUniqueWithoutCampaignLeadInput = {
    where: MessageLogWhereUniqueInput
    data: XOR<MessageLogUpdateWithoutCampaignLeadInput, MessageLogUncheckedUpdateWithoutCampaignLeadInput>
  }

  export type MessageLogUpdateManyWithWhereWithoutCampaignLeadInput = {
    where: MessageLogScalarWhereInput
    data: XOR<MessageLogUpdateManyMutationInput, MessageLogUncheckedUpdateManyWithoutCampaignLeadInput>
  }

  export type CampaignUpsertWithoutLeadsInput = {
    update: XOR<CampaignUpdateWithoutLeadsInput, CampaignUncheckedUpdateWithoutLeadsInput>
    create: XOR<CampaignCreateWithoutLeadsInput, CampaignUncheckedCreateWithoutLeadsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutLeadsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutLeadsInput, CampaignUncheckedUpdateWithoutLeadsInput>
  }

  export type CampaignUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUpdateManyWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
    instance?: InstanceUpdateOneWithoutCampaignsNestedInput
    CampaignErrorLog?: CampaignErrorLogUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignErrorLog?: CampaignErrorLogUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUncheckedUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUncheckedUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignCreateWithoutCampaignScheduleInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchCreateNestedManyWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
    instance?: InstanceCreateNestedOneWithoutCampaignsInput
    CampaignErrorLog?: CampaignErrorLogCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsCreateNestedManyWithoutCampaignInput
    contacts?: ContactCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutCampaignScheduleInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutCampaignInput
    CampaignErrorLog?: CampaignErrorLogUncheckedCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsUncheckedCreateNestedManyWithoutCampaignInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignCreateOrConnectWithoutCampaignScheduleInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaignScheduleInput, CampaignUncheckedCreateWithoutCampaignScheduleInput>
  }

  export type InstanceCreateWithoutCampaignSchedulesInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutInstancesInput
    campaigns?: CampaignCreateNestedManyWithoutInstanceInput
    campaignDispatches?: CampaignDispatchCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutInstanceInput
    mediaStats?: MediaStatsCreateNestedManyWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutCampaignSchedulesInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedCreateNestedManyWithoutInstanceInput
    campaignDispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutInstanceInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutInstanceInput
    mediaStats?: MediaStatsUncheckedCreateNestedManyWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutCampaignSchedulesInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutCampaignSchedulesInput, InstanceUncheckedCreateWithoutCampaignSchedulesInput>
  }

  export type CampaignUpsertWithoutCampaignScheduleInput = {
    update: XOR<CampaignUpdateWithoutCampaignScheduleInput, CampaignUncheckedUpdateWithoutCampaignScheduleInput>
    create: XOR<CampaignCreateWithoutCampaignScheduleInput, CampaignUncheckedCreateWithoutCampaignScheduleInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCampaignScheduleInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCampaignScheduleInput, CampaignUncheckedUpdateWithoutCampaignScheduleInput>
  }

  export type CampaignUpdateWithoutCampaignScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUpdateManyWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
    instance?: InstanceUpdateOneWithoutCampaignsNestedInput
    CampaignErrorLog?: CampaignErrorLogUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaignScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignErrorLog?: CampaignErrorLogUncheckedUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUncheckedUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type InstanceUpsertWithoutCampaignSchedulesInput = {
    update: XOR<InstanceUpdateWithoutCampaignSchedulesInput, InstanceUncheckedUpdateWithoutCampaignSchedulesInput>
    create: XOR<InstanceCreateWithoutCampaignSchedulesInput, InstanceUncheckedCreateWithoutCampaignSchedulesInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutCampaignSchedulesInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutCampaignSchedulesInput, InstanceUncheckedUpdateWithoutCampaignSchedulesInput>
  }

  export type InstanceUpdateWithoutCampaignSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutInstancesNestedInput
    campaigns?: CampaignUpdateManyWithoutInstanceNestedInput
    campaignDispatches?: CampaignDispatchUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutInstanceNestedInput
    mediaStats?: MediaStatsUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutCampaignSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedUpdateManyWithoutInstanceNestedInput
    campaignDispatches?: CampaignDispatchUncheckedUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutInstanceNestedInput
    mediaStats?: MediaStatsUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type CampaignCreateWithoutStatisticsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    dispatches?: CampaignDispatchCreateNestedManyWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
    instance?: InstanceCreateNestedOneWithoutCampaignsInput
    CampaignErrorLog?: CampaignErrorLogCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsCreateNestedManyWithoutCampaignInput
    contacts?: ContactCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutStatisticsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    dispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutCampaignInput
    CampaignErrorLog?: CampaignErrorLogUncheckedCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleUncheckedCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsUncheckedCreateNestedManyWithoutCampaignInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignCreateOrConnectWithoutStatisticsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutStatisticsInput, CampaignUncheckedCreateWithoutStatisticsInput>
  }

  export type CampaignUpsertWithoutStatisticsInput = {
    update: XOR<CampaignUpdateWithoutStatisticsInput, CampaignUncheckedUpdateWithoutStatisticsInput>
    create: XOR<CampaignCreateWithoutStatisticsInput, CampaignUncheckedCreateWithoutStatisticsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutStatisticsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutStatisticsInput, CampaignUncheckedUpdateWithoutStatisticsInput>
  }

  export type CampaignUpdateWithoutStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUpdateManyWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
    instance?: InstanceUpdateOneWithoutCampaignsNestedInput
    CampaignErrorLog?: CampaignErrorLogUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutStatisticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignErrorLog?: CampaignErrorLogUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUncheckedUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUncheckedUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignCreateWithoutMessageLogInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchCreateNestedManyWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
    instance?: InstanceCreateNestedOneWithoutCampaignsInput
    CampaignErrorLog?: CampaignErrorLogCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsCreateNestedManyWithoutCampaignInput
    contacts?: ContactCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutMessageLogInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutCampaignInput
    CampaignErrorLog?: CampaignErrorLogUncheckedCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleUncheckedCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsUncheckedCreateNestedManyWithoutCampaignInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignCreateOrConnectWithoutMessageLogInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMessageLogInput, CampaignUncheckedCreateWithoutMessageLogInput>
  }

  export type CampaignLeadCreateWithoutMessageLogsInput = {
    id?: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    segment?: string | null
    engagement?: string | null
    syncedWithCRM?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignLeadInput
    campaign: CampaignCreateNestedOneWithoutLeadsInput
  }

  export type CampaignLeadUncheckedCreateWithoutMessageLogsInput = {
    id?: string
    userId: string
    campaignId: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    segment?: string | null
    engagement?: string | null
    syncedWithCRM?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignLeadCreateOrConnectWithoutMessageLogsInput = {
    where: CampaignLeadWhereUniqueInput
    create: XOR<CampaignLeadCreateWithoutMessageLogsInput, CampaignLeadUncheckedCreateWithoutMessageLogsInput>
  }

  export type LeadCreateWithoutMessageLogInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string
    updatedat?: Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
    config: CompaniesUnitesCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutMessageLogInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    configid: string
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string
    updatedat?: Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LeadCreateOrConnectWithoutMessageLogInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutMessageLogInput, LeadUncheckedCreateWithoutMessageLogInput>
  }

  export type CampaignUpsertWithoutMessageLogInput = {
    update: XOR<CampaignUpdateWithoutMessageLogInput, CampaignUncheckedUpdateWithoutMessageLogInput>
    create: XOR<CampaignCreateWithoutMessageLogInput, CampaignUncheckedCreateWithoutMessageLogInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMessageLogInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMessageLogInput, CampaignUncheckedUpdateWithoutMessageLogInput>
  }

  export type CampaignUpdateWithoutMessageLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUpdateManyWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
    instance?: InstanceUpdateOneWithoutCampaignsNestedInput
    CampaignErrorLog?: CampaignErrorLogUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMessageLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignErrorLog?: CampaignErrorLogUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUncheckedUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUncheckedUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignLeadUpsertWithoutMessageLogsInput = {
    update: XOR<CampaignLeadUpdateWithoutMessageLogsInput, CampaignLeadUncheckedUpdateWithoutMessageLogsInput>
    create: XOR<CampaignLeadCreateWithoutMessageLogsInput, CampaignLeadUncheckedCreateWithoutMessageLogsInput>
    where?: CampaignLeadWhereInput
  }

  export type CampaignLeadUpdateToOneWithWhereWithoutMessageLogsInput = {
    where?: CampaignLeadWhereInput
    data: XOR<CampaignLeadUpdateWithoutMessageLogsInput, CampaignLeadUncheckedUpdateWithoutMessageLogsInput>
  }

  export type CampaignLeadUpdateWithoutMessageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: NullableStringFieldUpdateOperationsInput | string | null
    syncedWithCRM?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignLeadNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type CampaignLeadUncheckedUpdateWithoutMessageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: NullableStringFieldUpdateOperationsInput | string | null
    syncedWithCRM?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpsertWithoutMessageLogInput = {
    update: XOR<LeadUpdateWithoutMessageLogInput, LeadUncheckedUpdateWithoutMessageLogInput>
    create: XOR<LeadCreateWithoutMessageLogInput, LeadUncheckedCreateWithoutMessageLogInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutMessageLogInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutMessageLogInput, LeadUncheckedUpdateWithoutMessageLogInput>
  }

  export type LeadUpdateWithoutMessageLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: DateTimeFieldUpdateOperationsInput | Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
    config?: CompaniesUnitesUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutMessageLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    configid?: StringFieldUpdateOperationsInput | string
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: DateTimeFieldUpdateOperationsInput | Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignCreateWithoutMessageAnalyticsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchCreateNestedManyWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
    instance?: InstanceCreateNestedOneWithoutCampaignsInput
    CampaignErrorLog?: CampaignErrorLogCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleCreateNestedManyWithoutCampaignInput
    contacts?: ContactCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutMessageAnalyticsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutCampaignInput
    CampaignErrorLog?: CampaignErrorLogUncheckedCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleUncheckedCreateNestedManyWithoutCampaignInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignCreateOrConnectWithoutMessageAnalyticsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMessageAnalyticsInput, CampaignUncheckedCreateWithoutMessageAnalyticsInput>
  }

  export type CampaignUpsertWithoutMessageAnalyticsInput = {
    update: XOR<CampaignUpdateWithoutMessageAnalyticsInput, CampaignUncheckedUpdateWithoutMessageAnalyticsInput>
    create: XOR<CampaignCreateWithoutMessageAnalyticsInput, CampaignUncheckedCreateWithoutMessageAnalyticsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMessageAnalyticsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMessageAnalyticsInput, CampaignUncheckedUpdateWithoutMessageAnalyticsInput>
  }

  export type CampaignUpdateWithoutMessageAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUpdateManyWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
    instance?: InstanceUpdateOneWithoutCampaignsNestedInput
    CampaignErrorLog?: CampaignErrorLogUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMessageAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignErrorLog?: CampaignErrorLogUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUncheckedUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type UserCreateWithoutContactsInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutUserInput
    affiliate?: UserCreateNestedOneWithoutAffiliatesInput
    affiliates?: UserCreateNestedManyWithoutAffiliateInput
    Message?: MessageCreateNestedManyWithoutUserInput
    Conversation?: ConversationCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContactsInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutUserInput
    affiliates?: UserUncheckedCreateNestedManyWithoutAffiliateInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    Conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
  }

  export type CampaignCreateWithoutContactsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchCreateNestedManyWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
    instance?: InstanceCreateNestedOneWithoutCampaignsInput
    CampaignErrorLog?: CampaignErrorLogCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutCampaignInput
    CampaignErrorLog?: CampaignErrorLogUncheckedCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleUncheckedCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutContactsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutContactsInput, CampaignUncheckedCreateWithoutContactsInput>
  }

  export type ConversationCreateWithoutContactInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    user: UserCreateNestedOneWithoutConversationInput
    MessageReaction?: MessageReactionCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutContactInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    userId: string
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    MessageReaction?: MessageReactionUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutContactInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput>
  }

  export type ConversationCreateManyContactInputEnvelope = {
    data: ConversationCreateManyContactInput | ConversationCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactNoteCreateWithoutContactInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContactNotesInput
  }

  export type ContactNoteUncheckedCreateWithoutContactInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ContactNoteCreateOrConnectWithoutContactInput = {
    where: ContactNoteWhereUniqueInput
    create: XOR<ContactNoteCreateWithoutContactInput, ContactNoteUncheckedCreateWithoutContactInput>
  }

  export type ContactNoteCreateManyContactInputEnvelope = {
    data: ContactNoteCreateManyContactInput | ContactNoteCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutContactsInput = {
    update: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
  }

  export type UserUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutUserNestedInput
    affiliate?: UserUpdateOneWithoutAffiliatesNestedInput
    affiliates?: UserUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutUserNestedInput
    affiliates?: UserUncheckedUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutContactsInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutContactsInput, CampaignUncheckedUpdateWithoutContactsInput>
    create: XOR<CampaignCreateWithoutContactsInput, CampaignUncheckedCreateWithoutContactsInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutContactsInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutContactsInput, CampaignUncheckedUpdateWithoutContactsInput>
  }

  export type CampaignUpdateManyWithWhereWithoutContactsInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutContactsInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutContactInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutContactInput, ConversationUncheckedUpdateWithoutContactInput>
    create: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutContactInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutContactInput, ConversationUncheckedUpdateWithoutContactInput>
  }

  export type ConversationUpdateManyWithWhereWithoutContactInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactNoteUpsertWithWhereUniqueWithoutContactInput = {
    where: ContactNoteWhereUniqueInput
    update: XOR<ContactNoteUpdateWithoutContactInput, ContactNoteUncheckedUpdateWithoutContactInput>
    create: XOR<ContactNoteCreateWithoutContactInput, ContactNoteUncheckedCreateWithoutContactInput>
  }

  export type ContactNoteUpdateWithWhereUniqueWithoutContactInput = {
    where: ContactNoteWhereUniqueInput
    data: XOR<ContactNoteUpdateWithoutContactInput, ContactNoteUncheckedUpdateWithoutContactInput>
  }

  export type ContactNoteUpdateManyWithWhereWithoutContactInput = {
    where: ContactNoteScalarWhereInput
    data: XOR<ContactNoteUpdateManyMutationInput, ContactNoteUncheckedUpdateManyWithoutContactInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    messageId: string
    content: string
    type?: string
    sender: string
    status?: $Enums.MessageStatus
    timestamp: Date | string
    mediaUrl?: string | null
    mediaType?: string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    messageId: string
    content: string
    type?: string
    sender: string
    status?: $Enums.MessageStatus
    timestamp: Date | string
    mediaUrl?: string | null
    mediaType?: string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    failureReason?: string | null
    createdAt?: Date | string
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutConversationsInput = {
    id?: string
    phone: string
    name?: string | null
    email?: string | null
    company?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    lastInteractionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    source?: string | null
    user: UserCreateNestedOneWithoutContactsInput
    campaigns?: CampaignCreateNestedManyWithoutContactsInput
    contactNotes?: ContactNoteCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutConversationsInput = {
    id?: string
    phone: string
    name?: string | null
    email?: string | null
    company?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    userId: string
    lastInteractionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    source?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutContactsInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutConversationsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutConversationsInput, ContactUncheckedCreateWithoutConversationsInput>
  }

  export type UserCreateWithoutConversationInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutUserInput
    affiliate?: UserCreateNestedOneWithoutAffiliatesInput
    affiliates?: UserCreateNestedManyWithoutAffiliateInput
    Message?: MessageCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutUserInput
    affiliates?: UserUncheckedCreateNestedManyWithoutAffiliateInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationInput, UserUncheckedCreateWithoutConversationInput>
  }

  export type MessageReactionCreateWithoutConversationInput = {
    id?: string
    messageId: string
    reaction: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageReactionUncheckedCreateWithoutConversationInput = {
    id?: string
    messageId: string
    reaction: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageReactionCreateOrConnectWithoutConversationInput = {
    where: MessageReactionWhereUniqueInput
    create: XOR<MessageReactionCreateWithoutConversationInput, MessageReactionUncheckedCreateWithoutConversationInput>
  }

  export type MessageReactionCreateManyConversationInputEnvelope = {
    data: MessageReactionCreateManyConversationInput | MessageReactionCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ContactUpsertWithoutConversationsInput = {
    update: XOR<ContactUpdateWithoutConversationsInput, ContactUncheckedUpdateWithoutConversationsInput>
    create: XOR<ContactCreateWithoutConversationsInput, ContactUncheckedCreateWithoutConversationsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutConversationsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutConversationsInput, ContactUncheckedUpdateWithoutConversationsInput>
  }

  export type ContactUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
    campaigns?: CampaignUpdateManyWithoutContactsNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutContactsNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserUpsertWithoutConversationInput = {
    update: XOR<UserUpdateWithoutConversationInput, UserUncheckedUpdateWithoutConversationInput>
    create: XOR<UserCreateWithoutConversationInput, UserUncheckedCreateWithoutConversationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationInput, UserUncheckedUpdateWithoutConversationInput>
  }

  export type UserUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutUserNestedInput
    affiliate?: UserUpdateOneWithoutAffiliatesNestedInput
    affiliates?: UserUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutUserNestedInput
    affiliates?: UserUncheckedUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageReactionUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageReactionWhereUniqueInput
    update: XOR<MessageReactionUpdateWithoutConversationInput, MessageReactionUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageReactionCreateWithoutConversationInput, MessageReactionUncheckedCreateWithoutConversationInput>
  }

  export type MessageReactionUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageReactionWhereUniqueInput
    data: XOR<MessageReactionUpdateWithoutConversationInput, MessageReactionUncheckedUpdateWithoutConversationInput>
  }

  export type MessageReactionUpdateManyWithWhereWithoutConversationInput = {
    where: MessageReactionScalarWhereInput
    data: XOR<MessageReactionUpdateManyMutationInput, MessageReactionUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageReactionScalarWhereInput = {
    AND?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
    OR?: MessageReactionScalarWhereInput[]
    NOT?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
    id?: StringFilter<"MessageReaction"> | string
    messageId?: StringFilter<"MessageReaction"> | string
    conversationId?: StringFilter<"MessageReaction"> | string
    reaction?: StringFilter<"MessageReaction"> | string
    userId?: StringFilter<"MessageReaction"> | string
    createdAt?: DateTimeFilter<"MessageReaction"> | Date | string
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: ContactCreateNestedOneWithoutConversationsInput
    user: UserCreateNestedOneWithoutConversationInput
    MessageReaction?: MessageReactionCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    contactId?: string | null
    userId: string
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    MessageReaction?: MessageReactionUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessageInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutUserInput
    affiliate?: UserCreateNestedOneWithoutAffiliatesInput
    affiliates?: UserCreateNestedManyWithoutAffiliateInput
    Conversation?: ConversationCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessageInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutUserInput
    affiliates?: UserUncheckedCreateNestedManyWithoutAffiliateInput
    Conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    contactNotes?: ContactNoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentCreateWithoutMessageInput = {
    id?: string
    type: string
    url: string
    name?: string | null
    mimeType?: string | null
    filename?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type MessageAttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    type: string
    url: string
    name?: string | null
    mimeType?: string | null
    filename?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type MessageAttachmentCreateOrConnectWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentCreateManyMessageInputEnvelope = {
    data: MessageAttachmentCreateManyMessageInput | MessageAttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneWithoutConversationsNestedInput
    user?: UserUpdateOneRequiredWithoutConversationNestedInput
    MessageReaction?: MessageReactionUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MessageReaction?: MessageReactionUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutMessageInput = {
    update: XOR<UserUpdateWithoutMessageInput, UserUncheckedUpdateWithoutMessageInput>
    create: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageInput, UserUncheckedUpdateWithoutMessageInput>
  }

  export type UserUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutUserNestedInput
    affiliate?: UserUpdateOneWithoutAffiliatesNestedInput
    affiliates?: UserUpdateManyWithoutAffiliateNestedInput
    Conversation?: ConversationUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutUserNestedInput
    affiliates?: UserUncheckedUpdateManyWithoutAffiliateNestedInput
    Conversation?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    update: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    data: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: MessageAttachmentScalarWhereInput
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageAttachmentScalarWhereInput = {
    AND?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    OR?: MessageAttachmentScalarWhereInput[]
    NOT?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    messageId?: StringFilter<"MessageAttachment"> | string
    type?: StringFilter<"MessageAttachment"> | string
    url?: StringFilter<"MessageAttachment"> | string
    name?: StringNullableFilter<"MessageAttachment"> | string | null
    mimeType?: StringNullableFilter<"MessageAttachment"> | string | null
    filename?: StringNullableFilter<"MessageAttachment"> | string | null
    size?: IntNullableFilter<"MessageAttachment"> | number | null
    createdAt?: DateTimeFilter<"MessageAttachment"> | Date | string
  }

  export type MessageCreateWithoutAttachmentsInput = {
    id?: string
    messageId: string
    content: string
    type?: string
    sender: string
    status?: $Enums.MessageStatus
    timestamp: Date | string
    mediaUrl?: string | null
    mediaType?: string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    conversationId: string
    messageId: string
    content: string
    type?: string
    sender: string
    status?: $Enums.MessageStatus
    timestamp: Date | string
    mediaUrl?: string | null
    mediaType?: string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutAttachmentsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type MessageUpsertWithoutAttachmentsInput = {
    update: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateWithoutCampaignErrorLogInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchCreateNestedManyWithoutCampaignInput
    user: UserCreateNestedOneWithoutCampaignInput
    instance?: InstanceCreateNestedOneWithoutCampaignsInput
    CampaignSchedule?: CampaignScheduleCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsCreateNestedManyWithoutCampaignInput
    contacts?: ContactCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutCampaignErrorLogInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedCreateNestedManyWithoutCampaignInput
    leads?: CampaignLeadUncheckedCreateNestedManyWithoutCampaignInput
    messages?: CampaignMessageUncheckedCreateNestedManyWithoutCampaignInput
    statistics?: CampaignStatisticsUncheckedCreateNestedOneWithoutCampaignInput
    dispatches?: CampaignDispatchUncheckedCreateNestedManyWithoutCampaignInput
    CampaignSchedule?: CampaignScheduleUncheckedCreateNestedManyWithoutCampaignInput
    MessageAnalytics?: MessageAnalyticsUncheckedCreateNestedManyWithoutCampaignInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignCreateOrConnectWithoutCampaignErrorLogInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaignErrorLogInput, CampaignUncheckedCreateWithoutCampaignErrorLogInput>
  }

  export type CampaignUpsertWithoutCampaignErrorLogInput = {
    update: XOR<CampaignUpdateWithoutCampaignErrorLogInput, CampaignUncheckedUpdateWithoutCampaignErrorLogInput>
    create: XOR<CampaignCreateWithoutCampaignErrorLogInput, CampaignUncheckedCreateWithoutCampaignErrorLogInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCampaignErrorLogInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCampaignErrorLogInput, CampaignUncheckedUpdateWithoutCampaignErrorLogInput>
  }

  export type CampaignUpdateWithoutCampaignErrorLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUpdateManyWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
    instance?: InstanceUpdateOneWithoutCampaignsNestedInput
    CampaignSchedule?: CampaignScheduleUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaignErrorLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUncheckedUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUncheckedUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type ContactCreateWithoutContactNotesInput = {
    id?: string
    phone: string
    name?: string | null
    email?: string | null
    company?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    lastInteractionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    source?: string | null
    user: UserCreateNestedOneWithoutContactsInput
    campaigns?: CampaignCreateNestedManyWithoutContactsInput
    conversations?: ConversationCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutContactNotesInput = {
    id?: string
    phone: string
    name?: string | null
    email?: string | null
    company?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    userId: string
    lastInteractionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    source?: string | null
    campaigns?: CampaignUncheckedCreateNestedManyWithoutContactsInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutContactNotesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutContactNotesInput, ContactUncheckedCreateWithoutContactNotesInput>
  }

  export type UserCreateWithoutContactNotesInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
    instances?: InstanceCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsCreateNestedManyWithoutUserInput
    Campaign?: CampaignCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutWhatleadUserInput
    CampaignLead?: CampaignLeadCreateNestedManyWithoutUserInput
    affiliate?: UserCreateNestedOneWithoutAffiliatesInput
    affiliates?: UserCreateNestedManyWithoutAffiliateInput
    Message?: MessageCreateNestedManyWithoutUserInput
    Conversation?: ConversationCreateNestedManyWithoutUserInput
    contacts?: ContactCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContactNotesInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
    instances?: InstanceUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    warmupStats?: WarmupStatsUncheckedCreateNestedManyWithoutUserInput
    Campaign?: CampaignUncheckedCreateNestedManyWithoutUserInput
    CampaignLead?: CampaignLeadUncheckedCreateNestedManyWithoutUserInput
    affiliates?: UserUncheckedCreateNestedManyWithoutAffiliateInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    Conversation?: ConversationUncheckedCreateNestedManyWithoutUserInput
    contacts?: ContactUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContactNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactNotesInput, UserUncheckedCreateWithoutContactNotesInput>
  }

  export type ContactUpsertWithoutContactNotesInput = {
    update: XOR<ContactUpdateWithoutContactNotesInput, ContactUncheckedUpdateWithoutContactNotesInput>
    create: XOR<ContactCreateWithoutContactNotesInput, ContactUncheckedCreateWithoutContactNotesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutContactNotesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutContactNotesInput, ContactUncheckedUpdateWithoutContactNotesInput>
  }

  export type ContactUpdateWithoutContactNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
    campaigns?: CampaignUpdateManyWithoutContactsNestedInput
    conversations?: ConversationUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutContactNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutContactsNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserUpsertWithoutContactNotesInput = {
    update: XOR<UserUpdateWithoutContactNotesInput, UserUncheckedUpdateWithoutContactNotesInput>
    create: XOR<UserCreateWithoutContactNotesInput, UserUncheckedCreateWithoutContactNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactNotesInput, UserUncheckedUpdateWithoutContactNotesInput>
  }

  export type UserUpdateWithoutContactNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutUserNestedInput
    affiliate?: UserUpdateOneWithoutAffiliatesNestedInput
    affiliates?: UserUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContactNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutUserNestedInput
    affiliates?: UserUncheckedUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConversationCreateWithoutMessageReactionInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    contact?: ContactCreateNestedOneWithoutConversationsInput
    user: UserCreateNestedOneWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessageReactionInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    contactId?: string | null
    userId: string
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessageReactionInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessageReactionInput, ConversationUncheckedCreateWithoutMessageReactionInput>
  }

  export type ConversationUpsertWithoutMessageReactionInput = {
    update: XOR<ConversationUpdateWithoutMessageReactionInput, ConversationUncheckedUpdateWithoutMessageReactionInput>
    create: XOR<ConversationCreateWithoutMessageReactionInput, ConversationUncheckedCreateWithoutMessageReactionInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessageReactionInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessageReactionInput, ConversationUncheckedUpdateWithoutMessageReactionInput>
  }

  export type ConversationUpdateWithoutMessageReactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    contact?: ContactUpdateOneWithoutConversationsNestedInput
    user?: UserUpdateOneRequiredWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessageReactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    referredBy?: string | null
    role?: string
  }

  export type CompaniesUnitesCreateManyCompanyInput = {
    id?: string
    createdAt?: Date | string | null
    name?: string | null
    productdefault?: string | null
    campaignstatus?: string | null
    enablecuration?: boolean | null
    enabletosendustolead?: boolean | null
    enabled?: boolean | null
    isconversationia?: boolean | null
    campaignnumberbusiness?: string | null
    whatsappprovider?: string | null
    enabletosendprovider?: boolean | null
    enabletosecondcallprovider?: boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: string | null
    templatelistvars?: CompaniesUnitesCreatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesCreatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string | null
    whitelabel_config: string
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutUserNestedInput
    affiliate?: UserUpdateOneWithoutAffiliatesNestedInput
    affiliates?: UserUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutUserNestedInput
    affiliates?: UserUncheckedUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
  }

  export type CompaniesUnitesUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    leads?: LeadUpdateManyWithoutConfigNestedInput
  }

  export type CompaniesUnitesUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
    leads?: LeadUncheckedUpdateManyWithoutConfigNestedInput
  }

  export type CompaniesUnitesUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    productdefault?: NullableStringFieldUpdateOperationsInput | string | null
    campaignstatus?: NullableStringFieldUpdateOperationsInput | string | null
    enablecuration?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosendustolead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isconversationia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    campaignnumberbusiness?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappprovider?: NullableStringFieldUpdateOperationsInput | string | null
    enabletosendprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enabletosecondcallprovider?: NullableBoolFieldUpdateOperationsInput | boolean | null
    integrationconfiguration?: NullableJsonNullValueInput | InputJsonValue
    integrationname?: NullableStringFieldUpdateOperationsInput | string | null
    templatelistvars?: CompaniesUnitesUpdatetemplatelistvarsInput | InputJsonValue[]
    metaconfiguration?: NullableJsonNullValueInput | InputJsonValue
    messageperruns?: CompaniesUnitesUpdatemessageperrunsInput | InputJsonValue[]
    notifyconfiguration?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whitelabel_config?: StringFieldUpdateOperationsInput | string
  }

  export type InstanceCreateManyUserInput = {
    id?: string
    instanceName: string
    connectionStatus?: $Enums.InstanceStatus
    number?: string | null
    ownerJid?: string | null
    profilePicUrl?: string | null
    integration?: string
    token?: string | null
    clientName?: string | null
    profileName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    disconnectedAt?: Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    stripePaymentId: string
    amount: number
    currency: string
    status: string
    dueDate: Date | string
    customerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: string | null
    disputeReason?: string | null
    cancelReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarmupStatsCreateManyUserInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
    mediaReceivedId?: string | null
  }

  export type CampaignCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    instanceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignLeadCreateManyUserInput = {
    id?: string
    campaignId: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    segment?: string | null
    engagement?: string | null
    syncedWithCRM?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyAffiliateInput = {
    id?: string
    email: string
    name: string
    password: string
    profile: string
    phone: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    stripeSubscriptionStatus?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whatleadCompanyId: string
    plan?: string
    status?: boolean
    maxInstances?: number
    messagesPerDay?: number
    features?: UserCreatefeaturesInput | string[]
    support?: string
    trialEndDate?: Date | string | null
    role?: string
  }

  export type MessageCreateManyUserInput = {
    id?: string
    conversationId: string
    messageId: string
    content: string
    type?: string
    sender: string
    status?: $Enums.MessageStatus
    timestamp: Date | string
    mediaUrl?: string | null
    mediaType?: string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type ConversationCreateManyUserInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    contactId?: string | null
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyUserInput = {
    id?: string
    phone: string
    name?: string | null
    email?: string | null
    company?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    lastInteractionAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    source?: string | null
  }

  export type ContactNoteCreateManyUserInput = {
    id?: string
    contactId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUpdateManyWithoutInstanceNestedInput
    campaignSchedules?: CampaignScheduleUpdateManyWithoutInstanceNestedInput
    campaignDispatches?: CampaignDispatchUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutInstanceNestedInput
    mediaStats?: MediaStatsUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: CampaignUncheckedUpdateManyWithoutInstanceNestedInput
    campaignSchedules?: CampaignScheduleUncheckedUpdateManyWithoutInstanceNestedInput
    campaignDispatches?: CampaignDispatchUncheckedUpdateManyWithoutInstanceNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutInstanceNestedInput
    mediaStats?: MediaStatsUncheckedUpdateManyWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceStatusFieldUpdateOperationsInput | $Enums.InstanceStatus
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disconnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionReasonCode?: NullableStringFieldUpdateOperationsInput | string | null
    proxyConfig?: NullableJsonNullValueInput | InputJsonValue
    typebot?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripePaymentId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    disputeStatus?: NullableStringFieldUpdateOperationsInput | string | null
    disputeReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarmupStatsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutWarmupStatsNestedInput
    mediaReceived?: MediaStatsUpdateOneWithoutWarmupStatsReceivedNestedInput
    mediaStats?: MediaStatsUpdateOneWithoutWarmupStatsSentNestedInput
  }

  export type WarmupStatsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarmupStatsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUpdateManyWithoutCampaignNestedInput
    instance?: InstanceUpdateOneWithoutCampaignsNestedInput
    CampaignErrorLog?: CampaignErrorLogUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignErrorLog?: CampaignErrorLogUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUncheckedUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUncheckedUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignLeadUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: NullableStringFieldUpdateOperationsInput | string | null
    syncedWithCRM?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageLogs?: MessageLogUpdateManyWithoutCampaignLeadNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type CampaignLeadUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: NullableStringFieldUpdateOperationsInput | string | null
    syncedWithCRM?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageLogs?: MessageLogUncheckedUpdateManyWithoutCampaignLeadNestedInput
  }

  export type CampaignLeadUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: NullableStringFieldUpdateOperationsInput | string | null
    syncedWithCRM?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutWhatleadUserNestedInput
    CampaignLead?: CampaignLeadUpdateManyWithoutUserNestedInput
    affiliates?: UserUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUpdateManyWithoutUserNestedInput
    contacts?: ContactUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    instances?: InstanceUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    warmupStats?: WarmupStatsUncheckedUpdateManyWithoutUserNestedInput
    Campaign?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    CampaignLead?: CampaignLeadUncheckedUpdateManyWithoutUserNestedInput
    affiliates?: UserUncheckedUpdateManyWithoutAffiliateNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    Conversation?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatleadCompanyId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    maxInstances?: IntFieldUpdateOperationsInput | number
    messagesPerDay?: IntFieldUpdateOperationsInput | number
    features?: UserUpdatefeaturesInput | string[]
    support?: StringFieldUpdateOperationsInput | string
    trialEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    contact?: ContactUpdateOneWithoutConversationsNestedInput
    MessageReaction?: MessageReactionUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    MessageReaction?: MessageReactionUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUpdateManyWithoutContactsNestedInput
    conversations?: ConversationUpdateManyWithoutContactNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    campaigns?: CampaignUncheckedUpdateManyWithoutContactsNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactNoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutContactNotesNestedInput
  }

  export type ContactNoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyConfigInput = {
    id?: string
    externalid?: string | null
    sourceid?: string | null
    name: string
    phone: string
    email?: string | null
    lastmessagesent?: Date | string | null
    stepsecondcalltemplate?: number | null
    stepnointeraction?: number | null
    nointeractionquantity?: number | null
    accepttemplate?: boolean | null
    acceptsecondtemplate?: boolean | null
    status?: string | null
    dialog?: LeadCreatedialogInput | InputJsonValue[]
    whitelabelconfig: string
    lastintent?: string | null
    broker?: string | null
    origin?: string | null
    send?: boolean | null
    sendAt?: Date | string | null
    isBusinessAutoResponder?: boolean | null
    startmessage?: Date | string | null
    schedulingdata?: string | null
    productchoosebyclient?: string | null
    productid?: number | null
    createdat?: Date | string
    updatedat?: Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LeadUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: DateTimeFieldUpdateOperationsInput | Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: DateTimeFieldUpdateOperationsInput | Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalid?: NullableStringFieldUpdateOperationsInput | string | null
    sourceid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    lastmessagesent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsecondcalltemplate?: NullableIntFieldUpdateOperationsInput | number | null
    stepnointeraction?: NullableIntFieldUpdateOperationsInput | number | null
    nointeractionquantity?: NullableIntFieldUpdateOperationsInput | number | null
    accepttemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    acceptsecondtemplate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    dialog?: LeadUpdatedialogInput | InputJsonValue[]
    whitelabelconfig?: StringFieldUpdateOperationsInput | string
    lastintent?: NullableStringFieldUpdateOperationsInput | string | null
    broker?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    send?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBusinessAutoResponder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startmessage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedulingdata?: NullableStringFieldUpdateOperationsInput | string | null
    productchoosebyclient?: NullableStringFieldUpdateOperationsInput | string | null
    productid?: NullableIntFieldUpdateOperationsInput | number | null
    createdat?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedat?: DateTimeFieldUpdateOperationsInput | Date | string
    curation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageLogCreateManyLeadInput = {
    id?: string
    campaignId: string
    campaignLeadId: string
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageLogUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMessageLogNestedInput
    campaignLead?: CampaignLeadUpdateOneRequiredWithoutMessageLogsNestedInput
  }

  export type MessageLogUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignLeadId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLogUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    campaignLeadId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyInstanceInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    type: string
    message?: string | null
    mediaUrl?: string | null
    mediaType?: string | null
    mediaCaption?: string | null
    scheduledDate?: Date | string | null
    scheduledStatus?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    progress?: number
    minDelay?: number
    maxDelay?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignScheduleCreateManyInstanceInput = {
    id?: string
    campaignId: string
    scheduledDate: Date | string
    status?: string
    message?: string | null
    mediaType?: string | null
    mediaUrl?: string | null
    mediaCaption?: string | null
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type CampaignDispatchCreateManyInstanceInput = {
    id?: string
    campaignId: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarmupStatsCreateManyInstanceInput = {
    id?: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
    mediaReceivedId?: string | null
  }

  export type MediaStatsCreateManyInstanceInput = {
    id?: string
    date?: Date | string
    text?: number
    image?: number
    video?: number
    audio?: number
    sticker?: number
    reaction?: number
    isReceived?: boolean
    totalDaily?: number
    totalAllTime?: number
    totalSent?: number
    totalReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUpdateManyWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
    CampaignErrorLog?: CampaignErrorLogUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignErrorLog?: CampaignErrorLogUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUncheckedUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUncheckedUpdateManyWithoutCampaignNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignScheduleUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaign?: CampaignUpdateOneRequiredWithoutCampaignScheduleNestedInput
  }

  export type CampaignScheduleUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignScheduleUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignDispatchUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutDispatchesNestedInput
  }

  export type CampaignDispatchUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignDispatchUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarmupStatsUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaReceived?: MediaStatsUpdateOneWithoutWarmupStatsReceivedNestedInput
    mediaStats?: MediaStatsUpdateOneWithoutWarmupStatsSentNestedInput
    user?: UserUpdateOneRequiredWithoutWarmupStatsNestedInput
  }

  export type WarmupStatsUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarmupStatsUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaStatsUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warmupStatsReceived?: WarmupStatsUpdateManyWithoutMediaReceivedNestedInput
    warmupStatsSent?: WarmupStatsUpdateManyWithoutMediaStatsNestedInput
  }

  export type MediaStatsUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warmupStatsReceived?: WarmupStatsUncheckedUpdateManyWithoutMediaReceivedNestedInput
    warmupStatsSent?: WarmupStatsUncheckedUpdateManyWithoutMediaStatsNestedInput
  }

  export type MediaStatsUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: IntFieldUpdateOperationsInput | number
    image?: IntFieldUpdateOperationsInput | number
    video?: IntFieldUpdateOperationsInput | number
    audio?: IntFieldUpdateOperationsInput | number
    sticker?: IntFieldUpdateOperationsInput | number
    reaction?: IntFieldUpdateOperationsInput | number
    isReceived?: BoolFieldUpdateOperationsInput | boolean
    totalDaily?: IntFieldUpdateOperationsInput | number
    totalAllTime?: IntFieldUpdateOperationsInput | number
    totalSent?: IntFieldUpdateOperationsInput | number
    totalReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarmupStatsCreateManyMediaReceivedInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaStatsId?: string | null
  }

  export type WarmupStatsCreateManyMediaStatsInput = {
    id?: string
    instanceName: string
    status?: string
    messagesSent?: number
    messagesReceived?: number
    warmupTime?: number
    lastActive?: Date | string
    startTime?: Date | string | null
    pauseTime?: Date | string | null
    progress?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaReceivedId?: string | null
  }

  export type WarmupStatsUpdateWithoutMediaReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutWarmupStatsNestedInput
    mediaStats?: MediaStatsUpdateOneWithoutWarmupStatsSentNestedInput
    user?: UserUpdateOneRequiredWithoutWarmupStatsNestedInput
  }

  export type WarmupStatsUncheckedUpdateWithoutMediaReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarmupStatsUncheckedUpdateManyWithoutMediaReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaStatsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarmupStatsUpdateWithoutMediaStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutWarmupStatsNestedInput
    mediaReceived?: MediaStatsUpdateOneWithoutWarmupStatsReceivedNestedInput
    user?: UserUpdateOneRequiredWithoutWarmupStatsNestedInput
  }

  export type WarmupStatsUncheckedUpdateWithoutMediaStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarmupStatsUncheckedUpdateManyWithoutMediaStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    messagesSent?: IntFieldUpdateOperationsInput | number
    messagesReceived?: IntFieldUpdateOperationsInput | number
    warmupTime?: IntFieldUpdateOperationsInput | number
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaReceivedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageLogCreateManyCampaignInput = {
    id?: string
    campaignLeadId: string
    leadId?: string | null
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignLeadCreateManyCampaignInput = {
    id?: string
    userId: string
    name?: string | null
    phone: string
    status?: string
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    messageId?: string | null
    segment?: string | null
    engagement?: string | null
    syncedWithCRM?: boolean
    syncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignMessageCreateManyCampaignInput = {
    id?: string
    type: string
    content: string
    order: number
    caption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignDispatchCreateManyCampaignInput = {
    id?: string
    instanceName: string
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignErrorLogCreateManyCampaignInput = {
    id?: string
    errorMessage: string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignScheduleCreateManyCampaignInput = {
    id?: string
    instanceName: string
    scheduledDate: Date | string
    status?: string
    message?: string | null
    mediaType?: string | null
    mediaUrl?: string | null
    mediaCaption?: string | null
    minDelay?: number
    maxDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type MessageAnalyticsCreateManyCampaignInput = {
    id?: string
    date: Date | string
    sentCount?: number
    deliveredCount?: number
    readCount?: number
    respondedCount?: number
    failedCount?: number
  }

  export type MessageLogUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignLead?: CampaignLeadUpdateOneRequiredWithoutMessageLogsNestedInput
    lead?: LeadUpdateOneWithoutMessageLogNestedInput
  }

  export type MessageLogUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignLeadId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLogUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignLeadId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignLeadUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: NullableStringFieldUpdateOperationsInput | string | null
    syncedWithCRM?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignLeadNestedInput
    messageLogs?: MessageLogUpdateManyWithoutCampaignLeadNestedInput
  }

  export type CampaignLeadUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: NullableStringFieldUpdateOperationsInput | string | null
    syncedWithCRM?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageLogs?: MessageLogUncheckedUpdateManyWithoutCampaignLeadNestedInput
  }

  export type CampaignLeadUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    segment?: NullableStringFieldUpdateOperationsInput | string | null
    engagement?: NullableStringFieldUpdateOperationsInput | string | null
    syncedWithCRM?: BoolFieldUpdateOperationsInput | boolean
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMessageUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMessageUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMessageUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignDispatchUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instance?: InstanceUpdateOneRequiredWithoutCampaignDispatchesNestedInput
  }

  export type CampaignDispatchUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignDispatchUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignErrorLogUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignErrorLogUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignErrorLogUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    errorMessage?: StringFieldUpdateOperationsInput | string
    errorDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignScheduleUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance?: InstanceUpdateOneRequiredWithoutCampaignSchedulesNestedInput
  }

  export type CampaignScheduleUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignScheduleUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageAnalyticsUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    respondedCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
  }

  export type MessageAnalyticsUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    respondedCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
  }

  export type MessageAnalyticsUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sentCount?: IntFieldUpdateOperationsInput | number
    deliveredCount?: IntFieldUpdateOperationsInput | number
    readCount?: IntFieldUpdateOperationsInput | number
    respondedCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
  }

  export type ContactUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
    conversations?: ConversationUpdateManyWithoutContactNestedInput
    contactNotes?: ContactNoteUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
    contactNotes?: ContactNoteUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    lastInteractionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageLogCreateManyCampaignLeadInput = {
    id?: string
    campaignId: string
    leadId?: string | null
    messageId: string
    messageDate: Date | string
    messageType: string
    content: string
    status: string
    statusHistory?: MessageLogCreatestatusHistoryInput | InputJsonValue[]
    sentAt?: Date | string | null
    deliveredAt?: Date | string | null
    readAt?: Date | string | null
    failedAt?: Date | string | null
    failureReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageLogUpdateWithoutCampaignLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMessageLogNestedInput
    lead?: LeadUpdateOneWithoutMessageLogNestedInput
  }

  export type MessageLogUncheckedUpdateWithoutCampaignLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageLogUncheckedUpdateManyWithoutCampaignLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    messageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageType?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    statusHistory?: MessageLogUpdatestatusHistoryInput | InputJsonValue[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateManyContactInput = {
    id?: string
    instanceName: string
    contactPhone: string
    contactName?: string | null
    contactAvatar?: string | null
    lastMessageAt?: Date | string
    status?: string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    userId: string
    isGroup?: boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactNoteCreateManyContactInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type CampaignUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUpdateManyWithoutCampaignNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignNestedInput
    instance?: InstanceUpdateOneWithoutCampaignsNestedInput
    CampaignErrorLog?: CampaignErrorLogUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
    MessageLog?: MessageLogUncheckedUpdateManyWithoutCampaignNestedInput
    leads?: CampaignLeadUncheckedUpdateManyWithoutCampaignNestedInput
    messages?: CampaignMessageUncheckedUpdateManyWithoutCampaignNestedInput
    statistics?: CampaignStatisticsUncheckedUpdateOneWithoutCampaignNestedInput
    dispatches?: CampaignDispatchUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignErrorLog?: CampaignErrorLogUncheckedUpdateManyWithoutCampaignNestedInput
    CampaignSchedule?: CampaignScheduleUncheckedUpdateManyWithoutCampaignNestedInput
    MessageAnalytics?: MessageAnalyticsUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaCaption?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStatus?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: IntFieldUpdateOperationsInput | number
    minDelay?: IntFieldUpdateOperationsInput | number
    maxDelay?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    instanceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isAiResponder?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ConversationUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    user?: UserUpdateOneRequiredWithoutConversationNestedInput
    MessageReaction?: MessageReactionUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    MessageReaction?: MessageReactionUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    instanceName?: StringFieldUpdateOperationsInput | string
    contactPhone?: StringFieldUpdateOperationsInput | string
    contactName?: NullableStringFieldUpdateOperationsInput | string | null
    contactAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactNoteUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContactNotesNestedInput
  }

  export type ContactNoteUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactNoteUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    messageId: string
    content: string
    type?: string
    sender: string
    status?: $Enums.MessageStatus
    timestamp: Date | string
    mediaUrl?: string | null
    mediaType?: string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    userId: string
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type MessageReactionCreateManyConversationInput = {
    id?: string
    messageId: string
    reaction: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    replyTo?: NullableJsonNullValueInput | InputJsonValue
    userId?: StringFieldUpdateOperationsInput | string
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    reaction?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateManyMessageInput = {
    id?: string
    type: string
    url: string
    name?: string | null
    mimeType?: string | null
    filename?: string | null
    size?: number | null
    createdAt?: Date | string
  }

  export type MessageAttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}